diff -ruN minetest-master/src/emerge.cpp minetest-freeminer/src/emerge.cpp
--- minetest-master/src/emerge.cpp	2016-09-03 16:15:52.697779000 -0700
+++ minetest-freeminer/src/emerge.cpp	2016-09-03 15:44:00.006741000 -0700
@@ -1,24 +1,26 @@
 /*
-Minetest
+emerge.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
 Copyright (C) 2010-2013 kwolekr, Ryan Kwolek <kwolekr@minetest.net>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
-
 #include "emerge.h"
 
 #include <iostream>
@@ -31,7 +33,7 @@
 #include "config.h"
 #include "constants.h"
 #include "environment.h"
-#include "log.h"
+#include "log_types.h"
 #include "map.h"
 #include "mapblock.h"
 #include "mg_biome.h"
@@ -46,7 +48,9 @@
 #include "settings.h"
 #include "voxel.h"
 
-class EmergeThread : public Thread {
+#include "threading/thread_pool.h"
+
+class EmergeThread : public thread_pool {
 public:
 	bool enable_mapgen_debug_info;
 	int id;
@@ -109,23 +113,28 @@
 	// some other misc thread
 	s16 nthreads = 0;
 	if (!g_settings->getS16NoEx("num_emerge_threads", nthreads))
+	{}
+#if ENABLE_THREADS
+	if (nthreads < 1)
 		nthreads = Thread::getNumberOfProcessors() - 2;
+#endif
 	if (nthreads < 1)
 		nthreads = 1;
 
 	m_qlimit_total = g_settings->getU16("emergequeue_limit_total");
 	if (!g_settings->getU16NoEx("emergequeue_limit_diskonly", m_qlimit_diskonly))
-		m_qlimit_diskonly = nthreads * 5 + 1;
+		{ }
 	if (!g_settings->getU16NoEx("emergequeue_limit_generate", m_qlimit_generate))
-		m_qlimit_generate = nthreads + 1;
+		{ }
+	//errorstream<<"==> qlimit_generate="<<qlimit_generate<<"  qlimit_diskonly="<<qlimit_diskonly<<" qlimit_total="<<qlimit_total<<std::endl;
 
 	// don't trust user input for something very important like this
 	if (m_qlimit_total < 1)
-		m_qlimit_total = 1;
+		m_qlimit_total = nthreads * 128;
 	if (m_qlimit_diskonly < 1)
-		m_qlimit_diskonly = 1;
+		m_qlimit_diskonly = nthreads * 100;
 	if (m_qlimit_generate < 1)
-		m_qlimit_generate = 1;
+		m_qlimit_generate = nthreads * 32;
 
 	for (s16 i = 0; i < nthreads; i++)
 		m_threads.push_back(new EmergeThread((Server *)gamedef, i));
@@ -165,9 +174,13 @@
 
 	for (u32 i = 0; i != m_threads.size(); i++) {
 		Mapgen *mg = Mapgen::createMapgen(params->mgtype, i, params, this);
+		if (!mg)
+			continue;
 		m_mapgens.push_back(mg);
 	}
 
+	biomemgr->mapgen_params = params;
+
 	return true;
 }
 
@@ -338,7 +351,6 @@
 	if ((flags & BLOCK_EMERGE_FORCE_QUEUE) == 0) {
 		if (m_blocks_enqueued.size() >= m_qlimit_total)
 			return false;
-
 		if (peer_requested != PEER_ID_INEXISTENT) {
 			u16 qlimit_peer = (flags & BLOCK_EMERGE_ALLOW_GEN) ?
 				m_qlimit_generate : m_qlimit_diskonly;
@@ -503,24 +515,47 @@
 }
 
 
+
+
 EmergeAction EmergeThread::getBlockOrStartGen(
 	v3s16 pos, bool allow_gen, MapBlock **block, BlockMakeData *bmdata)
 {
-	MutexAutoLock envlock(m_server->m_env_mutex);
+	//MutexAutoLock envlock(m_server->m_env_mutex);
 
+	{
+	MAP_NOTHREAD_LOCK(m_map);
 	// 1). Attempt to fetch block from memory
-	*block = m_map->getBlockNoCreateNoEx(pos);
+	*block = m_map->getBlockNoCreateNoEx(pos, false, true);
+	}
 	if (*block && !(*block)->isDummy() && (*block)->isGenerated())
 		return EMERGE_FROM_MEMORY;
 
+	{
+	MAP_NOTHREAD_LOCK(m_map);
 	// 2). Attempt to load block from disk
 	*block = m_map->loadBlock(pos);
+	}
+
 	if (*block && (*block)->isGenerated())
+	{
+		MAP_NOTHREAD_LOCK(m_map);
+		m_map->prepareBlock(*block);
 		return EMERGE_FROM_DISK;
+	}
 
+	{
+	MAP_NOTHREAD_LOCK(m_map);
 	// 3). Attempt to start generation
 	if (allow_gen && m_map->initBlockMake(pos, bmdata))
 		return EMERGE_GENERATED;
+	}
+
+/*
+	verbosestream << "EmergeThread::getBlockOrStartGen : cancel pos=" << pos << " block="<< *block;
+	if (*block)
+		verbosestream << "dummy=" << (*block)->isDummy() << " generated="<< (*block)->isGenerated();
+	verbosestream << std::endl;
+*/
 
 	// All attempts failed; cancel this block emerge
 	return EMERGE_CANCELLED;
@@ -530,7 +565,7 @@
 MapBlock *EmergeThread::finishGen(v3s16 pos, BlockMakeData *bmdata,
 	std::map<v3s16, MapBlock *> *modified_blocks)
 {
-	MutexAutoLock envlock(m_server->m_env_mutex);
+	//MutexAutoLock envlock(m_server->m_env_mutex);
 	ScopeProfiler sp(g_profiler,
 		"EmergeThread: after Mapgen::makeChunk", SPT_AVG);
 
@@ -540,7 +575,7 @@
 	*/
 	m_map->finishBlockMake(bmdata, modified_blocks);
 
-	MapBlock *block = m_map->getBlockNoCreateNoEx(pos);
+	MapBlock *block = m_map->getBlockNoCreateNoEx(pos, false, true);
 	if (!block) {
 		errorstream << "EmergeThread::finishGen: Couldn't grab block we "
 			"just generated: " << PP(pos) << std::endl;
@@ -553,14 +588,18 @@
 
 	// Ignore map edit events, they will not need to be sent
 	// to anybody because the block hasn't been sent to anybody
+
+/* thread unsafe
 	MapEditEventAreaIgnorer ign(
 		&m_server->m_ignore_map_edit_events_area,
 		VoxelArea(minp, maxp));
+*/
 
 	/*
 		Run Lua on_generated callbacks
 	*/
 	try {
+		MAP_NOTHREAD_LOCK(m_map);
 		m_server->getScriptIface()->environment_OnGenerated(
 			minp, maxp, m_mapgen->blockseed);
 	} catch (LuaError &e) {
@@ -590,8 +629,10 @@
 	m_mapgen = m_emerge->m_mapgens[id];
 	enable_mapgen_debug_info = m_emerge->enable_mapgen_debug_info;
 
-	try {
+	reg("EmergeThread" + itos(id), 5);
+
 	while (!stopRequested()) {
+	try {
 		std::map<v3s16, MapBlock *> modified_blocks;
 		BlockEmergeData bedata;
 		BlockMakeData bmdata;
@@ -627,12 +668,19 @@
 
 		runCompletionCallbacks(pos, action, bedata.callbacks);
 
-		if (block)
-			modified_blocks[pos] = block;
+		if (block) {
+			//modified_blocks[pos] = block;
+		} else if (allow_gen) {
+			verbosestream<<"nothing generated at "<<pos<< " emerge action="<< action <<std::endl;
+		}
 
 		if (modified_blocks.size() > 0)
-			m_server->SetBlocksNotSent(modified_blocks);
-	}
+			m_server->SetBlocksNotSent(/*modified_blocks*/);
+
+		if (m_mapgen->heat_cache.size() > 1000) {
+			m_mapgen->heat_cache.clear();
+			m_mapgen->humidity_cache.clear();
+		}
 	} catch (VersionMismatchException &e) {
 		std::ostringstream err;
 		err << "World data version mismatch in MapBlock " << PP(pos) << std::endl
@@ -641,6 +689,7 @@
 			<< "See debug.txt." << std::endl
 			<< "World probably saved by a newer version of " PROJECT_NAME_C "."
 			<< std::endl;
+		debug_stacks_print();
 		m_server->setAsyncFatalError(err.str());
 	} catch (SerializationError &e) {
 		std::ostringstream err;
@@ -650,7 +699,11 @@
 			<< "See debug.txt." << std::endl
 			<< "You can ignore this using [ignore_world_load_errors = true]."
 			<< std::endl;
+		debug_stacks_print();
 		m_server->setAsyncFatalError(err.str());
+	} catch (std::exception &e) {
+		errorstream << m_name << ": exception at " << pos << " : " << e.what() << std::endl;
+	}
 	}
 
 	END_DEBUG_EXCEPTION_HANDLER
