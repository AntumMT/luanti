diff -ruN minetest-master/src/mapgen_v6.cpp minetest-freeminer/src/mapgen_v6.cpp
--- minetest-master/src/mapgen_v6.cpp	2016-09-03 16:15:52.601779000 -0700
+++ minetest-freeminer/src/mapgen_v6.cpp	2016-09-03 15:43:59.934741000 -0700
@@ -1,20 +1,22 @@
 /*
-Minetest
 Copyright (C) 2010-2015 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 
@@ -30,6 +32,7 @@
 #include "voxelalgorithms.h"
 //#include "profiler.h" // For TimeTaker
 #include "settings.h" // For g_settings
+#include "log_types.h"
 #include "emerge.h"
 #include "dungeongen.h"
 #include "cavegen.h"
@@ -37,6 +40,9 @@
 #include "mg_ore.h"
 #include "mg_decoration.h"
 #include "mapgen_v6.h"
+#include "environment.h"
+
+#include "mg_biome.h"
 
 
 FlagDesc flagdesc_mapgen_v6[] = {
@@ -98,6 +104,7 @@
 	c_snow            = ndef->getId("mapgen_snow");
 	c_snowblock       = ndef->getId("mapgen_snowblock");
 	c_ice             = ndef->getId("mapgen_ice");
+	c_clay            = ndef->getId("default:clay");
 
 	c_cobble          = ndef->getId("mapgen_cobble");
 	c_stair_cobble    = ndef->getId("mapgen_stair_cobble");
@@ -111,6 +118,11 @@
 		c_mossycobble = c_cobble;
 	if (c_stair_cobble == CONTENT_IGNORE)
 		c_stair_cobble = c_cobble;
+
+	// freeminer:
+	c_dirt_with_snow  = ndef->getId("mapgen_dirt_with_snow");
+	c_ice             = ndef->getId("mapgen_ice");
+
 	if (c_dirt_with_snow == CONTENT_IGNORE)
 		c_dirt_with_snow = c_dirt_with_grass;
 	if (c_snow == CONTENT_IGNORE)
@@ -159,7 +171,7 @@
 }
 
 
-void MapgenV6Params::readParams(const Settings *settings)
+void MapgenV6Params::readParams(Settings *settings)
 {
 	settings->getFlagStrNoEx("mgv6_spflags", spflags, flagdesc_mapgen_v6);
 	settings->getFloatNoEx("mgv6_freq_desert", freq_desert);
@@ -212,7 +224,7 @@
 
 	for (y = y_nodes_max; y >= y_nodes_min; y--) {
 		content_t c = vm->m_data[i].getContent();
-		if (c != CONTENT_IGNORE && (c == c_stone || c == c_desert_stone))
+		if (c != CONTENT_IGNORE && (c == c_stone || c == c_desert_stone || c == c_clay || c == c_sand || c == c_gravel || c == c_desert_sand || c == c_cobble || c == c_stair_cobble || c == c_mossycobble))
 			break;
 
 		vm->m_area.add_y(em, i, -1);
@@ -346,22 +358,26 @@
 }
 
 
-BiomeV6Type MapgenV6::getBiome(v2s16 p)
+BiomeV6Type MapgenV6::getBiome(v3POS p)
 {
-	int index = (p.Y - full_node_min.Z) * (ystride + 2 * MAP_BLOCKSIZE)
+	int index = (p.Z - full_node_min.Z) * (ystride + 2 * MAP_BLOCKSIZE)
 			+ (p.X - full_node_min.X);
 	return getBiome(index, p);
 }
 
 
-float MapgenV6::getHumidity(v2s16 p)
+float MapgenV6::getHumidity(v3POS p)
 {
 	/*double noise = noise2d_perlin(
 		0.5+(float)p.X/500, 0.5+(float)p.Y/500,
 		seed+72384, 4, 0.66);
 	noise = (noise + 1.0)/2.0;*/
 
-	int index = (p.Y - full_node_min.Z) * (ystride + 2 * MAP_BLOCKSIZE)
+	if (m_emerge->env->m_use_weather_biome) {
+		return (m_emerge->env->getServerMap().updateBlockHumidity(m_emerge->env, p, nullptr, &humidity_cache) - m_emerge->mgparams->bparams->np_humidity.offset) / m_emerge->mgparams->bparams->np_humidity.scale;
+	}
+
+	int index = (p.Z - full_node_min.Z) * (ystride + 2 * MAP_BLOCKSIZE)
 			+ (p.X - full_node_min.X);
 	float noise = noise_humidity->result[index];
 
@@ -425,15 +441,22 @@
 }
 
 
-BiomeV6Type MapgenV6::getBiome(int index, v2s16 p)
+BiomeV6Type MapgenV6::getBiome(int index, v3POS p)
 {
 	// Just do something very simple as for now
 	/*double d = noise2d_perlin(
 			0.6+(float)p2d.X/250, 0.2+(float)p2d.Y/250,
 			seed+9130, 3, 0.50);*/
 
-	float d = noise_biome->result[index];
-	float h = noise_humidity->result[index];
+	float d, h;
+
+	if (m_emerge->env->m_use_weather_biome) {
+		d = (m_emerge->env->getServerMap().updateBlockHeat(m_emerge->env, p, nullptr, &heat_cache) - m_emerge->mgparams->bparams->np_heat.offset) / m_emerge->mgparams->bparams->np_heat.scale;
+		h = (m_emerge->env->getServerMap().updateBlockHumidity(m_emerge->env, p, nullptr, &humidity_cache) - m_emerge->mgparams->bparams->np_humidity.offset) / m_emerge->mgparams->bparams->np_humidity.scale;
+	} else {
+		d = noise_biome->result[index];
+		h = noise_humidity->result[index];
+	}
 
 	if (spflags & MGV6_SNOWBIOMES) {
 		float blend = (spflags & MGV6_BIOMEBLEND) ? noise2d(p.X, p.Y, seed) / 40 : 0;
@@ -527,6 +550,8 @@
 	// Generate general ground level to full area
 	stone_surface_max_y = generateGround();
 
+	generateExperimental();
+
 	// Create initial heightmap to limit caves
 	updateHeightmap(node_min, node_max);
 
@@ -568,7 +593,7 @@
 		dp.np_density    = NoiseParams(0.9, 0.5, v3f(500.0, 500.0, 500.0), 0, 2, 0.8, 2.0);
 		dp.np_alt_wall   = NoiseParams(-0.4, 1.0, v3f(40.0, 40.0, 40.0), 32474, 6, 1.1, 2.0);
 
-		if (getBiome(0, v2s16(node_min.X, node_min.Z)) == BT_DESERT) {
+		if (getBiome(0, node_min) == BT_DESERT) {
 			dp.c_wall     = c_desert_stone;
 			dp.c_alt_wall = CONTENT_IGNORE;
 			dp.c_stair    = c_desert_stone;
@@ -593,7 +618,7 @@
 	}
 
 	// Add top and bottom side of water to transforming_liquid queue
-	updateLiquid(&data->transforming_liquid, full_node_min, full_node_max);
+	updateLiquid(full_node_min, full_node_max);
 
 	// Add surface nodes
 	growGrass();
@@ -661,7 +686,8 @@
 		if (surface_y > stone_surface_max_y)
 			stone_surface_max_y = surface_y;
 
-		BiomeV6Type bt = getBiome(v2s16(x, z));
+		BiomeV6Type bt = getBiome(v3POS(x, node_min.Y, z));
+		s16 heat = m_emerge->env->m_use_weather ? m_emerge->env->getServerMap().updateBlockHeat(m_emerge->env, v3POS(x,node_max.Y,z), nullptr, &heat_cache) : 0;
 
 		// Fill ground with stone
 		v3s16 em = vm->m_area.getExtent();
@@ -669,13 +695,15 @@
 		for (s16 y = node_min.Y; y <= node_max.Y; y++) {
 			if (vm->m_data[i].getContent() == CONTENT_IGNORE) {
 				if (y <= surface_y) {
-					vm->m_data[i] = (y >= MGV6_DESERT_STONE_BASE
+					vm->m_data[i] = (y >= MGV6_DESERT_STONE_BASE - surface_y
 							&& bt == BT_DESERT) ?
 						n_desert_stone : n_stone;
 				} else if (y <= water_level) {
-					vm->m_data[i] = (y >= MGV6_ICE_BASE
-							&& bt == BT_TUNDRA) ?
+					vm->m_data[i] = ((heat < 0 && y > heat/3) || (y >= MGV6_ICE_BASE
+							&& bt == BT_TUNDRA)) ?
 						n_ice : n_water_source;
+					if (liquid_pressure && y <= 0)
+						vm->m_data[i].addLevel(m_emerge->ndef, water_level - y, 1);
 				} else {
 					vm->m_data[i] = n_air;
 				}
@@ -709,7 +737,7 @@
 		if (surface_y == vm->m_area.MinEdge.Y - 1)
 			continue;
 
-		BiomeV6Type bt = getBiome(v2s16(x, z));
+		BiomeV6Type bt = getBiome(v3POS(x, surface_y, z));
 		addnode = (bt == BT_DESERT) ? n_desert_sand : n_dirt;
 
 		if (bt == BT_DESERT && surface_y + mud_add_amount <= water_level + 1) {
@@ -885,10 +913,11 @@
 void MapgenV6::placeTreesAndJungleGrass()
 {
 	//TimeTaker t("placeTrees");
-	if (node_max.Y < water_level)
-		return;
 
 	PseudoRandom grassrandom(blockseed + 53);
+
+	content_t c_sand            = ndef->getId("mapgen_sand");
+
 	content_t c_junglegrass = ndef->getId("mapgen_junglegrass");
 	// if we don't have junglegrass, don't place cignore... that's bad
 	if (c_junglegrass == CONTENT_IGNORE)
@@ -922,28 +951,34 @@
 		);
 
 		// Get biome at center position of part of division
-		BiomeV6Type bt = getBiome(p2d_center);
+		BiomeV6Type bt = getBiome(v3POS(p2d_center.X, node_min.Y, p2d_center.Y));
 
 		// Amount of trees
-		u32 tree_count;
+		float humidity = getHumidity(v3POS(p2d_center.X, node_max.Y, p2d_center.Y));
+		s32 tree_count;
 		if (bt == BT_JUNGLE || bt == BT_TAIGA || bt == BT_NORMAL) {
-			tree_count = area * getTreeAmount(p2d_center);
+			tree_count = area * getTreeAmount(p2d_center) * ((humidity + 1)/2.0);
 			if (bt == BT_JUNGLE)
 				tree_count *= 4;
 		} else {
 			tree_count = 0;
 		}
 
+		if (node_max.Y < water_level)
+			tree_count /= 2;
+
 		// Add jungle grass
 		if (bt == BT_JUNGLE) {
-			float humidity = getHumidity(p2d_center);
 			u32 grass_count = 5 * humidity * tree_count;
 			for (u32 i = 0; i < grass_count; i++) {
 				s16 x = grassrandom.range(p2d_min.X, p2d_max.X);
 				s16 z = grassrandom.range(p2d_min.Y, p2d_max.Y);
+/* wtf
 				int mapindex = central_area_size.X * (z - node_min.Z)
 								+ (x - node_min.X);
 				s16 y = heightmap[mapindex];
+*/
+				s16 y = findGroundLevelFull(v2s16(x, z));
 				if (y < water_level)
 					continue;
 
@@ -957,15 +992,19 @@
 		}
 
 		// Put trees in random places on part of division
-		for (u32 i = 0; i < tree_count; i++) {
+		for (s32 i = 0; i < tree_count; i++) {
 			s16 x = myrand_range(p2d_min.X, p2d_max.X);
 			s16 z = myrand_range(p2d_min.Y, p2d_max.Y);
+/* wtf
 			int mapindex = central_area_size.X * (z - node_min.Z)
 							+ (x - node_min.X);
 			s16 y = heightmap[mapindex];
+*/
+			s16 y = findGroundLevelFull(v2s16(x, z));
+
 			// Don't make a tree under water level
 			// Don't make a tree so high that it doesn't fit
-			if (y < water_level || y > node_max.Y - 6)
+			if (y > node_max.Y - 6)
 				continue;
 
 			v3s16 p(x, y, z);
@@ -976,13 +1015,17 @@
 				if (c != c_dirt &&
 						c != c_dirt_with_grass &&
 						c != c_dirt_with_snow &&
-						c != c_snowblock)
+						c != c_snowblock &&
+						(y >= water_level || c != c_sand))
 					continue;
 			}
 			p.Y++;
 
 			// Make a tree
-			if (bt == BT_JUNGLE) {
+			if (y < water_level) {
+				if (y < water_level - 20) // do not spawn trees in lakes
+					treegen::make_cavetree(*vm, p, bt == BT_JUNGLE, ndef, myrand());
+			} else if (bt == BT_JUNGLE) {
 				treegen::make_jungletree(*vm, p, ndef, myrand());
 			} else if (bt == BT_TAIGA) {
 				treegen::make_pine_tree(*vm, p - v3s16(0, 1, 0), ndef, myrand());
@@ -1003,6 +1046,7 @@
 	MapNode n_dirt_with_snow(c_dirt_with_snow);
 	MapNode n_snowblock(c_snowblock);
 	MapNode n_snow(c_snow);
+	MapNode n_dirt(c_dirt);
 	v3s16 em = vm->m_area.getExtent();
 
 	u32 index = 0;
@@ -1026,9 +1070,13 @@
 			surface_y = (y >= full_node_min.Y) ? y : full_node_min.Y;
 		}
 
-		BiomeV6Type bt = getBiome(index, v2s16(x, z));
+		BiomeV6Type bt = getBiome(index, v3POS(x, surface_y, z));
 		u32 i = vm->m_area.index(x, surface_y, z);
 		content_t c = vm->m_data[i].getContent();
+		if (m_emerge->env->m_use_weather && c == c_dirt) {
+			int heat = m_emerge->env->getServerMap().updateBlockHeat(m_emerge->env, v3POS(x, surface_y, z), nullptr, &heat_cache);
+			vm->m_data[i] = (heat < -10 ? n_dirt_with_snow : (heat < -5 || heat > 50) ? n_dirt : n_dirt_with_grass);
+		} else
 		if (surface_y >= water_level - 20) {
 			if (bt == BT_TAIGA && c == c_dirt) {
 				vm->m_data[i] = n_snowblock;
@@ -1063,7 +1111,7 @@
 	if (ps.range(1, 6) == 1)
 		bruises_count = ps.range(0, ps.range(0, 2));
 
-	if (getBiome(v2s16(node_min.X, node_min.Z)) == BT_DESERT) {
+	if (getBiome(node_min) == BT_DESERT) {
 		caves_count   /= 3;
 		bruises_count /= 3;
 	}
