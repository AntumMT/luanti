diff -ruN minetest-master/src/game.cpp minetest-freeminer/src/game.cpp
--- minetest-master/src/game.cpp	2016-09-03 16:15:52.673779000 -0700
+++ minetest-freeminer/src/game.cpp	2016-09-03 15:43:59.802740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+game.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "game.h"
@@ -33,7 +36,7 @@
 #include "event_manager.h"
 #include "fontengine.h"
 #include "itemdef.h"
-#include "log.h"
+#include "log_types.h"
 #include "filesys.h"
 #include "gettext.h"
 #include "guiChatConsole.h"
@@ -72,8 +75,12 @@
 	#include "touchscreengui.h"
 #endif
 
-extern Settings *g_settings;
-extern Profiler *g_profiler;
+//freeminer:
+//#include "FMStaticText.h"
+#include <future>
+
+//extern Settings *g_settings;
+//extern Profiler *g_profiler;
 
 /*
 	Text input system
@@ -574,11 +581,13 @@
 		Profiler::GraphValues values;
 	};
 	struct Meta {
+		float cur;
 		float min;
 		float max;
 		video::SColor color;
 		Meta(float initial = 0,
 			video::SColor color = video::SColor(255, 255, 255, 255)):
+			cur(initial),
 			min(initial),
 			max(initial),
 			color(color)
@@ -628,6 +637,7 @@
 
 				if (value > j->second.max)
 					j->second.max = value;
+				j->second.cur = value;
 			}
 		}
 
@@ -685,7 +695,7 @@
 					core::rect<s32>(textx, y - texth,
 						   textx2, y),
 					meta.color);
-			font->draw(utf8_to_wide(id).c_str(),
+			font->draw(utf8_to_wide(id + " " + ftos(meta.cur)).c_str(),
 					core::rect<s32>(textx, y - graphh / 2 - texth / 2,
 						   textx2, y - graphh / 2 + texth / 2),
 					meta.color);
@@ -891,6 +901,7 @@
 	bool *m_force_fog_off;
 	f32 *m_fog_range;
 	Client *m_client;
+	Inventory *m_local_inventory;
 	bool m_fogEnabled;
 
 public:
@@ -906,11 +917,12 @@
 	}
 
 	GameGlobalShaderConstantSetter(Sky *sky, bool *force_fog_off,
-			f32 *fog_range, Client *client) :
+			f32 *fog_range, Client *client, Inventory *local_inventory) :
 		m_sky(sky),
 		m_force_fog_off(force_fog_off),
 		m_fog_range(fog_range),
 		m_client(client)
+		,m_local_inventory(local_inventory)
 	{
 		g_settings->registerChangedCallback("enable_fog", SettingsCallback, this);
 		m_fogEnabled = g_settings->getBool("enable_fog");
@@ -961,6 +973,15 @@
 		services->setPixelShaderConstant("eyePosition", (irr::f32 *)&eye_position, 3);
 		services->setVertexShaderConstant("eyePosition", (irr::f32 *)&eye_position, 3);
 
+		v3f sun_moon_position;
+		if (m_sky->sun_moon_light) {
+			sun_moon_position = m_sky->sun_moon_light->getPosition();
+		} else {
+			sun_moon_position = v3f(0.0, eye_position.Y*BS+900.0, 0.0);
+		}
+		services->setPixelShaderConstant("sunPosition", (irr::f32 *)&sun_moon_position, 3);
+		services->setVertexShaderConstant("sunPosition", (irr::f32 *)&sun_moon_position, 3);
+
 		v3f minimap_yaw_vec = m_client->getMapper()->getYawVec();
 		services->setPixelShaderConstant("yawVec", (irr::f32 *)&minimap_yaw_vec, 3);
 
@@ -981,6 +1002,18 @@
 		services->setPixelShaderConstant("normalTexture" , (irr::s32 *)&layer1, 1);
 		services->setPixelShaderConstant("textureFlags" , (irr::s32 *)&layer2, 1);
 #endif
+		ItemStack playeritem;
+		{
+			InventoryList *mlist = m_local_inventory->getList("main");
+			if(mlist != NULL)
+			{
+				playeritem = mlist->getItem(m_client->getPlayerItem());
+			}
+		}
+		irr::f32 wieldLight = 0;
+		if (!g_settings->getBool("disable_wieldlight"))
+			wieldLight = (irr::f32)((ItemGroupList)m_client->idef()->get(playeritem.name).groups)["wield_light"];
+		services->setPixelShaderConstant("wieldLight", &wieldLight, 1);
 	}
 };
 
@@ -1084,15 +1117,10 @@
 
 			// Dont place node when player would be inside new node
 			// NOTE: This is to be eventually implemented by a mod as client-side Lua
-			if (!nodedef->get(n).walkable ||
-					g_settings->getBool("enable_build_where_you_stand") ||
-					(client.checkPrivilege("noclip") && g_settings->getBool("noclip")) ||
-					(nodedef->get(n).walkable &&
-					 neighbourpos != player->getStandingNodePos() + v3s16(0, 1, 0) &&
-					 neighbourpos != player->getStandingNodePos() + v3s16(0, 2, 0))) {
 
+			if(player->canPlaceNode(p, n)) {
 				// This triggers the required mesh update too
-				client.addNode(p, n);
+				client.addNode(p, n, true, nodedef->get(id).light_source ? 3 : 2); // add without liquids
 				return true;
 			}
 		} catch (InvalidPositionException &e) {
@@ -1113,6 +1141,11 @@
 		IFormSource *fs_src, TextDest *txt_dest, Client *client)
 {
 
+#ifdef HAVE_TOUCHSCREENGUI
+	if (g_touchscreengui)
+		g_touchscreengui->reset_pressed();
+#endif
+
 	if (*cur_formspec == 0) {
 		*cur_formspec = new GUIFormSpecMenu(device, joystick,
 			guiroot, -1, &g_menumgr, invmgr, gamedef, tsrc,
@@ -1148,8 +1181,8 @@
 		std::string(FORMSPEC_VERSION_STRING) +
 		SIZE_TAG
 		"bgcolor[#320000b4;true]"
-		"label[4.85,1.35;" + gettext("You died.") + "]"
-		"button_exit[4,3;3,0.5;btn_respawn;" + gettext("Respawn") + "]"
+		"label[4.85,1.35;" + _("You died.") + "]"
+		"button_exit[4,3;3,0.5;btn_respawn;" + _("Respawn") + "]"
 		;
 
 	/* Create menu */
@@ -1219,11 +1252,14 @@
 			<< strgettext("Exit to Menu") << "]";
 	os		<< "button_exit[4," << (ypos++) << ";3,0.5;btn_exit_os;"
 			<< strgettext("Exit to OS")   << "]"
+;
+/*
 			<< "textarea[7.5,0.25;3.9,6.25;;" << control_text << ";]"
 			<< "textarea[0.4,0.25;3.5,6;;" << PROJECT_NAME_C "\n"
 			<< g_build_info << "\n"
 			<< "path_user = " << wrap_rows(porting::path_user, 20)
 			<< "\n;]";
+*/
 
 	/* Create menu */
 	/* Note: FormspecFormSource and LocalFormspecHandler  *
@@ -1256,10 +1292,10 @@
 	}
 
 	// Get new messages from client
-	std::wstring message;
+	std::string message;
 
 	while (client.getChatMessage(message)) {
-		chat_backend.addUnparsedMessage(message);
+		chat_backend.addUnparsedMessage(narrow_to_wide(message));
 	}
 
 	// Remove old messages
@@ -1357,8 +1393,10 @@
 	key[KeyType::TOGGLE_CHAT]  = getKeySetting("keymap_toggle_chat");
 	key[KeyType::TOGGLE_FORCE_FOG_OFF]
 			= getKeySetting("keymap_toggle_force_fog_off");
+/*
 	key[KeyType::TOGGLE_UPDATE_CAMERA]
 			= getKeySetting("keymap_toggle_update_camera");
+*/
 	key[KeyType::TOGGLE_DEBUG]
 			= getKeySetting("keymap_toggle_debug");
 	key[KeyType::TOGGLE_PROFILER]
@@ -1380,6 +1418,10 @@
 
 	key[KeyType::DEBUG_STACKS]   = getKeySetting("keymap_print_debug_stacks");
 
+	//freeminer:
+	//key[KeyType::MSG]            = getKeySetting("keymap_msg");
+	key[KeyType::PLAYERLIST]     = getKeySetting("keymap_playerlist");
+
 	if (handler) {
 		// First clear all keys, then re-add the ones we listen for
 		handler->dontListenForKeys();
@@ -1445,6 +1487,11 @@
 	u32 profiler_current_page;
 	u32 profiler_max_page;     // Number of pages
 
+	//freeminer:
+	v3f update_draw_list_last_cam_pos;
+	unsigned int autoexit;
+	bool profiler_state;
+
 	float time_of_day;
 	float time_of_day_smooth;
 };
@@ -1474,6 +1521,15 @@
 	bool disable_camera_update;
 	bool first_loop_after_window_activation;
 	bool camera_offset_changed;
+
+	//freeminer:
+	bool headless_optimize;
+	bool no_output;
+	float dedicated_server_step;
+	int errors;
+	bool show_block_boundaries;
+	bool connected;
+	bool reconnect;
 };
 
 
@@ -1557,6 +1613,7 @@
 	void processItemSelection(u16 *new_playeritem);
 
 	void dropSelectedItem();
+	void dropSelectedStack();
 	void openInventory();
 	void openConsole(float height, const wchar_t *line=NULL);
 	void toggleFreeMove(float *statustext_time);
@@ -1564,6 +1621,8 @@
 	void toggleFast(float *statustext_time);
 	void toggleNoClip(float *statustext_time);
 	void toggleCinematic(float *statustext_time);
+	void enableCinematic();
+	void disableCinematic();
 	void toggleAutorun(float *statustext_time);
 
 	void toggleChat(float *statustext_time, bool *flag);
@@ -1574,6 +1633,7 @@
 	void toggleDebug(float *statustext_time, bool *show_debug,
 			bool *show_profiler_graph);
 	void toggleUpdateCamera(float *statustext_time, bool *flag);
+	void toggleBlockBoundaries(float *statustext_time, VolatileRunFlags *flags);
 	void toggleProfiler(float *statustext_time, u32 *profiler_current_page,
 			u32 profiler_max_page);
 
@@ -1613,9 +1673,11 @@
 	// Misc
 	void limitFps(FpsControl *fps_timings, f32 *dtime);
 
-	void showOverlayMessage(const wchar_t *msg, float dtime, int percent,
+	void showOverlayMessage(const std::wstring &msg, float dtime, int percent,
 			bool draw_clouds = true);
 
+	void showOverlayMessage(const std::string &msg, float dtime, int percent, bool draw_clouds = true);
+
 	static void settingChangedCallback(const std::string &setting_name, void *data);
 	void readSettings();
 
@@ -1725,6 +1787,18 @@
 	std::wstring infotext;
 	std::wstring statustext;
 
+	//freeminer:
+	GUITable *playerlist;
+	video::SColor console_bg;
+#if ENABLE_THREADS && HAVE_FUTURE
+	std::future<void> updateDrawList_future;
+#endif
+public:
+	VolatileRunFlags flags;
+	GameRunData runData;
+private:
+	// minetest:
+
 	KeyCache keycache;
 
 	IntervalLimiter profiler_interval;
@@ -1744,9 +1818,11 @@
 	f32  m_cache_joystick_frustum_sensitivity;
 	f32  m_repeat_right_click_time;
 
+	bool m_cinematic;
+
 #ifdef __ANDROID__
 	bool m_cache_hold_aux1;
-	bool m_android_chat_open;
+	bool m_android_chat_open = false;
 #endif
 };
 
@@ -1772,6 +1848,8 @@
 	local_inventory(NULL),
 	hud(NULL),
 	mapper(NULL)
+	,
+	playerlist(nullptr)
 {
 	g_settings->registerChangedCallback("doubletap_jump",
 		&settingChangedCallback, this);
@@ -1796,12 +1874,12 @@
 	m_cache_hold_aux1 = false;	// This is initialised properly later
 #endif
 
-}
-
+	crack_animation_length = 0;
 
+}
 
 /****************************************************************************
- MinetestApp Public
+ Game Public
  ****************************************************************************/
 
 Game::~Game()
@@ -1889,13 +1967,13 @@
 	RunStats stats              = { 0 };
 	CameraOrientation cam_view_target  = { 0 };
 	CameraOrientation cam_view  = { 0 };
-	GameRunData runData         = { 0 };
+	//runData         = { 0 };
 	FpsControl draw_times       = { 0 };
-	VolatileRunFlags flags      = { 0 };
+	flags      = { 0 };
 	f32 dtime; // in seconds
 
 	runData.time_from_last_punch  = 10.0;
-	runData.profiler_max_page = 3;
+	runData.profiler_max_page = 2;
 	runData.update_wielded_item_trigger = true;
 
 	flags.show_chat = true;
@@ -1905,6 +1983,23 @@
 	flags.invert_mouse = g_settings->getBool("invert_mouse");
 	flags.first_loop_after_window_activation = true;
 
+	mapper->setMinimapMode(MINIMAP_MODE_OFF);
+	if(flags.show_minimap) {
+		u16 minimapMode = g_settings->getU16("minimap_default_mode");
+		if( minimapMode>0 && minimapMode<MINIMAP_MODE_COUNT ) {
+			mapper->setMinimapMode(MinimapMode(minimapMode));
+		}
+	}
+
+	// freeminer:
+	runData.update_draw_list_timer = 5;
+	flags.dedicated_server_step = g_settings->getFloat("dedicated_server_step");
+	flags.headless_optimize = g_settings->getBool("headless_optimize");
+	flags.no_output = device->getVideoDriver()->getDriverType() == video::EDT_NULL;
+	flags.connected = false;
+	flags.reconnect = false;
+
+
 	/* Clear the profiler */
 	Profiler::GraphValues dummyvalues;
 	g_profiler->graphGet(dummyvalues);
@@ -1915,7 +2010,11 @@
 			sky,
 			&flags.force_fog_off,
 			&runData.fog_range,
-			client));
+			client,
+			local_inventory
+			));
+
+	double run_time = 0;
 
 	set_light_table(g_settings->getFloat("display_gamma"));
 
@@ -1928,10 +2027,15 @@
 			&& !(*kill || g_gamecallback->shutdown_requested
 			|| (server && server->getShutdownRequested()))) {
 
+		try {
+
 		/* Must be called immediately after a device->run() call because it
 		 * uses device->getTimer()->getTime()
 		 */
 		limitFps(&draw_times, &dtime);
+		run_time += dtime;
+		if (runData.autoexit && run_time > runData.autoexit)
+			g_gamecallback->shutdown_requested = 1;
 
 		updateStats(&stats, draw_times, dtime);
 		updateInteractTimers(&runData, dtime);
@@ -1951,7 +2055,7 @@
 		// Update camera before player movement to avoid camera lag of one frame
 		updateCameraDirection(&cam_view_target, &flags, dtime);
 		float cam_smoothing = 0;
-		if (g_settings->getBool("cinematic"))
+		if (m_cinematic)
 			cam_smoothing = 1 - g_settings->getFloat("cinematic_camera_smoothing");
 		else
 			cam_smoothing = 1 - g_settings->getFloat("camera_smoothing");
@@ -1973,17 +2077,36 @@
 
 		// Update if minimap has been disabled by the server
 		flags.show_minimap &= !client->isMinimapDisabledByServer();
+
+		} catch(std::exception &e) {
+			if (!flags.errors++ || !(flags.errors % (int)(60/flags.dedicated_server_step)))
+				errorstream << "Fatal client error n=" << flags.errors << " : " << e.what() << std::endl;
+		}
 	}
 }
 
 
 void Game::shutdown()
 {
+
+	if (runData.autoexit) {
+		actionstream << "Profiler:" << std::fixed << std::setprecision(9) << std::endl;
+		g_profiler->print(actionstream);
+	}
+
 	if (g_settings->get("3d_mode") == "pageflip") {
+// fmTODO: fixme:
+#if IRRLICHT_VERSION_10000 < 10900
 		driver->setRenderTarget(irr::video::ERT_STEREO_BOTH_BUFFERS);
+#endif
 	}
 
-	showOverlayMessage(wgettext("Shutting down..."), 0, 0, false);
+	showOverlayMessage(wstrgettext("Shutting down..."), 0, 0, false);
+
+#if ENABLE_THREADS && HAVE_FUTURE
+	if (updateDrawList_future.valid())
+		updateDrawList_future.wait_for(std::chrono::seconds(10));
+#endif
 
 	if (clouds)
 		clouds->drop();
@@ -2010,14 +2133,20 @@
 
 	if (client) {
 		client->Stop();
-		while (!client->isShutdown()) {
-			assert(texture_src != NULL);
-			assert(shader_src != NULL);
+		if (texture_src)
 			texture_src->processQueue();
+		if (shader_src)
 			shader_src->processQueue();
 			sleep_ms(100);
-		}
 	}
+
+	guitext->remove();
+	guitext2->remove();
+	guitext_info->remove();
+	guitext_status->remove();
+	guitext_chat->remove();
+	guitext_profiler->remove();
+
 }
 
 
@@ -2033,7 +2162,7 @@
 		u16 port,
 		const SubgameSpec &gamespec)
 {
-	showOverlayMessage(wgettext("Loading..."), 0, 0);
+	showOverlayMessage(wstrgettext("Loading..."), 0, 0);
 
 	texture_src = createTextureSource(device);
 	shader_src = createShaderSource(device);
@@ -2090,16 +2219,17 @@
 bool Game::createSingleplayerServer(const std::string map_dir,
 		const SubgameSpec &gamespec, u16 port, std::string *address)
 {
-	showOverlayMessage(wgettext("Creating server..."), 0, 5);
+	showOverlayMessage(wstrgettext("Creating server..."), 0, 5);
 
 	std::string bind_str = g_settings->get("bind_address");
 	Address bind_addr(0, 0, 0, 0, port);
 
 	if (g_settings->getBool("ipv6_server")) {
-		bind_addr.setAddress((IPv6AddressBytes *) NULL);
+		bind_addr.setAddress(in6addr_any);
 	}
 
 	try {
+		if (!bind_str.empty())
 		bind_addr.Resolve(bind_str.c_str());
 	} catch (ResolveError &e) {
 		infostream << "Resolving bind address \"" << bind_str
@@ -2115,18 +2245,32 @@
 		return false;
 	}
 
+	try {
+
 	server = new Server(map_dir, gamespec, simple_singleplayer_mode,
 			    bind_addr.isIPv6());
 
 	server->start(bind_addr);
 
+#if !EXEPTION_DEBUG
+	} catch (std::exception &e) {
+		*error_message = std::string("Unable to create server: ") + e.what();
+		errorstream << *error_message << std::endl;
+		return false;
+#else
+	} catch (int) {
+#endif
+	}
+
 	return true;
 }
 
 bool Game::createClient(const std::string &playername,
 		const std::string &password, std::string *address, u16 port)
 {
-	showOverlayMessage(wgettext("Creating client..."), 0, 10);
+	showOverlayMessage(wstrgettext("Creating client..."), 0, 10);
+
+	device->setWindowCaption(L"Freeminer [Connecting]");
 
 	draw_control = new MapDrawControl;
 	if (!draw_control)
@@ -2195,9 +2339,10 @@
 	video::ITexture *t = texture_src->getTexture("crack_anylength.png");
 	if (t) {
 		v2u32 size = t->getOriginalSize();
+		if (size.X)
 		crack_animation_length = size.Y / size.X;
 	} else {
-		crack_animation_length = 5;
+		crack_animation_length = 0;
 	}
 
 	if (!initGui())
@@ -2295,6 +2440,12 @@
 
 #endif
 
+	if(!g_settings->get("console_color").empty())
+	{
+		v3f console_color = g_settings->getV3F("console_color");
+		console_bg = video::SColor(g_settings->getU16("console_alpha"), console_color.X, console_color.Y, console_color.Z);
+	}
+
 	return true;
 }
 
@@ -2306,7 +2457,7 @@
 	*aborted = false;
 	bool local_server_mode = false;
 
-	showOverlayMessage(wgettext("Resolving address..."), 0, 15);
+	showOverlayMessage(wstrgettext("Resolving address..."), 0, 15);
 
 	Address connect_address(0, 0, 0, 0, port);
 
@@ -2315,10 +2466,8 @@
 
 		if (connect_address.isZero()) { // i.e. INADDR_ANY, IN6ADDR_ANY
 			//connect_address.Resolve("localhost");
-			if (connect_address.isIPv6()) {
-				IPv6AddressBytes addr_bytes;
-				addr_bytes.bytes[15] = 1;
-				connect_address.setAddress(&addr_bytes);
+			if (connect_address.isIPv6() || g_settings->getBool("ipv6_server")) {
+				connect_address.setAddress(in6addr_loopback);
 			} else {
 				connect_address.setAddress(127, 0, 0, 1);
 			}
@@ -2340,6 +2489,7 @@
 
 	client = new Client(device,
 			playername.c_str(), password,
+			simple_singleplayer_mode,
 			*draw_control, texture_src, shader_src,
 			itemdef_manager, nodedef_manager, sound, eventmgr,
 			connect_address.isIPv6());
@@ -2347,11 +2497,14 @@
 	if (!client)
 		return false;
 
+	client->chat_backend = chat_backend;
 	gamedef = client;	// Client acts as our GameDef
 
-	infostream << "Connecting to server at ";
-	connect_address.print(&infostream);
-	infostream << std::endl;
+	actionstream << "Connecting to server at ";
+	connect_address.print(&actionstream);
+	actionstream << std::endl;
+
+	try {
 
 	client->connect(connect_address, *address,
 		simple_singleplayer_mode || local_server_mode);
@@ -2360,7 +2513,6 @@
 		Wait for server to accept connection
 	*/
 
-	try {
 		input->clear();
 
 		FpsControl fps_control = { 0 };
@@ -2391,18 +2543,19 @@
 						+ client->accessDeniedReason();
 				*reconnect_requested = client->reconnectRequested();
 				errorstream << *error_message << std::endl;
-				break;
+				return false;
 			}
 
 			if (wasKeyDown(KeyType::ESC) || input->wasKeyDown(CancelKey)) {
 				*aborted = true;
 				infostream << "Connect aborted [Escape]" << std::endl;
-				break;
+				return false;
 			}
 
 			wait_time += dtime;
+
 			// Only time out if we aren't waiting for the server we started
-			if ((*address != "") && (wait_time > 10)) {
+			if ((*address != "") && (wait_time > 15)) {
 				bool sent_old_init = g_settings->getFlag("send_pre_v25_init");
 				// If no pre v25 init was sent, and no answer was received,
 				// but the low level connection could be established
@@ -2424,16 +2577,31 @@
 					*error_message = "Connection timed out.";
 				}
 				errorstream << *error_message << std::endl;
+				flags.reconnect = true;
 				break;
 			}
 
 			// Update status
-			showOverlayMessage(wgettext("Connecting to server..."), dtime, 20);
+			showOverlayMessage((wstrgettext("Connecting to server... ") + narrow_to_wide(itos(int(wait_time)))).c_str(), dtime, 20);
 		}
-	} catch (con::PeerNotFoundException &e) {
-		// TODO: Should something be done here? At least an info/error
-		// message?
+
+	} catch (con::ConnectionException &e) {
+		showOverlayMessage(std::string("Connection error: ") + e.what(), 0, 0, false);
+		errorstream << "Connection error: "<< e.what() << std::endl;
+		return false;
+
+#if !EXEPTION_DEBUG
+	} catch (std::exception &e) {
+		showOverlayMessage(std::string("Connection error: ") + e.what(), 0, 0, false);
+		errorstream << "Connection error: "<< e.what() << std::endl;
 		return false;
+	} catch (...) {
+		showOverlayMessage(std::string("Oops ") , 0, 0, false);
+		return false;
+#else
+	} catch (int) { //nothing
+		return false;
+#endif
 	}
 
 	return true;
@@ -2446,10 +2614,17 @@
 	FpsControl fps_control = { 0 };
 	f32 dtime; // in seconds
 
+	int progress_old = 0;
+
+	limitFps(&fps_control, &dtime);
+	float time_counter = 0;
+	auto dtime_start = dtime;
+	s16 timeout_mul = 1;
+	g_settings->getS16NoEx("timeout_mul", timeout_mul);
+
 	fps_control.last_time = device->getTimer()->getTime();
 
 	while (device->run()) {
-
 		limitFps(&fps_control, &dtime);
 
 		// Update client and server
@@ -2496,16 +2671,16 @@
 		} else {
 			std::stringstream message;
 			message.precision(3);
-			message << gettext("Media...");
+			message << _("Media...");
 
 			if ((USE_CURL == 0) ||
 					(!g_settings->getBool("enable_remote_media_server"))) {
 				float cur = client->getCurRate();
-				std::string cur_unit = gettext("KiB/s");
+				std::string cur_unit = _("KiB/s");
 
 				if (cur > 900) {
 					cur /= 1024.0;
-					cur_unit = gettext("MiB/s");
+					cur_unit = _("MiB/s");
 				}
 
 				message << " (" << cur << ' ' << cur_unit << ")";
@@ -2515,6 +2690,18 @@
 			draw_load_screen(utf8_to_wide(message.str()), device,
 					guienv, dtime, progress);
 		}
+
+		if (progress_old != progress) {
+			progress_old = progress;
+			time_counter = 0;
+		}
+		time_counter += dtime < dtime_start ? dtime : dtime - dtime_start;
+		if (time_counter > CONNECTION_TIMEOUT * 5 * timeout_mul) {
+			flags.reconnect = 1;
+			*aborted = true;
+			return false;
+		}
+
 	}
 
 	return true;
@@ -2551,6 +2738,13 @@
 		return false;
 	}
 
+	if (client->m_con.Connected()) {
+		flags.connected = 1;
+	} else if (flags.connected) {
+		flags.reconnect = 1;
+		return false;
+	}
+
 	return true;
 }
 
@@ -2593,8 +2787,10 @@
 
 void Game::processQueues()
 {
+	if (!flags.headless_optimize)
 	texture_src->processQueue();
 	itemdef_manager->processQueue(gamedef);
+	if (!flags.headless_optimize)
 	shader_src->processQueue();
 }
 
@@ -2611,6 +2807,7 @@
 		profiler_print_interval = 5;
 	}
 
+	if (!runData.autoexit)
 	if (profiler_interval.step(dtime, profiler_print_interval)) {
 		if (print_to_log) {
 			infostream << "Profiler:" << std::endl;
@@ -2690,6 +2887,7 @@
 		jp->max = 0.0;
 		jp->min = 0.0;
 	}
+
 }
 
 
@@ -2707,6 +2905,7 @@
 			|| guienv->hasFocus(gui_chat_console)) {
 		input->clear();
 #ifdef HAVE_TOUCHSCREENGUI
+		if (g_touchscreengui)
 		g_touchscreengui->hide();
 #endif
 	}
@@ -2718,6 +2917,15 @@
 	}
 #endif
 
+#ifdef __ANDROID__
+	if (gui_chat_console->isOpen()) {
+		if (gui_chat_console->getAndroidUIInput()) {
+			//gui_chat_console->closeConsoleAtOnce();
+			//gui_chat_console->closeConsole();
+		}
+	}
+#endif
+
 	if (!guienv->hasFocus(gui_chat_console) && gui_chat_console->isOpen()) {
 		gui_chat_console->closeConsoleAtOnce();
 	}
@@ -2759,7 +2967,15 @@
 	//TimeTaker tt("process kybd input", NULL, PRECISION_NANO);
 
 	if (wasKeyDown(KeyType::DROP)) {
-		dropSelectedItem();
+#ifdef __ANDROID__
+		dropSelectedStack();
+#else
+		if (input->isKeyDown(LControlKey) || input->isKeyDown(RControlKey)) {
+			dropSelectedStack();
+		} else {
+			dropSelectedItem();
+		}
+#endif
 	} else if (wasKeyDown(KeyType::AUTORUN)) {
 		toggleAutorun(statustext_time);
 	} else if (wasKeyDown(KeyType::INVENTORY)) {
@@ -2771,11 +2987,13 @@
 				simple_singleplayer_mode);
 		}
 	} else if (wasKeyDown(KeyType::CHAT)) {
-		openConsole(0.2, L"");
+		openConsole(0.1, L"");
 	} else if (wasKeyDown(KeyType::CMD)) {
-		openConsole(0.2, L"/");
+		openConsole(0.1, L"/");
+	//} else if (input->wasKeyDown(keycache.key[KeyCache::KEYMAP_ID_MSG])) {
+	//	openConsole(0.1, L"/msg ");
 	} else if (wasKeyDown(KeyType::CONSOLE)) {
-		openConsole(1);
+		openConsole(0.5);
 	} else if (wasKeyDown(KeyType::FREEMOVE)) {
 		toggleFreeMove(statustext_time);
 	} else if (wasKeyDown(KeyType::JUMP)) {
@@ -2788,7 +3006,7 @@
 	} else if (wasKeyDown(KeyType::CINEMATIC)) {
 		toggleCinematic(statustext_time);
 	} else if (wasKeyDown(KeyType::SCREENSHOT)) {
-		client->makeScreenshot(device);
+		client->makeScreenshot();
 	} else if (wasKeyDown(KeyType::TOGGLE_HUD)) {
 		toggleHud(statustext_time, &flags->show_hud);
 	} else if (wasKeyDown(KeyType::MINIMAP)) {
@@ -2798,8 +3016,10 @@
 		toggleChat(statustext_time, &flags->show_chat);
 	} else if (wasKeyDown(KeyType::TOGGLE_FORCE_FOG_OFF)) {
 		toggleFog(statustext_time, &flags->force_fog_off);
+/*
 	} else if (wasKeyDown(KeyType::TOGGLE_UPDATE_CAMERA)) {
 		toggleUpdateCamera(statustext_time, &flags->disable_camera_update);
+*/
 	} else if (wasKeyDown(KeyType::TOGGLE_DEBUG)) {
 		toggleDebug(statustext_time, &flags->show_debug, &flags->show_profiler_graph);
 	} else if (wasKeyDown(KeyType::TOGGLE_PROFILER)) {
@@ -2810,6 +3030,7 @@
 		decreaseViewRange(statustext_time);
 	} else if (wasKeyDown(KeyType::RANGESELECT)) {
 		toggleFullViewRange(statustext_time);
+		client->sendDrawControl();
 	} else if (wasKeyDown(KeyType::QUICKTUNE_NEXT)) {
 		quicktune->next();
 	} else if (wasKeyDown(KeyType::QUICKTUNE_PREV)) {
@@ -2828,6 +3049,72 @@
 		debug_stacks_print();
 	}
 
+	//freeminer
+#if !defined(NDEBUG)
+	if (input->wasKeyDown(getKeySetting("keymap_toggle_block_boundaries"))) {
+		toggleBlockBoundaries(statustext_time, flags);
+	}
+#endif
+
+		if (playerlist)
+			playerlist->setSelected(-1);
+		if(!isKeyDown(KeyType::PLAYERLIST) && playerlist != NULL)
+		{
+			playerlist->remove();
+			playerlist = NULL;
+		}
+		if(wasKeyDown(KeyType::PLAYERLIST) && playerlist == NULL)
+		{
+			v2u32 screensize = driver->getScreenSize();
+			std::list<std::string> players_list = client->getEnv().getPlayerNames();
+			std::vector<std::string> players;
+			players.reserve(players_list.size());
+			std::copy(players_list.begin(), players_list.end(), std::back_inserter(players));
+			std::sort(players.begin(), players.end(), string_icompare);
+
+			u32 max_height = screensize.Y * 0.7;
+
+			u32 row_height = g_fontengine->getTextHeight() + 4;
+			u32 rows = max_height / row_height;
+			u32 columns = players.size() / rows;
+			if (players.size() % rows > 0)
+				++columns;
+			u32 actual_height = row_height * rows;
+			if (rows > players.size())
+				actual_height = row_height * players.size();
+			u32 max_width = 0;
+			for (size_t i = 0; i < players.size(); ++i)
+				max_width = std::max(max_width, g_fontengine->getTextWidth(narrow_to_wide(players[i]).c_str()));
+			max_width += 15;
+			u32 actual_width = columns * max_width;
+
+			if (columns != 0) {
+				u32 x = (screensize.X - actual_width) / 2;
+				u32 y = (screensize.Y - actual_height) / 2;
+				playerlist = new GUITable(guienv, guienv->getRootGUIElement(), -1, core::rect<s32>(x, y, x + actual_width, y + actual_height), texture_src);
+				playerlist->drop();
+				playerlist->setScrollBarEnabled(false);
+				GUITable::TableOptions table_options;
+				GUITable::TableColumns table_columns;
+				for (size_t i = 0; i < columns; ++i) {
+					GUITable::TableColumn col;
+					col.type = "text";
+					table_columns.push_back(col);
+				}
+				std::vector<std::string> players_ordered;
+				players_ordered.reserve(columns * rows);
+				for (size_t i = 0; i < rows; ++i)
+					for (size_t j = 0; j < columns; ++j) {
+						size_t index = j * rows + i;
+						if (index >= players.size())
+							players_ordered.push_back("");
+						else
+							players_ordered.push_back(players[index]);
+					}
+				playerlist->setTable(table_options, table_columns, players_ordered);
+			}
+		}
+
 	if (!isKeyDown(KeyType::JUMP) && *reset_jump_timer) {
 		*reset_jump_timer = false;
 		*jump_timer = 0.0;
@@ -2881,7 +3168,10 @@
 
 		if (input->wasKeyDown(*item_keys[i])) {
 			if (i < PLAYER_INVENTORY_SIZE && i < player->hud_hotbar_itemcount) {
-				*new_playeritem = i;
+				if (*new_playeritem == i && g_settings->getBool("hotbar_cycling"))
+					*new_playeritem = client->getPreviousPlayerItem();
+				else
+					*new_playeritem = i;
 				infostream << "Selected item: " << new_playeritem << std::endl;
 			}
 			break;
@@ -2893,13 +3183,22 @@
 void Game::dropSelectedItem()
 {
 	IDropAction *a = new IDropAction();
-	a->count = 0;
+	a->count = 1;
 	a->from_inv.setCurrentPlayer();
 	a->from_list = "main";
 	a->from_i = client->getPlayerItem();
 	client->inventoryAction(a);
 }
 
+void Game::dropSelectedStack()
+{
+	IDropAction *a = new IDropAction();
+	a->count = 0;
+	a->from_inv.setCurrentPlayer();
+	a->from_list = "main";
+	a->from_i = client->getPlayerItem();
+	client->inventoryAction(a);
+}
 
 void Game::openInventory()
 {
@@ -2928,18 +3227,33 @@
 
 void Game::openConsole(float height, const wchar_t *line)
 {
-#ifdef __ANDROID__
-	porting::showInputDialog(gettext("ok"), "", "", 2);
-	m_android_chat_open = true;
-#else
 	if (gui_chat_console->isOpenInhibited())
 		return;
+
+#ifdef __ANDROID__
+	if (porting::canKeyboard() >= 2) {
+		// fmtodo: invisible input text before pressing enter
+		porting::displayKeyboard(true, porting::app_global, porting::jnienv);
+#endif
+
 	gui_chat_console->openConsole(height);
 	if (line) {
 		gui_chat_console->setCloseOnEnter(true);
 		gui_chat_console->replaceAndAddToHistory(line);
 	}
+
+#ifdef __ANDROID__
+	} else {
+		int type = 2;
+		porting::showInputDialog(_("ok"), "", wide_to_narrow(gui_chat_console->getText()), type);
+
+/*
+	porting::showInputDialog(_("ok"), "", "", 2);
+*/
+	m_android_chat_open = true;
+	}
 #endif
+
 }
 
 #ifdef __ANDROID__
@@ -2947,7 +3261,8 @@
 {
 	if (m_android_chat_open && porting::getInputDialogState() == 0) {
 		std::string text = porting::getInputDialogValue();
-		client->typeChatMessage(utf8_to_wide(text));
+		client->typeChatMessage(text);
+		m_android_chat_open = false;
 	}
 }
 #endif
@@ -3010,11 +3325,21 @@
 void Game::toggleCinematic(float *statustext_time)
 {
 	static const wchar_t *msg[] = { L"cinematic disabled", L"cinematic enabled" };
-	bool cinematic = !g_settings->getBool("cinematic");
-	g_settings->set("cinematic", bool_to_cstr(cinematic));
+	m_cinematic = !g_settings->getBool("cinematic");
+	g_settings->set("cinematic", bool_to_cstr(m_cinematic));
 
 	*statustext_time = 0;
-	statustext = msg[cinematic];
+	statustext = msg[m_cinematic];
+}
+
+void Game::enableCinematic()
+{
+	m_cinematic = true;
+}
+
+void Game::disableCinematic()
+{
+	m_cinematic = false;
 }
 
 // Add WoW-style autorun by toggling continuous forward.
@@ -3142,6 +3467,17 @@
 }
 
 
+void Game::toggleBlockBoundaries(float *statustext_time, VolatileRunFlags *flags) {
+	static const wchar_t *msg[] = {
+		L"Block boundaries shown",
+		L"Block boundaries hidden"
+	};
+	flags->show_block_boundaries = !flags->show_block_boundaries;
+	*statustext_time = 0;
+	statustext = msg[flags->show_block_boundaries];
+}
+
+
 void Game::toggleProfiler(float *statustext_time, u32 *profiler_current_page,
 		u32 profiler_max_page)
 {
@@ -3156,9 +3492,14 @@
 		sstr << "Profiler shown (page " << *profiler_current_page
 		     << " of " << profiler_max_page << ")";
 		statustext = sstr.str();
+		if (*profiler_current_page == 1)
+			runData.profiler_state = g_profiler_enabled;
+		g_profiler_enabled = true;
 	} else {
 		statustext = L"Profiler hidden";
+		g_profiler_enabled = runData.profiler_state;
 	}
+
 	*statustext_time = 0;
 }
 
@@ -3166,7 +3507,13 @@
 void Game::increaseViewRange(float *statustext_time)
 {
 	s16 range = g_settings->getS16("viewing_range");
-	s16 range_new = range + 10;
+	s16 range_new = range * 1.5;
+
+	// it's < 0 if it's outside the range of s16
+	// and increase it directly from 1 to 5 for less key pressing
+	if (range_new < 5)
+		range_new = 5;
+
 	g_settings->set("viewing_range", itos(range_new));
 	statustext = utf8_to_wide("Viewing range changed to "
 			+ itos(range_new));
@@ -3177,7 +3524,7 @@
 void Game::decreaseViewRange(float *statustext_time)
 {
 	s16 range = g_settings->getS16("viewing_range");
-	s16 range_new = range - 10;
+	s16 range_new = range / 1.5;
 
 	if (range_new < 20)
 		range_new = 20;
@@ -3327,6 +3674,28 @@
 	LocalPlayer *player = client->getEnv().getLocalPlayer();
 	player->keyPressed = keypress_bits;
 
+	auto & draw_control = client->getEnv().getClientMap().getControl();
+	bool zoom_changed = false;
+	if (isKeyDown(KeyType::ZOOM)) {
+		zoom_changed = player->zoom == false;
+		player->zoom = true;
+	} else {
+		zoom_changed = player->zoom == true;
+		player->zoom = false;
+	}
+
+	if (zoom_changed) {
+		if(g_settings->getBool("enable_zoom_cinematic") && !g_settings->getBool("cinematic")) {
+			if (player->zoom)
+				enableCinematic();
+			else
+				disableCinematic();
+		}
+		draw_control.fov_want = player->zoom ? g_settings->getFloat("zoom_fov") : g_settings->getFloat("fov");
+		client->sendDrawControl();
+	}
+	draw_control.fov -= (draw_control.fov - draw_control.fov_want)/7;
+
 	//tt.stop();
 }
 
@@ -3341,7 +3710,12 @@
 	} else {
 		if (server != NULL) {
 			//TimeTaker timer("server->step(dtime)");
+			try {
 			server->step(*dtime);
+			} catch(std::exception &e) {
+				if (!flags.errors++ || !(flags.errors % (int)(60/flags.dedicated_server_step)))
+					errorstream << "Fatal error n=" << flags.errors << " : " << e.what() << std::endl;
+			}
 		}
 
 		//TimeTaker timer("client.step(dtime)");
@@ -3376,10 +3750,15 @@
 			cam->camera_yaw = event.player_force_move.yaw;
 			cam->camera_pitch = event.player_force_move.pitch;
 		} else if (event.type == CE_DEATHSCREEN) {
+			player->m_sneak_node_exists = false;
+			if (g_settings->getBool("respawn_auto")) {
+				client->sendRespawn();
+			} else {
+
 			show_deathscreen(&current_formspec, client, gamedef, texture_src,
-				device, &input->joystick, client);
+					 device, &input->joystick, client);
 
-			chat_backend->addMessage(L"", L"You died.");
+			}
 
 			/* Handle visualization */
 			*damage_flash = 0;
@@ -3435,9 +3814,12 @@
 			e->world_pos = *event.hudadd.world_pos;
 			e->size = *event.hudadd.size;
 
-			u32 new_id = player->addHud(e);
+			player->addHud(e);
+/*
 			//if this isn't true our huds aren't consistent
+			assert(new_id == id);
 			sanity_check(new_id == id);
+*/
 
 			delete event.hudadd.pos;
 			delete event.hudadd.name;
@@ -3619,6 +4001,8 @@
 
 			if (clouds)
 				clouds->updateCameraOffset(camera_offset);
+			if (sky)
+				sky->camera_offset = camera_offset;
 		}
 	}
 }
@@ -3695,7 +4079,8 @@
 
 #ifdef HAVE_TOUCHSCREENGUI
 
-	if ((g_settings->getBool("touchtarget")) && (g_touchscreengui)) {
+	static const auto touchtarget = g_settings->getBool("touchtarget");
+	if (touchtarget && g_touchscreengui) {
 		shootline = g_touchscreengui->getShootline();
 		shootline.start += intToFloat(camera_offset, BS);
 		shootline.end += intToFloat(camera_offset, BS);
@@ -3715,6 +4100,15 @@
 
 	if (pointed != runData->pointed_old) {
 		infostream << "Pointing at " << pointed.dump() << std::endl;
+
+/* node debug
+			MapNode nu = client->getEnv().getClientMap().getNodeNoEx(pointed.node_undersurface);
+			MapNode na = client->getEnv().getClientMap().getNodeNoEx(pointed.node_abovesurface);
+			infostream	<< "|| nu0="<<(int)nu.param0<<" nu1"<<(int)nu.param1<<" nu2"<<(int)nu.param1<<"; nam="<<client->getNodeDefManager()->get(nu.getContent()).name
+						<< "|| na0="<<(int)na.param0<<" na1"<<(int)na.param1<<" na2"<<(int)na.param1<<"; nam="<<client->getNodeDefManager()->get(na.getContent()).name
+						<<std::endl;
+*/
+
 		hud->updateSelectionMesh(camera_offset);
 	}
 
@@ -3837,6 +4231,7 @@
 	if (runData->nodig_delay_timer <= 0.0 && isLeftPressed()
 			&& client->checkPrivilege("interact")) {
 		handleDigging(runData, pointed, nodepos, playeritem_toolcap, dtime);
+		meta = map.getNodeMetadata(nodepos); // old meta can be removed
 	}
 
 	if ((getRightClicked() ||
@@ -3845,6 +4240,28 @@
 		runData->repeat_rightclick_timer = 0;
 		infostream << "Ground right-clicked" << std::endl;
 
+/*
+				// Sign special case, at least until formspec is properly implemented.
+				// Deprecated?
+				if(meta && meta->getString("formspec") == "hack:sign_text_input"
+						&& !random_input
+						&& !input->isKeyDown(getKeySetting("keymap_sneak")))
+				{
+					infostream<<"Launching metadata text input"<<std::endl;
+
+					// Get a new text for it
+
+					TextDest *dest = new TextDestNodeMetadata(nodepos, client);
+
+					std::wstring wtext = narrow_to_wide(meta->getString("text"));
+
+					(new GUITextInputMenu(guienv, guiroot, -1,
+							&g_menumgr, dest,
+							wtext))->drop();
+				}
+				// If metadata provides an inventory view, activate it
+				else
+*/
 		if (meta && meta->getString("formspec") != "" && !random_input
 				&& !isKeyDown(KeyType::SNEAK)) {
 			infostream << "Launching custom inventory view" << std::endl;
@@ -3962,6 +4379,7 @@
 	LocalPlayer *player = client->getEnv().getLocalPlayer();
 	ClientMap &map = client->getEnv().getClientMap();
 	MapNode n = client->getEnv().getClientMap().getNodeNoEx(nodepos);
+	const ContentFeatures &features = client->getNodeDefManager()->get(n);
 
 	// NOTE: Similar piece of code exists on the server side for
 	// cheat detection.
@@ -3985,8 +4403,6 @@
 		runData->dig_time_complete = params.time;
 
 		if (m_cache_enable_particles) {
-			const ContentFeatures &features =
-					client->getNodeDefManager()->get(n);
 			client->getParticleManager()->addPunchingParticles(gamedef, smgr,
 					player, nodepos, features.tiles);
 		}
@@ -4082,10 +4498,34 @@
 		Fog range
 	*/
 
+	auto player_position = player->getPosition();
+	auto pos_i = floatToInt(player_position, BS);
+	if (!flags.headless_optimize) {
+
+	auto fog_was = runData->fog_range;
+
 	if (draw_control->range_all) {
 		runData->fog_range = 100000 * BS;
+	} else if (!flags.headless_optimize){
+		runData->fog_range = draw_control->wanted_range * BS
+				+ 0.0 * MAP_BLOCKSIZE * BS;
+
+		if (client->use_weather) {
+			auto humidity = client->getEnv().getClientMap().getHumidity(pos_i, 1);
+			runData->fog_range *= (1.55 - 1.4*(float)humidity/100);
+		}
+
+		runData->fog_range = MYMIN(
+				runData->fog_range,
+				(draw_control->farthest_drawn + 20) * BS);
+		runData->fog_range *= 0.9;
+
+		runData->fog_range = fog_was + (runData->fog_range-fog_was)/50;
+
+/*
 	} else {
 		runData->fog_range = 0.9 * draw_control->wanted_range * BS;
+*/
 	}
 
 	/*
@@ -4093,14 +4533,14 @@
 	*/
 	u32 daynight_ratio = client->getEnv().getDayNightRatio();
 	float time_brightness = decode_light_f((float)daynight_ratio / 1000.0);
-	float direct_brightness;
-	bool sunlight_seen;
+	float direct_brightness = time_brightness;
+	bool sunlight_seen = false;
 
 	if (g_settings->getBool("free_move")) {
-		direct_brightness = time_brightness;
+		//direct_brightness = time_brightness;
 		sunlight_seen = true;
-	} else {
-		ScopeProfiler sp(g_profiler, "Detecting background light", SPT_AVG);
+	} else if (!flags.headless_optimize) {
+		//ScopeProfiler sp(g_profiler, "Detecting background light", SPT_AVG);
 		float old_brightness = sky->getBrightness();
 		direct_brightness = client->getEnv().getClientMap()
 				.getBackgroundBrightness(MYMIN(runData->fog_range * 1.2, 60 * BS),
@@ -4131,6 +4571,7 @@
 	runData->time_of_day = time_of_day;
 	runData->time_of_day_smooth = time_of_day_smooth;
 
+	if (!flags.headless_optimize)
 	sky->update(time_of_day_smooth, time_brightness, direct_brightness,
 			sunlight_seen, camera->getCameraMode(), player->getYaw(),
 			player->getPitch());
@@ -4139,8 +4580,7 @@
 		Update clouds
 	*/
 	if (clouds) {
-		v3f player_position = player->getPosition();
-		if (sky->getCloudsVisible()) {
+		if (sky->getCloudsVisible() && std::abs(clouds->m_cloud_y - player_position.Y)/BS < 3000) {
 			clouds->setVisible(true);
 			clouds->step(dtime);
 			clouds->update(v2f(player_position.X, player_position.Z),
@@ -4181,6 +4621,8 @@
 		);
 	}
 
+	} // headless_optimize
+
 	/*
 		Get chat messages from client
 	*/
@@ -4222,14 +4664,37 @@
 	*/
 	runData->update_draw_list_timer += dtime;
 
-	v3f camera_direction = camera->getDirection();
-	if (runData->update_draw_list_timer >= 0.2
-			|| runData->update_draw_list_last_cam_dir.getDistanceFrom(camera_direction) > 0.2
-			|| flags.camera_offset_changed) {
-		runData->update_draw_list_timer = 0;
-		client->getEnv().getClientMap().updateDrawList(driver);
-		runData->update_draw_list_last_cam_dir = camera_direction;
-	}
+	//auto camera_direction = camera->getDirection();
+	auto camera_position = camera->getPosition();
+
+		if (!flags.headless_optimize)
+		if (client->getEnv().getClientMap().m_drawlist_last || runData->update_draw_list_timer >= 0.5 ||
+				runData->update_draw_list_last_cam_pos.getDistanceFrom(camera_position) > MAP_BLOCKSIZE*BS*2 ||
+				flags.camera_offset_changed){
+			bool allow = true;
+#if ENABLE_THREADS && HAVE_FUTURE
+			if (g_settings->getBool("more_threads")) {
+				bool allow = true;
+				if (updateDrawList_future.valid()) {
+					auto res = updateDrawList_future.wait_for(std::chrono::milliseconds(0));
+					if (res == std::future_status::timeout)
+						allow = false;
+				}
+				if (allow) {
+					updateDrawList_future = std::async(std::launch::async, [=](float dtime) {
+							client->getEnv().getClientMap().updateDrawList(driver, dtime, 1000);
+						}, runData->update_draw_list_timer);
+
+				}
+			}
+			else
+#endif
+				client->getEnv().getClientMap().updateDrawList(driver, runData->update_draw_list_timer);
+			if (allow)
+				runData->update_draw_list_last_cam_pos = camera->getPosition();
+
+			runData->update_draw_list_timer = 0;
+		}
 
 	updateGui(&runData->statustext_time, *stats, *runData, dtime, flags, cam);
 
@@ -4253,13 +4718,16 @@
 
 	video::SColor skycolor = sky->getSkyColor();
 
-	TimeTaker tt_draw("mainloop: draw");
+	//TimeTaker tt_draw("mainloop: draw");
+	auto start_ms = porting::getTimeMs();
+	if (!flags.headless_optimize)
 	{
 		TimeTaker timer("beginScene");
 		driver->beginScene(true, true, skycolor);
 		stats->beginscenetime = timer.stop(true);
 	}
 
+	if (!flags.headless_optimize)
 	draw_scene(driver, smgr, *camera, *client, player, *hud, *mapper,
 			guienv, screensize, skycolor, flags.show_hud,
 			flags.show_minimap);
@@ -4295,6 +4763,15 @@
 			player->hurt_tilt_strength = 0;
 	}
 
+		/*
+			Draw background for player list
+		*/
+		if (playerlist != NULL)
+		{
+			driver->draw2DRectangle(console_bg, playerlist->getAbsolutePosition());
+			driver->draw2DRectangleOutline(playerlist->getAbsolutePosition(), video::SColor(255,128,128,128));
+		}
+
 	/*
 		Update minimap pos and rotation
 	*/
@@ -4306,13 +4783,18 @@
 	/*
 		End scene
 	*/
+	if (!flags.headless_optimize)
 	{
 		TimeTaker timer("endScene");
 		driver->endScene();
 		stats->endscenetime = timer.stop(true);
 	}
 
+	/*
 	stats->drawtime = tt_draw.stop(true);
+	*/
+	stats->drawtime = (porting::getTimeMs() - start_ms);
+
 	g_profiler->graphAdd("mainloop_draw", stats->drawtime / 1000.0f);
 }
 
@@ -4336,27 +4818,48 @@
 	LocalPlayer *player = client->getEnv().getLocalPlayer();
 	v3f player_position = player->getPosition();
 
+	draw_control->drawtime_avg = draw_control->drawtime_avg * 0.95 + (float)stats.drawtime*0.05;
+	//draw_control->fps_avg = 1000/draw_control->drawtime_avg;
+	draw_control->fps = (1.0/stats.dtime_jitter.avg);
+	draw_control->fps_avg = draw_control->fps_avg * 0.95 + draw_control->fps*0.05;
+
 	if (flags.show_debug) {
+/*
 		static float drawtime_avg = 0;
 		drawtime_avg = drawtime_avg * 0.95 + stats.drawtime * 0.05;
 
 		u16 fps = 1.0 / stats.dtime_jitter.avg;
+*/
 		//s32 fps = driver->getFPS();
 
 		std::ostringstream os(std::ios_base::binary);
 		os << std::fixed
+#if !defined(__ANDROID__)
 		   << PROJECT_NAME_C " " << g_version_hash
-		   << " FPS = " << fps
+#endif
+		   << std::setprecision(0)
+		   << " FPS = " << draw_control->fps
+//		   << "/" << draw_control->fps_avg
+/*
 		   << " (R: range_all=" << draw_control->range_all << ")"
+*/
 		   << std::setprecision(0)
-		   << " drawtime = " << drawtime_avg
+		   << " drawtime = " << draw_control->drawtime_avg
+/*
 		   << std::setprecision(1)
 		   << ", dtime_jitter = "
 		   << (stats.dtime_jitter.max_fraction * 100.0) << " %"
+*/
 		   << std::setprecision(1)
-		   << ", v_range = " << draw_control->wanted_range
-		   << std::setprecision(3)
+		   << ", v_range = "
+		   << (draw_control->range_all ? "A " : "")
+		   << draw_control->wanted_range;
+		if (draw_control->farmesh)
+			os << ", farmesh = "<<draw_control->farmesh<<":"<<draw_control->farmesh_step;
+		os << std::setprecision(3);
+/*
 		   << ", RTT = " << client->getRTT();
+*/
 		setStaticText(guitext, utf8_to_wide(os.str()).c_str());
 		guitext->setVisible(true);
 	} else {
@@ -4372,24 +4875,38 @@
 	}
 
 	if (flags.show_debug) {
+		auto pos_i = floatToInt(player_position, BS);
+
 		std::ostringstream os(std::ios_base::binary);
 		os << std::setprecision(1) << std::fixed
 		   << "(" << (player_position.X / BS)
 		   << ", " << (player_position.Y / BS)
 		   << ", " << (player_position.Z / BS)
+		   << ") (spd=" << (int)player->getSpeed().getLength()/BS
 		   << ") (yaw=" << (wrapDegrees_0_360(cam.camera_yaw))
 		   << " " << yawToDirectionString(cam.camera_yaw)
-		   << ") (seed = " << ((u64)client->getMapSeed())
+		   << ") (t=" << client->getEnv().getClientMap().getHeat(pos_i, 1)
+		   << "C, h=" << client->getEnv().getClientMap().getHumidity(pos_i, 1)
+/*
+		   << "%) (seed = " << ((u64)client->getMapSeed())
+*/
+		   << "%"
 		   << ")";
 
 		if (runData.pointed_old.type == POINTEDTHING_NODE) {
 			ClientMap &map = client->getEnv().getClientMap();
 			const INodeDefManager *nodedef = client->getNodeDefManager();
 			MapNode n = map.getNodeNoEx(runData.pointed_old.node_undersurface);
-			if (n.getContent() != CONTENT_IGNORE && nodedef->get(n).name != "unknown") {
-				const ContentFeatures &features = nodedef->get(n);
-				os << " (pointing_at = " << nodedef->get(n).name
-				   << " - " << features.tiledef[0].name.c_str()
+			const ContentFeatures &features = nodedef->get(n);
+			if (n.getContent() != CONTENT_IGNORE && features.name != "unknown") {
+				os << " (pointing_at = " << features.name
+					<< " " << n
+#if !defined(NDEBUG)
+					<< " - " << features.tiledef[0].name.c_str()
+					<< " - " << features.drawtype
+					<< " - " << features.param_type
+					<< " - " << features.param_type_2
+#endif
 				   << ")";
 			}
 		}
@@ -4507,14 +5024,16 @@
 	fps_timings->last_time = time;
 }
 
-// Note: This will free (using delete[])! \p msg. If you want to use it later,
-// pass a copy of it to this function
-// Note: \p msg must be allocated using new (not malloc())
-void Game::showOverlayMessage(const wchar_t *msg, float dtime,
+void Game::showOverlayMessage(const std::wstring &msg, float dtime,
 		int percent, bool draw_clouds)
 {
 	draw_load_screen(msg, device, guienv, dtime, percent, draw_clouds);
-	delete[] msg;
+}
+
+void Game::showOverlayMessage(const std::string &msg, float dtime,
+		int percent, bool draw_clouds)
+{
+	draw_load_screen(narrow_to_wide(msg), device, guienv, dtime, percent, draw_clouds);
 }
 
 void Game::settingChangedCallback(const std::string &setting_name, void *data)
@@ -4533,9 +5052,13 @@
 	m_cache_joystick_frustum_sensitivity = g_settings->getFloat("joystick_frustum_sensitivity");
 	m_repeat_right_click_time            = g_settings->getFloat("repeat_rightclick_time");
 
+	m_cinematic                       = g_settings->getBool("cinematic");
+
 	m_cache_mouse_sensitivity = rangelim(m_cache_mouse_sensitivity, 0.001, 100.0);
 }
 
+
+
 /****************************************************************************/
 /****************************************************************************
  Shutdown / cleanup
@@ -4570,7 +5093,7 @@
  ****************************************************************************/
 /****************************************************************************/
 
-void the_game(bool *kill,
+bool the_game(bool *kill,
 		bool random_input,
 		InputHandler *input,
 		IrrlichtDevice *device,
@@ -4585,7 +5108,9 @@
 		ChatBackend &chat_backend,
 		bool *reconnect_requested,
 		const SubgameSpec &gamespec,        // Used for local game
-		bool simple_singleplayer_mode)
+		bool simple_singleplayer_mode,
+		unsigned int autoexit
+	)
 {
 	Game game;
 
@@ -4595,16 +5120,21 @@
 	 */
 	std::string server_address = address;
 
+	bool started = false;
 	try {
 
+		game.runData  = { 0 };
 		if (game.startup(kill, random_input, input, device, map_dir,
 				playername, password, &server_address, port, error_message,
 				reconnect_requested, &chat_backend, gamespec,
 				simple_singleplayer_mode)) {
+			started = true;
+			game.runData.autoexit = autoexit;
 			game.run();
 			game.shutdown();
 		}
 
+#ifdef NDEBUG
 	} catch (SerializationError &e) {
 		error_message = std::string("A serialization error occurred:\n")
 				+ e.what() + "\n\nThe server is probably "
@@ -4616,5 +5146,10 @@
 	} catch (ModError &e) {
 		error_message = e.what() + strgettext("\nCheck debug.txt for details.");
 		errorstream << "ModError: " << error_message << std::endl;
+#else
+	} catch (int) { //nothing
+#endif
 	}
+
+	return started && game.flags.reconnect;
 }
