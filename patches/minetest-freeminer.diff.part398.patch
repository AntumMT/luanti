diff -ruN minetest-master/src/nodedef.h minetest-freeminer/src/nodedef.h
--- minetest-master/src/nodedef.h	2016-09-03 16:15:52.613779000 -0700
+++ minetest-freeminer/src/nodedef.h	2016-09-03 15:43:59.942741000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+nodedef.h
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifndef NODEDEF_HEADER
@@ -25,15 +28,65 @@
 #include <iostream>
 #include <map>
 #include <list>
+#include <bitset>
 #include "util/numeric.h"
 #include "mapnode.h"
-#ifndef SERVER
 #include "client/tile.h"
+#ifndef SERVER
 #include "shader.h"
 #endif
 #include "itemgroup.h"
 #include "sound.h" // SimpleSoundSpec
 #include "constants.h" // BS
+#include "fm_bitset.h"
+#include <unordered_set>
+
+
+#include "msgpack_fix.h"
+
+enum {
+	CONTENTFEATURES_NAME,
+	CONTENTFEATURES_GROUPS,
+	CONTENTFEATURES_DRAWTYPE,
+	CONTENTFEATURES_VISUAL_SCALE,
+	CONTENTFEATURES_TILEDEF,
+	CONTENTFEATURES_TILEDEF_SPECIAL,
+	CONTENTFEATURES_ALPHA,
+	CONTENTFEATURES_POST_EFFECT_COLOR,
+	CONTENTFEATURES_PARAM_TYPE,
+	CONTENTFEATURES_PARAM_TYPE_2,
+	CONTENTFEATURES_IS_GROUND_CONTENT,
+	CONTENTFEATURES_LIGHT_PROPAGATES,
+	CONTENTFEATURES_SUNLIGHT_PROPAGATES,
+	CONTENTFEATURES_WALKABLE,
+	CONTENTFEATURES_POINTABLE,
+	CONTENTFEATURES_DIGGABLE,
+	CONTENTFEATURES_CLIMBABLE,
+	CONTENTFEATURES_BUILDABLE_TO,
+	CONTENTFEATURES_LIQUID_TYPE,
+	CONTENTFEATURES_LIQUID_ALTERNATIVE_FLOWING,
+	CONTENTFEATURES_LIQUID_ALTERNATIVE_SOURCE,
+	CONTENTFEATURES_LIQUID_VISCOSITY,
+	CONTENTFEATURES_LIQUID_RENEWABLE,
+	CONTENTFEATURES_LIGHT_SOURCE,
+	CONTENTFEATURES_DAMAGE_PER_SECOND,
+	CONTENTFEATURES_NODE_BOX,
+	CONTENTFEATURES_SELECTION_BOX,
+	CONTENTFEATURES_LEGACY_FACEDIR_SIMPLE,
+	CONTENTFEATURES_LEGACY_WALLMOUNTED,
+	CONTENTFEATURES_SOUND_FOOTSTEP,
+	CONTENTFEATURES_SOUND_DIG,
+	CONTENTFEATURES_SOUND_DUG,
+	CONTENTFEATURES_RIGHTCLICKABLE,
+	CONTENTFEATURES_DROWNING,
+	CONTENTFEATURES_LEVELED,
+	CONTENTFEATURES_WAVING,
+	CONTENTFEATURES_MESH,
+	CONTENTFEATURES_COLLISION_BOX,
+	CONTENTFEATURES_CONNECT_TO_IDS,
+	CONTENTFEATURES_CONNECT_SIDES,
+
+};
 
 class INodeDefManager;
 class IItemDefManager;
@@ -61,7 +114,7 @@
 	CPT2_FACEDIR,
 	// Direction for signs, torches and such
 	CPT2_WALLMOUNTED,
-	// Block level like FLOWINGLIQUID
+	// Block level like FLOWINGLIQUID (also for snow)
 	CPT2_LEVELED,
 	// 2D rotation for things like plants
 	CPT2_DEGROTATE,
@@ -85,6 +138,22 @@
 	NODEBOX_CONNECTED, // optionally draws nodeboxes if a neighbor node attaches
 };
 
+// _S_ is serialized, added to make sure collisions with NodeBoxType never happen
+enum {
+	NODEBOX_S_TYPE,
+	NODEBOX_S_FIXED,
+	NODEBOX_S_WALL_TOP,
+	NODEBOX_S_WALL_BOTTOM,
+	NODEBOX_S_WALL_SIDE,
+
+	NODEBOX_S_CONNECTED_TOP,
+	NODEBOX_S_CONNECTED_BOTTOM,
+	NODEBOX_S_CONNECTED_FRONT,
+	NODEBOX_S_CONNECTED_LEFT,
+	NODEBOX_S_CONNECTED_BACK,
+	NODEBOX_S_CONNECTED_RIGHT,
+};
+
 struct NodeBox
 {
 	enum NodeBoxType type;
@@ -109,6 +178,9 @@
 	void reset();
 	void serialize(std::ostream &os, u16 protocol_version) const;
 	void deSerialize(std::istream &is);
+
+	void msgpack_pack(msgpack::packer<msgpack::sbuffer> &pk) const;
+	void msgpack_unpack(msgpack::object o);
 };
 
 struct MapNode;
@@ -161,6 +233,16 @@
 /*
 	Stand-alone definition of a TileSpec (basically a server-side TileSpec)
 */
+enum {
+	TILEDEF_NAME,
+	TILEDEF_ANIMATION_TYPE,
+	TILEDEF_ANIMATION_ASPECT_W,
+	TILEDEF_ANIMATION_ASPECT_H,
+	TILEDEF_ANIMATION_LENGTH,
+	TILEDEF_BACKFACE_CULLING,
+	TILEDEF_TILEABLE_HORIZONTAL,
+	TILEDEF_TILEABLE_VERTICAL
+};
 enum TileAnimationType{
 	TAT_NONE=0,
 	TAT_VERTICAL_FRAMES=1,
@@ -190,10 +272,27 @@
 		animation.length = 1.0;
 	}
 
+	void msgpack_pack(msgpack::packer<msgpack::sbuffer> &pk) const;
+	void msgpack_unpack(msgpack::object o);
+
 	void serialize(std::ostream &os, u16 protocol_version) const;
 	void deSerialize(std::istream &is, const u8 contentfeatures_version, const NodeDrawType drawtype);
 };
 
+struct ContentFeatureSingleDrop
+{
+	std::string item;
+	u16 rarity;
+	u16 min_items;
+	u16 max_items;
+};
+
+struct ContentFeatureDrops
+{
+	u8 max_items;
+	std::vector<ContentFeatureSingleDrop> items;
+};
+
 #define CF_SPECIAL_COUNT 6
 
 struct ContentFeatures
@@ -208,15 +307,19 @@
 	// Special tiles
 	// - Currently used for flowing liquids
 	TileSpec special_tiles[CF_SPECIAL_COUNT];
+#endif
 	u8 solidness; // Used when choosing which face is drawn
 	u8 visual_solidness; // When solidness=0, this tells how it looks like
 	bool backface_culling;
-#endif
+
+//#endif
 
 	// Server-side cached callback existence for fast skipping
 	bool has_on_construct;
 	bool has_on_destruct;
 	bool has_after_destruct;
+	bool has_on_activate;
+	bool has_on_deactivate;
 
 	/*
 		Actual data
@@ -277,6 +380,9 @@
 	u8 liquid_viscosity;
 	// Is liquid renewable (new liquid source will be created between 2 existing)
 	bool liquid_renewable;
+	// Ice for water, water for ice
+	std::string freeze;
+	std::string melt;
 	// Number of flowing liquids surrounding source
 	u8 liquid_range;
 	u8 drowning;
@@ -293,6 +399,17 @@
 	bool legacy_facedir_simple;
 	// Set to true if wall_mounted used to be set to true
 	bool legacy_wallmounted;
+
+//freeminer:
+	u8 solidness_far = 0;
+	bool is_wire;
+	bool is_wire_connector;
+	bool is_circuit_element;
+	u8 wire_connections[6];
+	u8 circuit_element_func[64];
+	u8 circuit_element_delay;
+
+
 	// for NDT_CONNECTED pairing
 	u8 connect_sides;
 
@@ -302,7 +419,7 @@
 	SimpleSoundSpec sound_dug;
 
 	std::vector<std::string> connects_to;
-	std::set<content_t> connects_to_ids;
+	std::unordered_set<content_t> connects_to_ids;
 
 	/*
 		Methods
@@ -311,10 +428,12 @@
 	ContentFeatures();
 	~ContentFeatures();
 	void reset();
+
 	void serialize(std::ostream &os, u16 protocol_version) const;
 	void deSerialize(std::istream &is);
-	void serializeOld(std::ostream &os, u16 protocol_version) const;
-	void deSerializeOld(std::istream &is, int version);
+
+	void msgpack_pack(msgpack::packer<msgpack::sbuffer> &pk) const;
+	void msgpack_unpack(msgpack::object o);
 
 	/*
 		Some handy methods
@@ -326,15 +445,26 @@
 		if(!isLiquid() || !f.isLiquid()) return false;
 		return (liquid_alternative_flowing == f.liquid_alternative_flowing);
 	}
+	u8 getMaxLevel(bool compress = 0) const{
+		//if(param_type_2 == CPT2_LEVELED /* && liquid_type == LIQUID_FLOWING*/ && leveled)
+		//	return(compress ? LEVELED_MAX : leveled);
+		if(leveled || param_type_2 == CPT2_LEVELED)
+			return compress ? LEVELED_MAX : leveled ? leveled : LEVELED_MAX;
+		if(param_type_2 == CPT2_FLOWINGLIQUID || liquid_type == LIQUID_FLOWING) //remove liquid_type
+			return LIQUID_LEVEL_SOURCE;
+		return 0;
+	}
 
-#ifndef SERVER
+
+//#ifndef SERVER
 	void fillTileAttribs(ITextureSource *tsrc, TileSpec *tile, TileDef *tiledef,
 		u32 shader_id, bool use_normal_texture, bool backface_culling,
 		u8 alpha, u8 material_type);
 	void updateTextures(ITextureSource *tsrc, IShaderSource *shdsrc,
 		scene::ISceneManager *smgr, scene::IMeshManipulator *meshmanip,
-		IGameDef *gamedef, const TextureSettings &tsettings);
-#endif
+		IGameDef *gamedef, const TextureSettings &tsettings,
+		bool server = false);
+//#endif
 };
 
 class INodeDefManager {
@@ -347,13 +477,17 @@
 	virtual bool getId(const std::string &name, content_t &result) const=0;
 	virtual content_t getId(const std::string &name) const=0;
 	// Allows "group:name" in addition to regular node names
+	virtual bool getIds(const std::string &name, FMBitset &result) const=0;
 	// returns false if node name not found, true otherwise
-	virtual bool getIds(const std::string &name, std::set<content_t> &result)
+	virtual bool getIds(const std::string &name, std::unordered_set<content_t> &result)
 			const=0;
 	virtual const ContentFeatures &get(const std::string &name) const=0;
 
 	virtual void serialize(std::ostream &os, u16 protocol_version) const=0;
 
+	virtual void msgpack_pack(msgpack::packer<msgpack::sbuffer> &pk) const=0;
+	virtual void msgpack_unpack(msgpack::object o)=0;
+
 	virtual bool getNodeRegistrationStatus() const=0;
 
 	virtual void pendNodeResolve(NodeResolver *nr)=0;
@@ -373,7 +507,7 @@
 	// If not found, returns CONTENT_IGNORE
 	virtual content_t getId(const std::string &name) const=0;
 	// Allows "group:name" in addition to regular node names
-	virtual bool getIds(const std::string &name, std::set<content_t> &result)
+	virtual bool getIds(const std::string &name, std::unordered_set<content_t> &result)
 		const=0;
 	// If not found, returns the features of CONTENT_UNKNOWN
 	virtual const ContentFeatures &get(const std::string &name) const=0;
@@ -400,12 +534,15 @@
 		Update tile textures to latest return values of TextueSource.
 	*/
 	virtual void updateTextures(IGameDef *gamedef,
-		void (*progress_cbk)(void *progress_args, u32 progress, u32 max_progress),
-		void *progress_cbk_args)=0;
+		void (*progress_cbk)(void *progress_args, u32 progress, u32 max_progress) = nullptr,
+		void *progress_cbk_args = nullptr)=0;
 
 	virtual void serialize(std::ostream &os, u16 protocol_version) const=0;
 	virtual void deSerialize(std::istream &is)=0;
 
+	virtual void msgpack_pack(msgpack::packer<msgpack::sbuffer> &pk) const=0;
+	virtual void msgpack_unpack(msgpack::object o)=0;
+
 	virtual bool getNodeRegistrationStatus() const=0;
 	virtual void setNodeRegistrationStatus(bool completed)=0;
 
