diff -ruN minetest-master/src/content_mapblock.cpp minetest-freeminer/src/content_mapblock.cpp
--- minetest-master/src/content_mapblock.cpp	2016-09-03 16:15:52.441778000 -0700
+++ minetest-freeminer/src/content_mapblock.cpp	2016-09-03 15:43:59.842740000 -0700
@@ -1,26 +1,30 @@
 /*
-Minetest
+content_mapblock.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "content_mapblock.h"
 #include "util/numeric.h"
 #include "util/directiontables.h"
 #include "mapblock_mesh.h" // For MapBlock_LightColor() and MeshCollector
+#include "map.h"
 #include "settings.h"
 #include "nodedef.h"
 #include "client/tile.h"
@@ -164,6 +168,354 @@
 	}
 }
 
+class neighborRail {
+	public:
+		bool is_rail_x_all[2];
+		bool is_rail_z_all[2];
+		int adjacencies;
+		bool is_straight;
+		bool force_end;
+}; neighborRail recurseRail(v3s16 p, MeshMakeData *data, MeshCollector &collector, int recurse = 0)
+{
+	INodeDefManager *nodedef = data->m_gamedef->ndef();
+	v3s16 blockpos_nodes = data->m_blockpos*MAP_BLOCKSIZE;
+	s16 x = p.X, y = p.Y, z = p.Z;
+	MapNode n = data->m_vmanip.getNodeNoEx(blockpos_nodes+p);
+	const ContentFeatures &f = nodedef->get(n);
+
+	bool is_rail_x [] = { false, false };  /* x-1, x+1 */
+	bool is_rail_z [] = { false, false };  /* z-1, z+1 */
+
+	bool is_rail_z_minus_y [] = { false, false };  /* z-1, z+1; y-1 */
+	bool is_rail_x_minus_y [] = { false, false };  /* x-1, z+1; y-1 */
+	bool is_rail_z_plus_y [] = { false, false };  /* z-1, z+1; y+1 */
+	bool is_rail_x_plus_y [] = { false, false };  /* x-1, x+1; y+1 */
+
+	MapNode n_minus_x = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x-1,y,z));
+	MapNode n_plus_x = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x+1,y,z));
+	MapNode n_minus_z = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x,y,z-1));
+	MapNode n_plus_z = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x,y,z+1));
+	MapNode n_plus_x_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x+1, y+1, z));
+	MapNode n_plus_x_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x+1, y-1, z));
+	MapNode n_minus_x_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x-1, y+1, z));
+	MapNode n_minus_x_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x-1, y-1, z));
+	MapNode n_plus_z_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y+1, z+1));
+	MapNode n_minus_z_plus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y+1, z-1));
+	MapNode n_plus_z_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y-1, z+1));
+	MapNode n_minus_z_minus_y = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y-1, z-1));
+
+	content_t thiscontent = n.getContent();
+	std::string groupname = "connect_to_raillike"; // name of the group that enables connecting to raillike nodes of different kind
+	//bool self_connect_to_raillike = ((ItemGroupList) nodedef->get(n).groups)[groupname] != 0;
+	int self_group = ((ItemGroupList) nodedef->get(n).groups)[groupname];
+	
+	if ((nodedef->get(n_minus_x).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_minus_x).groups)[groupname] != self_group)
+			|| n_minus_x.getContent() == thiscontent)
+		is_rail_x[0] = true;
+
+	if ((nodedef->get(n_minus_x_minus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_minus_x_minus_y).groups)[groupname] != self_group)
+			|| n_minus_x_minus_y.getContent() == thiscontent)
+		is_rail_x_minus_y[0] = true;
+
+	if ((nodedef->get(n_minus_x_plus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_minus_x_plus_y).groups)[groupname] != self_group)
+			|| n_minus_x_plus_y.getContent() == thiscontent)
+		is_rail_x_plus_y[0] = true;
+
+	if ((nodedef->get(n_plus_x).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_plus_x).groups)[groupname] != self_group)
+			|| n_plus_x.getContent() == thiscontent)
+		is_rail_x[1] = true;
+
+	if ((nodedef->get(n_plus_x_minus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_plus_x_minus_y).groups)[groupname] != self_group)
+			|| n_plus_x_minus_y.getContent() == thiscontent)
+		is_rail_x_minus_y[1] = true;
+
+	if ((nodedef->get(n_plus_x_plus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_plus_x_plus_y).groups)[groupname] != self_group)
+			|| n_plus_x_plus_y.getContent() == thiscontent)
+		is_rail_x_plus_y[1] = true;
+
+	if ((nodedef->get(n_minus_z).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_minus_z).groups)[groupname] != self_group)
+			|| n_minus_z.getContent() == thiscontent)
+		is_rail_z[0] = true;
+
+	if ((nodedef->get(n_minus_z_minus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_minus_z_minus_y).groups)[groupname] != self_group)
+			|| n_minus_z_minus_y.getContent() == thiscontent)
+		is_rail_z_minus_y[0] = true;
+
+	if ((nodedef->get(n_minus_z_plus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_minus_z_plus_y).groups)[groupname] != self_group)
+			|| n_minus_z_plus_y.getContent() == thiscontent)
+		is_rail_z_plus_y[0] = true;
+
+	if ((nodedef->get(n_plus_z).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_plus_z).groups)[groupname] != self_group)
+			|| n_plus_z.getContent() == thiscontent)
+		is_rail_z[1] = true;
+
+	if ((nodedef->get(n_plus_z_minus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_plus_z_minus_y).groups)[groupname] != self_group)
+			|| n_plus_z_minus_y.getContent() == thiscontent)
+		is_rail_z_minus_y[1] = true;
+
+	if ((nodedef->get(n_plus_z_plus_y).drawtype == NDT_RAILLIKE
+			&& ((ItemGroupList) nodedef->get(n_plus_z_plus_y).groups)[groupname] != self_group)
+			|| n_plus_z_plus_y.getContent() == thiscontent)
+		is_rail_z_plus_y[1] = true;
+
+	bool is_rail_x_all[] = {false, false};
+	bool is_rail_z_all[] = {false, false};
+	is_rail_x_all[0]=is_rail_x[0] || is_rail_x_minus_y[0] || is_rail_x_plus_y[0];
+	is_rail_x_all[1]=is_rail_x[1] || is_rail_x_minus_y[1] || is_rail_x_plus_y[1];
+	is_rail_z_all[0]=is_rail_z[0] || is_rail_z_minus_y[0] || is_rail_z_plus_y[0];
+	is_rail_z_all[1]=is_rail_z[1] || is_rail_z_minus_y[1] || is_rail_z_plus_y[1];
+
+	// reasonable default, flat straight unrotated rail
+	bool is_straight = true;
+	int adjacencies = 0;
+	int angle = 0;
+	u8 tileindex = 0;
+
+	// check for sloped rail
+	if (is_rail_x_plus_y[0] || is_rail_x_plus_y[1] || is_rail_z_plus_y[0] || is_rail_z_plus_y[1])
+	{
+		adjacencies = 5; //5 means sloped
+		is_straight = true; // sloped is always straight
+	}
+	else
+	{
+		// is really straight, rails on both sides
+		is_straight = (is_rail_x_all[0] && is_rail_x_all[1]) || (is_rail_z_all[0] && is_rail_z_all[1]);
+		adjacencies = is_rail_x_all[0] + is_rail_x_all[1] + is_rail_z_all[0] + is_rail_z_all[1];
+	}
+
+	bool diagonalflip = false, force_end = false;
+
+	neighborRail self;
+	memcpy(self.is_rail_x_all,is_rail_x_all, sizeof(bool[2]));
+	memcpy(self.is_rail_z_all,is_rail_z_all, sizeof(bool[2]));
+	self.adjacencies = adjacencies;
+	self.is_straight = is_straight;
+	self.force_end = force_end;
+	if (recurse >= 2)
+		return self;
+
+	neighborRail neighbor_x_all[2] = {}, neighbor_z_all[2] = {};
+	if(is_rail_x_all[0]) {
+		if(is_rail_x_plus_y[0]) {
+			neighbor_x_all[0] = recurseRail(v3s16(x-1, y+1, z), data, collector, recurse+1);
+		} else if (is_rail_x[0]) {
+			neighbor_x_all[0] = recurseRail(v3s16(x-1, y  , z), data, collector, recurse+1);
+		} else { //if (is_rail_x_minus_y[0]) {
+			neighbor_x_all[0] = recurseRail(v3s16(x-1, y-1, z), data, collector, recurse+1);
+		}
+	}
+	if(is_rail_x_all[1]) {
+		if(is_rail_x_plus_y[1]) {
+			neighbor_x_all[1] = recurseRail(v3s16(x+1, y+1, z), data, collector, recurse+1);
+		} else if (is_rail_x[1]) {
+			neighbor_x_all[1] = recurseRail(v3s16(x+1, y  , z), data, collector, recurse+1);
+		} else { //if (is_rail_x_minus_y[1]) {
+			neighbor_x_all[1] = recurseRail(v3s16(x+1, y-1, z), data, collector, recurse+1);
+		}
+	}
+	if(is_rail_z_all[0]) {
+		if(is_rail_z_plus_y[0]) {
+			neighbor_z_all[0] = recurseRail(v3s16(x, y+1, z-1), data, collector, recurse+1);
+		} else if (is_rail_z[0]) {
+			neighbor_z_all[0] = recurseRail(v3s16(x, y  , z-1), data, collector, recurse+1);
+		} else { //if (is_rail_z_minus_y[0]) {
+			neighbor_z_all[0] = recurseRail(v3s16(x, y-1, z-1), data, collector, recurse+1);
+		}
+	}
+	if(is_rail_z_all[1]) {
+		if(is_rail_z_plus_y[1]) {
+			neighbor_z_all[1] = recurseRail(v3s16(x, y+1, z+1), data, collector, recurse+1);
+		} else if (is_rail_z[1]) {
+			neighbor_z_all[1] = recurseRail(v3s16(x, y  , z+1), data, collector, recurse+1);
+		} else { //if (is_rail_z_minus_y[1]) {
+			neighbor_z_all[1] = recurseRail(v3s16(x, y-1, z+1), data, collector, recurse+1);
+		}
+	}
+
+	bool is_corner_x_all[2], is_corner_z_all[2];
+	is_corner_x_all[0] = is_rail_x_all[0] && neighbor_x_all[0].adjacencies == 2 && !neighbor_x_all[0].is_straight;
+	is_corner_x_all[1] = is_rail_x_all[1] && neighbor_x_all[1].adjacencies == 2 && !neighbor_x_all[1].is_straight;
+	is_corner_z_all[0] = is_rail_z_all[0] && neighbor_z_all[0].adjacencies == 2 && !neighbor_z_all[0].is_straight;
+	is_corner_z_all[1] = is_rail_z_all[1] && neighbor_z_all[1].adjacencies == 2 && !neighbor_z_all[1].is_straight;
+
+	switch (adjacencies) {
+	case 1: //straight
+		tileindex = 5; //diagonal rail end
+		       if(is_corner_z_all[0] && neighbor_z_all[0].force_end) {
+			//angle = 0;
+		    if(neighbor_z_all[0].is_rail_x_all[1]) {
+		    	angle -= 90;
+		    	diagonalflip = true;
+		    }
+		} else if(is_corner_x_all[0] && neighbor_x_all[0].force_end) {
+			angle = -90;
+			if(neighbor_x_all[0].is_rail_z_all[0]) {
+				angle -= 90;
+				diagonalflip = true;
+			}
+		} else if(is_corner_z_all[1] && neighbor_z_all[1].force_end) {
+			angle = -180;
+			if(neighbor_z_all[1].is_rail_x_all[0]) {
+				angle -= 90;
+				diagonalflip = true;
+			}
+		} else if(is_corner_x_all[1] && neighbor_x_all[1].force_end) {
+			angle = -270;
+			if(neighbor_x_all[1].is_rail_z_all[1]) {
+				angle -= 90;
+				diagonalflip = true;
+			}
+		} else {
+			tileindex = 0; //straight
+			if(is_rail_x_all[0] || is_rail_x_all[1])
+				angle = 90;
+		}
+		break;
+	case 2:
+		if(!is_straight) {
+			tileindex = 1; //curved
+			//attempt diagonal
+			if (
+					(is_rail_x_all[0] && (
+							(is_corner_z_all[0] && neighbor_z_all[0].is_rail_x_all[1]) ||
+							(is_corner_z_all[1] && neighbor_z_all[1].is_rail_x_all[1])
+					)) ||
+					(is_rail_x_all[1] && (
+							(is_corner_z_all[0] && neighbor_z_all[0].is_rail_x_all[0]) ||
+							(is_corner_z_all[1] && neighbor_z_all[1].is_rail_x_all[0])
+					)) ||
+					(is_rail_z_all[0] && (
+							(is_corner_x_all[0] && neighbor_x_all[0].is_rail_z_all[1]) ||
+							(is_corner_x_all[1] && neighbor_x_all[1].is_rail_z_all[1])
+					)) ||
+					(is_rail_z_all[1] && (
+							(is_corner_x_all[0] && neighbor_x_all[0].is_rail_z_all[0]) ||
+							(is_corner_x_all[1] && neighbor_x_all[1].is_rail_z_all[0])
+					))
+			) { //at least one adjacent corner, not a U-turn
+				tileindex = 4; //diagonal (middle)
+				if((is_corner_x_all[0] || is_corner_x_all[1]) && (is_corner_z_all[0] || is_corner_z_all[1])) {
+					//keep middle diagonal
+				} else { //diagonal end/start/force_end
+					if(
+							(is_rail_x_all[0] && neighbor_x_all[0].adjacencies == 1) ||
+							(is_rail_x_all[1] && neighbor_x_all[1].adjacencies == 1) ||
+							(is_rail_z_all[0] && neighbor_z_all[0].adjacencies == 1) ||
+							(is_rail_z_all[1] && neighbor_z_all[1].adjacencies == 1)
+					) {
+						//Rail end is the new end, keep middle diagonal.
+						force_end = true;
+					} else {
+						tileindex = 5; //diagonal end (or start)
+						if(
+								((is_rail_z_all[0] && !is_corner_z_all[0]) && (is_rail_x_all[1] && is_corner_x_all[1])) ||
+								((is_rail_x_all[0] && !is_corner_x_all[0]) && (is_rail_z_all[0] && is_corner_z_all[0])) ||
+								((is_rail_z_all[1] && !is_corner_z_all[1]) && (is_rail_x_all[0] && is_corner_x_all[0])) ||
+								((is_rail_x_all[1] && !is_corner_x_all[1]) && (is_rail_z_all[1] && is_corner_z_all[1]))
+						) {
+							diagonalflip = true; //diagonal start
+						}
+					}
+				}
+			}
+		}
+		if(is_rail_x_all[0] && is_rail_x_all[1])
+			angle = 90;
+		if(is_rail_z_all[0] && is_rail_z_all[1]){
+			if (is_rail_z_plus_y[0])
+				angle = 180;
+		}
+		else if(is_rail_x_all[0] && is_rail_z_all[0])
+			angle = 270;
+		else if(is_rail_x_all[0] && is_rail_z_all[1])
+			angle = 180;
+		else if(is_rail_x_all[1] && is_rail_z_all[1])
+			angle = 90;
+		break;
+	case 3:
+		// here is where the potential to 'switch' a junction is, but not implemented at present
+		tileindex = 2; // t-junction
+		if(!is_rail_x_all[1])
+			angle=180;
+		if(!is_rail_z_all[0])
+			angle=90;
+		if(!is_rail_z_all[1])
+			angle=270;
+		break;
+	case 4:
+		tileindex = 3; // crossing
+		break;
+	case 5: //sloped
+		if(is_rail_z_plus_y[0])
+			angle = 180;
+		if(is_rail_x_plus_y[0])
+			angle = 90;
+		if(is_rail_x_plus_y[1])
+			angle = -90;
+		break;
+	default:
+		break;
+	}
+
+	self.force_end = force_end;
+	if (recurse >= 1)
+		return self;
+
+	TileSpec tile = getNodeTileN(n, p, tileindex, data);
+	tile.material_flags &= ~MATERIAL_FLAG_BACKFACE_CULLING;
+	tile.material_flags |= MATERIAL_FLAG_CRACK_OVERLAY;
+
+	u16 l = getInteriorLight(n, 0, nodedef);
+	video::SColor c = MapBlock_LightColor(255, l, f.light_source);
+
+	float d = (float)BS/64;
+	
+			float s = BS/2;
+
+			short g = -1;
+	if (is_rail_x_plus_y[0] || is_rail_x_plus_y[1] || is_rail_z_plus_y[0] || is_rail_z_plus_y[1])
+		g = 1; //Object is at a slope
+
+			video::S3DVertex vertices[4] =
+			{
+					video::S3DVertex(-s,  -s+d,-s,  0,0,0,  c,0,1),
+					video::S3DVertex( s,  -s+d,-s,  0,0,0,  c,1,1),
+					video::S3DVertex( s, g*s+d, s,  0,0,0,  c,1,0),
+					video::S3DVertex(-s, g*s+d, s,  0,0,0,  c,0,0),
+			};
+
+	for(s32 i=0; i<4; i++)
+	{
+		if(diagonalflip) {
+			//swap -x,-z with +x,+z
+			vertices[i].Pos.rotateXZBy(90);
+			vertices[i].Pos.Z = -vertices[i].Pos.Z;
+		}
+		if(angle != 0)
+			vertices[i].Pos.rotateXZBy(angle);
+		vertices[i].Pos += intToFloat(p, BS);
+	}
+
+	u16 indices[] = {0,1,2,2,3,0};
+
+	collector.append(tile, vertices, 4, indices, 6);
+
+	//required return, not used.
+	return self;
+}
+
 static inline void getNeighborConnectingFace(v3s16 p, INodeDefManager *nodedef,
 		MeshMakeData *data, MapNode n, int v, int *neighbors)
 {
@@ -270,7 +622,7 @@
 
 				// Don't draw any faces if neighbor same is liquid and top is
 				// same liquid
-				if(neighbor_is_same_liquid && !top_is_same_liquid)
+				if(neighbor_is_same_liquid && top_is_same_liquid)
 					continue;
 
 				// Use backface culled material if neighbor doesn't have a
@@ -373,11 +725,13 @@
 			*/
 			TileSpec tile_liquid = f.special_tiles[0];
 			TileSpec tile_liquid_bfculled = f.special_tiles[1];
+			const TileSpec *current_tile = &tile_liquid;
 
 			bool top_is_same_liquid = false;
 			MapNode ntop = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x,y+1,z));
 			content_t c_flowing = nodedef->getId(f.liquid_alternative_flowing);
 			content_t c_source = nodedef->getId(f.liquid_alternative_source);
+			TileSpec tile_liquid_source = nodedef->get(c_source).special_tiles[0];
 			if(ntop.getContent() == c_flowing || ntop.getContent() == c_source)
 				top_is_same_liquid = true;
 
@@ -397,7 +751,9 @@
 				l = getInteriorLight(n, 0, nodedef);
 			video::SColor c = MapBlock_LightColor(f.alpha, l, f.light_source);
 
+/*
 			u8 range = rangelim(nodedef->get(c_flowing).liquid_range, 1, 8);
+*/
 
 			// Neighbor liquid levels (key = relative position)
 			// Includes current node
@@ -431,12 +787,15 @@
 					if(n2.getContent() == c_source)
 						level = 0.5 * BS;
 					else if(n2.getContent() == c_flowing){
+/*
 						u8 liquid_level = (n2.param2&LIQUID_LEVEL_MASK);
 						if (liquid_level <= LIQUID_LEVEL_MAX+1-range)
 							liquid_level = 0;
 						else
 							liquid_level -= (LIQUID_LEVEL_MAX+1-range);
 						level = (-0.5 + ((float)liquid_level + 0.5) / (float)range) * BS;
+*/
+						level = (-0.5 + ((float)n2.getLevel(nodedef) + 0.5) / n2.getMaxLevel(nodedef)) * BS;
 					}
 
 					// Check node above neighbor.
@@ -500,7 +859,7 @@
 					}
 				}
 				if(air_count >= 2)
-					cornerlevel = -0.5*BS+0.2;
+					cornerlevel = -0.5*BS+(float)1/f.getMaxLevel();
 				else if(valid_count > 0)
 					cornerlevel /= valid_count;
 				corner_levels[i] = cornerlevel;
@@ -547,12 +906,12 @@
 				// Don't draw any faces if neighbor same is liquid and top is
 				// same liquid
 				if(neighbor_is_same_liquid == true
-						&& top_is_same_liquid == false)
+						&& top_is_same_liquid == true)
 					continue;
 
 				// Use backface culled material if neighbor doesn't have a
 				// solidness of 0
-				const TileSpec *current_tile = &tile_liquid;
+				current_tile = &tile_liquid;
 				if(n_feat.solidness != 0 || n_feat.visual_solidness != 0)
 					current_tile = &tile_liquid_bfculled;
 
@@ -633,6 +992,7 @@
 
 			if(top_is_same_liquid == false)
 			{
+				current_tile = &tile_liquid_source;
 				video::S3DVertex vertices[4] =
 				{
 					video::S3DVertex(-BS/2,0,BS/2, 0,0,0, c, 0,1),
@@ -652,6 +1012,9 @@
 					//vertices[i].Pos.Y += neighbor_levels[v3s16(0,0,0)];
 					s32 j = corner_resolve[i];
 					vertices[i].Pos.Y += corner_levels[j];
+					if (neighbor_levels[neighbor_dirs[0]] > corner_levels[j] + 0.25 ||
+					    neighbor_levels[neighbor_dirs[0]] < corner_levels[j] - 0.25)
+						current_tile = &tile_liquid;
 					vertices[i].Pos += intToFloat(p, BS);
 				}
 
@@ -691,8 +1054,32 @@
 
 				u16 indices[] = {0,1,2,2,3,0};
 				// Add to mesh collector
-				collector.append(tile_liquid, vertices, 4, indices, 6);
+				collector.append(*current_tile, vertices, 4, indices, 6);
 			}
+
+			/*
+				Generate bottom side, if appropriate
+			*/
+			MapNode n_bottom = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x,y-1,z));
+			const ContentFeatures &f_bottom = nodedef->get(n_bottom);
+			if (!f_bottom.walkable && n_bottom.getContent() != c_flowing &&
+				n_bottom.getContent() != c_source) {
+				video::S3DVertex vertices[4] = {
+					video::S3DVertex(-BS/2,0,BS/2, 0,0,0, c, 0,1),
+					video::S3DVertex(BS/2,0,BS/2, 0,0,0, c, 1,1),
+					video::S3DVertex(BS/2,0,-BS/2, 0,0,0, c, 1,0),
+					video::S3DVertex(-BS/2,0,-BS/2, 0,0,0, c, 0,0),
+				};
+
+				v3f offset(p.X*BS, p.Y*BS + -0.5*BS, p.Z*BS);
+				for(s32 i=0; i<4; i++) {
+					vertices[i].Pos += offset;
+				}
+
+				u16 indices[] = {0,1,2,2,3,0};
+				// Add to mesh collector
+				collector.append(tile_liquid, vertices, 4, indices, 6);
+                        }
 		break;}
 		case NDT_GLASSLIKE:
 		{
@@ -1008,57 +1395,85 @@
 		{
 			v3s16 dir = n.getWallMountedDir(nodedef);
 
-			u8 tileindex = 0;
-			if(dir == v3s16(0,-1,0)){
-				tileindex = 0; // floor
-			} else if(dir == v3s16(0,1,0)){
-				tileindex = 1; // ceiling
-			// For backwards compatibility
-			} else if(dir == v3s16(0,0,0)){
-				tileindex = 0; // floor
-			} else {
-				tileindex = 2; // side
-			}
-
-			TileSpec tile = getNodeTileN(n, p, tileindex, data);
+			// TileSpec tile = getNodeTileN(n, p, tileindex, data);
+			TileSpec tile = getNodeTileN(n, p, 0, data);
 			tile.material_flags &= ~MATERIAL_FLAG_BACKFACE_CULLING;
 			tile.material_flags |= MATERIAL_FLAG_CRACK_OVERLAY;
 
 			u16 l = getInteriorLight(n, 1, nodedef);
 			video::SColor c = MapBlock_LightColor(255, l, f.light_source);
 
-			float s = BS/2*f.visual_scale;
-			// Wall at X+ of node
-			video::S3DVertex vertices[4] =
-			{
-				video::S3DVertex(-s,-s,0, 0,0,0, c, 0,1),
-				video::S3DVertex( s,-s,0, 0,0,0, c, 1,1),
-				video::S3DVertex( s, s,0, 0,0,0, c, 1,0),
-				video::S3DVertex(-s, s,0, 0,0,0, c, 0,0),
+			float d = (float) BS/64;
+			f32 HBB = HBS/8;
+			video::S3DVertex vertices[6][4] = {
+				{	// right
+
+					video::S3DVertex(HBB,HBS-1,-HBS, 1,0,0, c, 0,0),
+					video::S3DVertex(HBB,HBS-1,HBS, 1,0,0, c, 1,0),
+					video::S3DVertex(HBB,-HBS,HBS, 1,0,0, c, 1,1),
+					video::S3DVertex(HBB,-HBS,-HBS, 1,0,0, c, 0,1)
+				},
+				{	// left
+					video::S3DVertex(-HBB,HBS,HBS, -1,0,0, c, 0,0),
+					video::S3DVertex(-HBB,HBS,-HBS, -1,0,0, c, 1,0),
+					video::S3DVertex(-HBB,-HBS,-HBS, -1,0,0, c, 1,1),
+					video::S3DVertex(-HBB,-HBS,HBS, -1,0,0, c, 0,1)
+				},
+				{	// back
+					video::S3DVertex(HBS,HBS-1,HBB, 0,0,0, c, 0,0),
+					video::S3DVertex(-HBS,HBS-1,HBB, 0,0,0, c, 1,0),
+					video::S3DVertex(-HBS,-HBS,HBB, 0,0,0, c, 1,1),
+					video::S3DVertex(HBS,-HBS,HBB, 0,0,0, c, 0,1)
+				},
+				{	// front
+					video::S3DVertex(-HBS,HBS,-HBB, 0,0,0, c, 0,0),
+					video::S3DVertex(HBS,HBS,-HBB, 0,0,0, c, 1,0),
+					video::S3DVertex(HBS,-HBS,-HBB, 0,0,0, c, 1,1),
+					video::S3DVertex(-HBS,-HBS,-HBB, 0,0,0, c, 0,1)
+				},
+				{	// up
+					video::S3DVertex(HBB,HBS-d-2.375,HBB, 0,0,0, c, HBB-0.18,0.18),
+					video::S3DVertex(-HBB,HBS-d-2.375,HBB, 0,0,0, c, HBB-0.06,0.18),
+					video::S3DVertex(-HBB,HBS-d-2.375,-HBB, 0,0,0, c, HBB-0.06,0.305),
+					video::S3DVertex(HBB,HBS-d-2.375,-HBB, 0,0,0, c, HBB-0.18,0.305)
+				},
+				{	// down
+					video::S3DVertex(-HBB,-HBS+d,-HBB, 0,0,0, c, HBB-0.18,0.875),
+					video::S3DVertex(HBB,-HBS+d,-HBB, 0,0,0, c, HBB-0.06,0.875),
+					video::S3DVertex(HBB,-HBS+d,HBB, 0,0,0, c, HBB-0.06,1),
+					video::S3DVertex(-HBB,-HBS+d,HBB, 0,0,0, c, HBB-0.18,1)
+				}
 			};
 
-			for(s32 i=0; i<4; i++)
-			{
-				if(dir == v3s16(1,0,0))
-					vertices[i].Pos.rotateXZBy(0);
-				if(dir == v3s16(-1,0,0))
-					vertices[i].Pos.rotateXZBy(180);
-				if(dir == v3s16(0,0,1))
-					vertices[i].Pos.rotateXZBy(90);
-				if(dir == v3s16(0,0,-1))
-					vertices[i].Pos.rotateXZBy(-90);
-				if(dir == v3s16(0,-1,0))
-					vertices[i].Pos.rotateXZBy(45);
-				if(dir == v3s16(0,1,0))
-					vertices[i].Pos.rotateXZBy(-45);
-
-				vertices[i].Pos += intToFloat(p, BS);
+			for(u16 j=0; j<6; j++) {
+				for(u16 i=0; i<4; i++) {
+					f32 y_offset = 0;
+					if (dir == v3s16(0,1,0)){
+						vertices[j][i].Pos.rotateXYBy(180); // ceiling
+					} else if(dir != v3s16(0,0,0) && dir != v3s16(0,-1,0)) {
+						vertices[j][i].Pos.rotateXYBy(20); // wall
+						y_offset = 1;
+					}
+					if(dir == v3s16(1,0,0))
+						vertices[j][i].Pos.rotateXZBy(0);
+					if(dir == v3s16(-1,0,0))
+						vertices[j][i].Pos.rotateXZBy(180);
+					if(dir == v3s16(0,0,1))
+						vertices[j][i].Pos.rotateXZBy(90);
+					if(dir == v3s16(0,0,-1))
+						vertices[j][i].Pos.rotateXZBy(-90);
+					if(dir == v3s16(0,-1,0))
+						vertices[j][i].Pos.rotateXZBy(0); // old 45
+					if(dir == v3s16(0,1,0))
+						vertices[j][i].Pos.rotateXZBy(0); // old -45
+					vertices[j][i].Pos += intToFloat(p, BS);
+					vertices[j][i].Pos += v3f(3.3*dir.X,y_offset,3.3*dir.Z);
+				}
+				u16 indices[] = {0,1,2,2,3,0};
+				// Add to mesh collector
+				collector.append(tile, vertices[j], 4, indices, 6);
 			}
-
-			u16 indices[] = {0,1,2,2,3,0};
-			// Add to mesh collector
-			collector.append(tile, vertices, 4, indices, 6);
-		break;}
+			break;}
 		case NDT_SIGNLIKE:
 		{
 			TileSpec tile = getNodeTileN(n, p, 0, data);
@@ -1491,6 +1906,8 @@
 		break;}
 		case NDT_RAILLIKE:
 		{
+			recurseRail(p, data, collector);
+#if TODO_MERGE
 			bool is_rail_x[6]; /* (-1,-1,0) X (1,-1,0) (-1,0,0) X (1,0,0) (-1,1,0) X (1,1,0) */
 			bool is_rail_z[6];
 
@@ -1506,8 +1923,8 @@
 						continue;
 					MapNode n_xy = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x + xz, y + y0, z));
 					MapNode n_zy = data->m_vmanip.getNodeNoEx(blockpos_nodes + v3s16(x, y + y0, z + xz));
-					ContentFeatures def_xy = nodedef->get(n_xy);
-					ContentFeatures def_zy = nodedef->get(n_zy);
+					const ContentFeatures &def_xy = nodedef->get(n_xy);
+					const ContentFeatures &def_zy = nodedef->get(n_zy);
 
 					// Check if current node would connect with the rail
 					is_rail_x[index] = ((def_xy.drawtype == NDT_RAILLIKE
@@ -1621,6 +2038,7 @@
 
 			u16 indices[] = {0,1,2,2,3,0};
 			collector.append(tile, vertices, 4, indices, 6);
+#endif
 		break;}
 		case NDT_NODEBOX:
 		{
@@ -1737,6 +2155,8 @@
 			u8 facedir = 0;
 			if (f.param_type_2 == CPT2_FACEDIR) {
 				facedir = n.getFaceDir(nodedef);
+				if (facedir >= 24)
+					facedir = 0;
 			} else if (f.param_type_2 == CPT2_WALLMOUNTED) {
 				//convert wallmounted to 6dfacedir.
 				//when cache enabled, it is already converted
