diff -ruN minetest-master/src/mapblock_mesh.cpp minetest-freeminer/src/mapblock_mesh.cpp
--- minetest-master/src/mapblock_mesh.cpp	2016-09-03 16:15:52.513778000 -0700
+++ minetest-freeminer/src/mapblock_mesh.cpp	2016-09-03 15:43:59.518738000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+mapblock_mesh.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "mapblock_mesh.h"
@@ -31,6 +34,8 @@
 #include "shader.h"
 #include "settings.h"
 #include "util/directiontables.h"
+#include "clientmap.h"
+#include "log_types.h"
 #include <IMeshManipulator.h>
 
 static void applyFacesShading(video::SColor &color, const float factor)
@@ -39,27 +44,82 @@
 	color.setGreen(core::clamp(core::round32(color.getGreen() * factor), 0, 255));
 }
 
+int getFarmeshStep(MapDrawControl& draw_control, const v3POS & playerpos, const v3POS & blockpos) {
+	int range = radius_box(playerpos, blockpos);
+	if (draw_control.farmesh) {
+		if		(range >= draw_control.farmesh+draw_control.farmesh_step*3)	return 16;
+		else if (range >= draw_control.farmesh+draw_control.farmesh_step*2)	return 8;
+		else if (range >= draw_control.farmesh+draw_control.farmesh_step)	return 4;
+		else if (range >= draw_control.farmesh)								return 2;
+	}
+	return 1;
+};
+
 /*
 	MeshMakeData
 */
 
 MeshMakeData::MeshMakeData(IGameDef *gamedef, bool use_shaders,
-		bool use_tangent_vertices):
-	m_vmanip(),
+		bool use_tangent_vertices,
+		Map & map_, MapDrawControl& draw_control_):
+#if defined(MESH_ZEROCOPY)
+	m_vmanip(map_),
+#endif
 	m_blockpos(-1337,-1337,-1337),
 	m_crack_pos_relative(-1337, -1337, -1337),
 	m_smooth_lighting(false),
 	m_show_hud(false),
 	m_gamedef(gamedef),
+
+
 	m_use_shaders(use_shaders),
 	m_use_tangent_vertices(use_tangent_vertices)
+
+	,
+	step(1),
+	range(1),
+	no_draw(false),
+	timestamp(0),
+	block(nullptr),
+	map(map_),
+	draw_control(draw_control_),
+	debug(0),
+	filled(false)
 {}
 
-void MeshMakeData::fill(MapBlock *block)
+MeshMakeData::~MeshMakeData() {
+	//infostream<<"~MeshMakeData "<<m_blockpos<<std::endl;
+}
+
+void MeshMakeData::fill(MapBlock *block_)
 {
-	m_blockpos = block->getPos();
+#if ! ENABLE_THREADS
+	block = block_;
+#endif
+	m_blockpos = block_->getPos();
+}
+
+bool MeshMakeData::fill_data()
+{
+
+	if (filled)
+		return filled;
+
+	if (!block)
+		block = map.getBlockNoCreateNoEx(m_blockpos);
+
+	if (!block)
+		return filled;
+	filled = true;
+	timestamp = block->getTimestamp();
 
-	v3s16 blockpos_nodes = m_blockpos*MAP_BLOCKSIZE;
+#if !defined(MESH_ZEROCOPY)
+	ScopeProfiler sp(g_profiler, "Client: Mesh data fill");
+
+	map.copy_27_blocks_to_vm(block, m_vmanip);
+
+#if 0
+	v3POS blockpos_nodes = m_blockpos*MAP_BLOCKSIZE;
 
 	/*
 		Copy data
@@ -99,13 +159,18 @@
 				b->copyTo(m_vmanip);
 		}
 	}
+
+#endif
+
+#endif
+	return filled;
 }
 
-void MeshMakeData::fillSingleNode(MapNode *node)
-{
-	m_blockpos = v3s16(0,0,0);
+void MeshMakeData::fillSingleNode(MapNode *node, v3POS blockpos) {
+	m_blockpos = blockpos;
 
-	v3s16 blockpos_nodes = v3s16(0,0,0);
+#if !defined(MESH_ZEROCOPY)
+	v3s16 blockpos_nodes = m_blockpos * MAP_BLOCKSIZE;
 	VoxelArea area(blockpos_nodes-v3s16(1,1,1)*MAP_BLOCKSIZE,
 			blockpos_nodes+v3s16(1,1,1)*MAP_BLOCKSIZE*2-v3s16(1,1,1));
 	s32 volume = area.getVolume();
@@ -116,7 +181,7 @@
 	m_vmanip.addArea(area);
 
 	// Fill in data
-	MapNode *data = new MapNode[volume];
+	MapNode *data = reinterpret_cast<MapNode*>( ::operator new(volume * sizeof(MapNode)));
 	for(s32 i = 0; i < volume; i++)
 	{
 		if(i == our_node_index)
@@ -129,7 +194,8 @@
 		}
 	}
 	m_vmanip.copyFrom(data, area, area.MinEdge, area.MinEdge, area.getExtent());
-	delete[] data;
+	delete data;
+#endif
 }
 
 void MeshMakeData::setCrack(int crack_level, v3s16 crack_pos)
@@ -338,9 +404,10 @@
 
 	// Emphase blue a bit in darker places
 	// Each entry of this array represents a range of 8 blue levels
-	static const u8 emphase_blue_when_dark[32] = {
+	static const u8 emphase_blue_when_dark[35] = {
 		1, 4, 6, 6, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0,
 		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0
 	};
 	b += emphase_blue_when_dark[irr::core::clamp(b, 0, 255) / 8];
 	b = irr::core::clamp(b, 0, 255);
@@ -614,11 +681,11 @@
 	TODO: Add 3: Both faces drawn with backface culling, remove equivalent
 */
 static u8 face_contents(content_t m1, content_t m2, bool *equivalent,
-		INodeDefManager *ndef)
+		INodeDefManager *ndef, int step)
 {
 	*equivalent = false;
 
-	if(m1 == CONTENT_IGNORE || m2 == CONTENT_IGNORE)
+	if(step <= 1 && (m1 == CONTENT_IGNORE || m2 == CONTENT_IGNORE))
 		return 0;
 
 	bool contents_differ = (m1 != m2);
@@ -630,8 +697,15 @@
 	if(f1.sameLiquid(f2))
 		contents_differ = false;
 
-	u8 c1 = f1.solidness;
-	u8 c2 = f2.solidness;
+	u8 c1 = (step > 1 && f1.isLiquid()) ? 1 : f1.solidness;
+	u8 c2 = (step > 1 && f2.isLiquid()) ? 1 : f2.solidness;
+
+	if (step > 1) {
+		if (!c1)
+			c1 = f1.solidness_far;
+		if (!c2)
+			c2 = f2.solidness_far;
+	}
 
 	bool solidness_differs = (c1 != c2);
 	bool makes_face = contents_differ && solidness_differs;
@@ -750,23 +824,25 @@
 		u16 *lights,
 		TileSpec &tile,
 		u8 &light_source
+		,int step
 	)
 {
-	VoxelManipulator &vmanip = data->m_vmanip;
+	auto &vmanip = data->m_vmanip;
 	INodeDefManager *ndef = data->m_gamedef->ndef();
 	v3s16 blockpos_nodes = data->m_blockpos * MAP_BLOCKSIZE;
 
-	MapNode &n0 = vmanip.getNodeRefUnsafe(blockpos_nodes + p);
+	MapNode &n0 = vmanip.getNodeRefUnsafe(blockpos_nodes + p*step);
 
 	// Don't even try to get n1 if n0 is already CONTENT_IGNORE
-	if (n0.getContent() == CONTENT_IGNORE) {
+	if (step <= 1 && n0.getContent() == CONTENT_IGNORE) {
 		makes_face = false;
 		return;
 	}
 
-	const MapNode &n1 = vmanip.getNodeRefUnsafeCheckFlags(blockpos_nodes + p + face_dir);
+	const MapNode &n1 = vmanip.getNodeRefUnsafeCheckFlags(blockpos_nodes + p*step + face_dir*step);
+	// if(data->debug) infostream<<" GN "<<n0<< n1<< blockpos_nodes<<blockpos_nodes + p*step<<blockpos_nodes + p*step + face_dir*step<<std::endl;
 
-	if (n1.getContent() == CONTENT_IGNORE) {
+	if (step <= 1 && n1.getContent() == CONTENT_IGNORE) {
 		makes_face = false;
 		return;
 	}
@@ -774,7 +850,7 @@
 	// This is hackish
 	bool equivalent = false;
 	u8 mf = face_contents(n0.getContent(), n1.getContent(),
-			&equivalent, ndef);
+			&equivalent, ndef, step);
 
 	if(mf == 0)
 	{
@@ -803,8 +879,11 @@
 	if(equivalent)
 		tile.material_flags |= MATERIAL_FLAG_BACKFACE_CULLING;
 
-	if(data->m_smooth_lighting == false)
+	if(data->m_smooth_lighting == false || step > 1)
 	{
+		if (step > 1 && (!n0.getContent() || !n1.getContent()))
+			lights[0] = lights[1] = lights[2] = lights[3] = decode_light(LIGHT_MAX-2);
+		else
 		lights[0] = lights[1] = lights[2] = lights[3] =
 				getFaceLight(n0, n1, face_dir, ndef);
 	}
@@ -835,7 +914,8 @@
 		v3f translate_dir_f,
 		v3s16 face_dir,
 		v3f face_dir_f,
-		std::vector<FastFace> &dest)
+		std::vector<FastFace> &dest,
+		int step)
 {
 	v3s16 p = startpos;
 
@@ -849,9 +929,12 @@
 	u8 light_source = 0;
 	getTileInfo(data, p, face_dir,
 			makes_face, p_corrected, face_dir_corrected,
-			lights, tile, light_source);
+			lights, tile, light_source, step);
 
-	for(u16 j=0; j<MAP_BLOCKSIZE; j++)
+	auto prev_p_corrected = p_corrected;
+
+	u16 to = MAP_BLOCKSIZE/step;
+	for(u16 j=0; j<to; j++)
 	{
 		// If tiling can be done, this is set to false in the next step
 		bool next_is_different = true;
@@ -867,17 +950,17 @@
 
 		// If at last position, there is nothing to compare to and
 		// the face must be drawn anyway
-		if(j != MAP_BLOCKSIZE - 1)
+		if(j != to - 1)
 		{
 			p_next = p + translate_dir;
 
 			getTileInfo(data, p_next, face_dir,
 					next_makes_face, next_p_corrected,
 					next_face_dir_corrected, next_lights,
-					next_tile, next_light_source);
+					next_tile, next_light_source, step);
 
 			if(next_makes_face == makes_face
-					&& next_p_corrected == p_corrected + translate_dir
+					&& next_p_corrected == prev_p_corrected + translate_dir
 					&& next_face_dir_corrected == face_dir_corrected
 					&& next_lights[0] == lights[0]
 					&& next_lights[1] == lights[1]
@@ -926,6 +1009,8 @@
 				v3f pf(p_corrected.X, p_corrected.Y, p_corrected.Z);
 				// Center point of face (kind of)
 				v3f sp = pf - ((f32)continuous_tiles_count / 2.0 - 0.5) * translate_dir_f;
+//?				if(continuous_tiles_count > 1)
+//?					sp += translate_dir_f * (continuous_tiles_count - 1);
 				v3f scale(1,1,1);
 
 				if(translate_dir.X != 0) {
@@ -942,10 +1027,9 @@
 						sp, face_dir_corrected, scale, light_source,
 						dest);
 
-				g_profiler->avg("Meshgen: faces drawn by tiling", 0);
-				for(int i = 1; i < continuous_tiles_count; i++){
-					g_profiler->avg("Meshgen: faces drawn by tiling", 1);
-				}
+#if !defined(NDEBUG)
+				g_profiler->avg("Meshgen: faces drawn by tiling", continuous_tiles_count);
+#endif
 			}
 
 			continuous_tiles_count = 1;
@@ -961,54 +1045,56 @@
 		tile = next_tile;
 		light_source = next_light_source;
 		p = p_next;
+		prev_p_corrected = next_p_corrected;
 	}
 }
 
 static void updateAllFastFaceRows(MeshMakeData *data,
-		std::vector<FastFace> &dest)
+		std::vector<FastFace> &dest, int step)
 {
+	s16 to = MAP_BLOCKSIZE/step;
 	/*
 		Go through every y,z and get top(y+) faces in rows of x+
 	*/
-	for(s16 y = 0; y < MAP_BLOCKSIZE; y++) {
-		for(s16 z = 0; z < MAP_BLOCKSIZE; z++) {
+	for(s16 y = 0; y < to; y++) {
+		for(s16 z = 0; z < to; z++) {
 			updateFastFaceRow(data,
 					v3s16(0,y,z),
 					v3s16(1,0,0), //dir
 					v3f  (1,0,0),
 					v3s16(0,1,0), //face dir
 					v3f  (0,1,0),
-					dest);
+					dest, step);
 		}
 	}
 
 	/*
 		Go through every x,y and get right(x+) faces in rows of z+
 	*/
-	for(s16 x = 0; x < MAP_BLOCKSIZE; x++) {
-		for(s16 y = 0; y < MAP_BLOCKSIZE; y++) {
+	for(s16 x = 0; x < to; x++) {
+		for(s16 y = 0; y < to; y++) {
 			updateFastFaceRow(data,
 					v3s16(x,y,0),
 					v3s16(0,0,1), //dir
 					v3f  (0,0,1),
 					v3s16(1,0,0), //face dir
 					v3f  (1,0,0),
-					dest);
+					dest, step);
 		}
 	}
 
 	/*
 		Go through every y,z and get back(z+) faces in rows of x+
 	*/
-	for(s16 z = 0; z < MAP_BLOCKSIZE; z++) {
-		for(s16 y = 0; y < MAP_BLOCKSIZE; y++) {
+	for(s16 z = 0; z < to; z++) {
+		for(s16 y = 0; y < to; y++) {
 			updateFastFaceRow(data,
 					v3s16(0,y,z),
 					v3s16(1,0,0), //dir
 					v3f  (1,0,0),
 					v3s16(0,0,1), //face dir
 					v3f  (0,0,1),
-					dest);
+					dest, step);
 		}
 	}
 }
@@ -1018,7 +1104,9 @@
 */
 
 MapBlockMesh::MapBlockMesh(MeshMakeData *data, v3s16 camera_offset):
-	m_mesh(new scene::SMesh()),
+	step(data->step),
+	no_draw(data->no_draw),
+	m_mesh(nullptr),
 	m_minimap_mapblock(NULL),
 	m_gamedef(data->m_gamedef),
 	m_driver(m_gamedef->tsrc()->getDevice()->getVideoDriver()),
@@ -1028,12 +1116,19 @@
 	m_last_crack(-1),
 	m_crack_materials(),
 	m_last_daynight_ratio((u32) -1),
-	m_daynight_diffs()
+	m_daynight_diffs(),
+	m_usage_timer(0)
 {
+	m_mesh = new scene::SMesh();
+
 	m_enable_shaders = data->m_use_shaders;
 	m_use_tangent_vertices = data->m_use_tangent_vertices;
 	m_enable_vbo = g_settings->getBool("enable_vbo");
 	
+
+	if (!data->fill_data())
+		return;
+	if (step == 1 || !data->block->getMesh())
 	if (g_settings->getBool("enable_minimap")) {
 		m_minimap_mapblock = new MinimapMapblock;
 		m_minimap_mapblock->getMinimapNodes(
@@ -1044,8 +1139,11 @@
 	// 24-155ms for MAP_BLOCKSIZE=32  (NOTE: probably outdated)
 	//TimeTaker timer1("MapBlockMesh()");
 
+
+	timestamp = data->timestamp;
+
 	std::vector<FastFace> fastfaces_new;
-	fastfaces_new.reserve(512);
+	fastfaces_new.reserve(512/step);
 
 	/*
 		We are including the faces of the trailing edges of the block.
@@ -1057,10 +1155,12 @@
 	{
 		// 4-23ms for MAP_BLOCKSIZE=16  (NOTE: probably outdated)
 		//TimeTaker timer2("updateAllFastFaceRows()");
-		updateAllFastFaceRows(data, fastfaces_new);
+		updateAllFastFaceRows(data, fastfaces_new, step);
 	}
 	// End of slow part
 
+	//if (data->debug) infostream<<" step="<<step<<" fastfaces_new.size="<<fastfaces_new.size()<<std::endl;
+
 	/*
 		Convert FastFaces to MeshCollector
 	*/
@@ -1104,6 +1204,7 @@
 		- whatever
 	*/
 
+	if(step <= 1)
 	mapblock_mesh_generate_special(data, collector);
 
 	/*
@@ -1114,6 +1215,7 @@
 	{
 		PreMeshBuffer &p = collector.prebuffers[i];
 
+		if (step <= data->draw_control.farmesh || !data->draw_control.farmesh) {
 		// Generate animation data
 		// - Cracks
 		if(p.tile.material_flags & MATERIAL_FLAG_CRACK)
@@ -1130,8 +1232,9 @@
 					os.str()+"0",
 					&p.tile.texture_id);
 		}
+		}
 		// - Texture animation
-		if(p.tile.material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES)
+		if(p.tile.material_flags & MATERIAL_FLAG_ANIMATION_VERTICAL_FRAMES && !p.tile.frames.empty())
 		{
 			// Add to MapBlockMesh in order to animate these tiles
 			m_animation_tiles[i] = p.tile;
@@ -1196,6 +1299,8 @@
 		material.setFlag(video::EMF_BACK_FACE_CULLING, true);
 		material.setFlag(video::EMF_BILINEAR_FILTER, false);
 		material.setFlag(video::EMF_FOG_ENABLE, true);
+		//material.setFlag(video::EMF_WIREFRAME, true);
+
 		material.setTexture(0, p.tile.texture);
 
 		if (m_enable_shaders) {
@@ -1239,8 +1344,15 @@
 		Do some stuff to the mesh
 	*/
 	m_camera_offset = camera_offset;
+
+	v3f t = v3f(0,0,0);
+	if (step>1) {
+		translateMesh(m_mesh, v3f(HBS, 0, HBS));
+		scaleMesh(m_mesh, v3f(step,step,step));
+		t = v3f( -HBS, -BS*step/2+1.4142135623731*BS, -HBS); //magic number is sqrt(2)
+	}
 	translateMesh(m_mesh,
-		intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset, BS));
+		intToFloat(data->m_blockpos * MAP_BLOCKSIZE - camera_offset, BS) + t);
 
 	if (m_use_tangent_vertices) {
 		scene::IMeshManipulator* meshmanip =
@@ -1252,9 +1364,9 @@
 	{
 #if 0
 		// Usually 1-700 faces and 1-7 materials
-		std::cout<<"Updated MapBlock has "<<fastfaces_new.size()<<" faces "
+		infostream<<"Updated MapBlock mesh p="<<data->m_blockpos<<" has "<<fastfaces_new.size()<<" faces "
 				<<"and uses "<<m_mesh->getMeshBufferCount()
-				<<" materials (meshbuffers)"<<std::endl;
+				<<" materials "<<" step="<<step<<" range="<<data->range<< " mesh="<<m_mesh<<std::endl;
 #endif
 
 		// Use VBO for mesh (this just would set this for ever buffer)
@@ -1274,15 +1386,19 @@
 
 MapBlockMesh::~MapBlockMesh()
 {
-	if (m_enable_vbo && m_mesh) {
+	if (!m_mesh)
+		return;
+
+	//if (m_enable_vbo && m_mesh) {
 		for (u32 i = 0; i < m_mesh->getMeshBufferCount(); i++) {
 			scene::IMeshBuffer *buf = m_mesh->getMeshBuffer(i);
 			m_driver->removeHardwareBuffer(buf);
 		}
-	}
+	//}
 	m_mesh->drop();
 	m_mesh = NULL;
 	delete m_minimap_mapblock;
+	m_minimap_mapblock = nullptr;
 }
 
 bool MapBlockMesh::animate(bool faraway, float time, int crack, u32 daynight_ratio)
@@ -1293,9 +1409,16 @@
 		return false;
 	}
 
+#if __ANDROID__
+	m_animation_force_timer = myrand_range(500, 1000);
+#else
 	m_animation_force_timer = myrand_range(5, 100);
+#endif
+
+	m_animation_force_timer *= step;
 
 	// Cracks
+	if (step <= 1)
 	if(crack != m_last_crack)
 	{
 		for(std::map<u32, std::string>::iterator
@@ -1330,6 +1453,7 @@
 	}
 
 	// Texture animation
+	if (step <= 1)
 	for(std::map<u32, TileSpec>::iterator
 			i = m_animation_tiles.begin();
 			i != m_animation_tiles.end(); ++i)
@@ -1338,7 +1462,7 @@
 		// Figure out current frame
 		int frameoffset = m_animation_frame_offsets[i->first];
 		int frame = (int)(time * 1000 / tile.animation_frame_length_ms
-				+ frameoffset) % tile.animation_frame_count;
+				+ frameoffset) % (tile.animation_frame_count ? tile.animation_frame_count : 1);
 		// If frame doesn't change, skip
 		if(frame == m_animation_frames[i->first])
 			continue;
@@ -1369,6 +1493,7 @@
 				i != m_daynight_diffs.end(); ++i)
 		{
 			scene::IMeshBuffer *buf = m_mesh->getMeshBuffer(i->first);
+			buf->setDirty(irr::scene::EBT_VERTEX);
 			video::S3DVertex *vertices = (video::S3DVertex *)buf->getVertices();
 			for(std::map<u32, std::pair<u8, u8 > >::iterator
 					j = i->second.begin();
@@ -1385,7 +1510,7 @@
 	return true;
 }
 
-void MapBlockMesh::updateCameraOffset(v3s16 camera_offset)
+bool MapBlockMesh::updateCameraOffset(v3s16 camera_offset)
 {
 	if (camera_offset != m_camera_offset) {
 		translateMesh(m_mesh, intToFloat(m_camera_offset-camera_offset, BS));
@@ -1393,7 +1518,9 @@
 			m_mesh->setDirty();
 		}
 		m_camera_offset = camera_offset;
+		return true;
 	}
+	return false;
 }
 
 /*
