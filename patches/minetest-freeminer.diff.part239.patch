diff -ruN minetest-master/src/environment.h minetest-freeminer/src/environment.h
--- minetest-master/src/environment.h	2016-09-03 16:15:52.449778000 -0700
+++ minetest-freeminer/src/environment.h	2016-09-03 15:43:59.846740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+environment.h
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifndef ENVIRONMENT_HEADER
@@ -39,6 +42,20 @@
 #include "util/numeric.h"
 #include "mapnode.h"
 #include "mapblock.h"
+
+//fm:
+#include "network/connection.h"
+#include "fm_bitset.h"
+#include "threading/concurrent_unordered_map.h"
+#include "threading/concurrent_vector.h"
+#include <unordered_set>
+#include "util/container.h" // Queue
+#include <array>
+#include "circuit.h"
+#include "key_value_storage.h"
+#include <unordered_set>
+//--
+
 #include "threading/mutex.h"
 #include "threading/atomic.h"
 #include "network/networkprotocol.h" // for AccessDeniedCode
@@ -55,6 +72,15 @@
 class Player;
 class RemotePlayer;
 
+struct ItemStack;
+class PlayerSAO;
+
+namespace epixel
+{
+class ItemSAO;
+class FallingSAO;
+}
+
 class Environment
 {
 public:
@@ -68,16 +94,14 @@
 		- Step mobs
 		- Run timers of map
 	*/
-	virtual void step(f32 dtime) = 0;
+	virtual void step(f32 dtime, float uptime, unsigned int max_cycle_ms) = 0;
 
 	virtual Map & getMap() = 0;
 
 	virtual void addPlayer(Player *player);
 	void removePlayer(Player *player);
 	Player * getPlayer(u16 peer_id);
-	Player * getPlayer(const char *name);
-	Player * getRandomConnectedPlayer();
-	Player * getNearestConnectedPlayer(v3f pos);
+	Player * getPlayer(const std::string &name);
 	std::vector<Player*> getPlayers();
 	std::vector<Player*> getPlayers(bool ignore_disconnected);
 
@@ -98,11 +122,11 @@
 	u32 getDayCount();
 
 	// counter used internally when triggering ABMs
-	u32 m_added_objects;
+	std::atomic_uint m_added_objects;
 
 protected:
 	// peer_ids in here should be unique, except that there may be many 0s
-	std::vector<Player*> m_players;
+	concurrent_vector<Player*> m_players;
 
 	GenericAtomic<float> m_time_of_day_speed;
 
@@ -163,8 +187,11 @@
 	virtual std::set<std::string> getTriggerContents()=0;
 	// Set of required neighbors (trigger doesn't happen if none are found)
 	// Empty = do not check neighbors
-	virtual std::set<std::string> getRequiredNeighbors()
+	virtual std::set<std::string> getRequiredNeighbors(bool activate)
 	{ return std::set<std::string>(); }
+	// Maximum range to neighbors
+	virtual u32 getNeighborsRange()
+	{ return 1; };
 	// Trigger interval in seconds
 	virtual float getTriggerInterval() = 0;
 	// Random chance of (1 / return value), 0 is disallowed
@@ -172,17 +199,24 @@
 	// Whether to modify chance to simulate time lost by an unnattended block
 	virtual bool getSimpleCatchUp() = 0;
 	// This is called usually at interval for 1/chance of the nodes
-	virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n){};
+	//virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n){};
+	//virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n, MapNode neighbor){};
 	virtual void trigger(ServerEnvironment *env, v3s16 p, MapNode n,
-			u32 active_object_count, u32 active_object_count_wider){};
+			u32 active_object_count, u32 active_object_count_wider, MapNode neighbor, bool activate = false){};
 };
 
 struct ABMWithState
 {
 	ActiveBlockModifier *abm;
+	float interval;
+	float chance;
 	float timer;
+	int neighbors_range;
+	bool simple_catchup;
+	std::unordered_set<content_t> trigger_ids;
+	FMBitset required_neighbors, required_neighbors_activate;
 
-	ABMWithState(ActiveBlockModifier *abm_);
+	ABMWithState(ActiveBlockModifier *abm_, ServerEnvironment *senv);
 };
 
 struct LoadingBlockModifierDef
@@ -276,12 +310,36 @@
 		m_list.clear();
 	}
 
-	std::set<v3s16> m_list;
+	maybe_concurrent_unordered_map<v3POS, bool, v3POSHash, v3POSEqual> m_list;
 	std::set<v3s16> m_forceloaded_list;
 
 private:
 };
 
+struct ActiveABM
+{
+	ActiveABM()
+	{}
+	ABMWithState *abmws;
+	int chance;
+};
+
+class ABMHandler
+{
+private:
+	ServerEnvironment *m_env;
+	std::array<std::vector<ActiveABM> *, CONTENT_ID_CAPACITY> m_aabms;
+	std::list<std::vector<ActiveABM>*> m_aabms_list;
+	bool m_aabms_empty;
+public:
+	ABMHandler(ServerEnvironment *env);
+	void init(std::vector<ABMWithState> &abms);
+	~ABMHandler();
+	u32 countObjects(MapBlock *block, ServerMap * map, u32 &wider);
+	void apply(MapBlock *block, bool activate = false);
+
+};
+
 /*
 	Operation mode for ServerEnvironment::clearObjects()
 */
@@ -304,7 +362,7 @@
 {
 public:
 	ServerEnvironment(ServerMap *map, GameScripting *scriptIface,
-			IGameDef *gamedef, const std::string &path_world);
+	                  IGameDef *gamedef, const std::string &path_world);
 	~ServerEnvironment();
 
 	Map & getMap();
@@ -321,6 +379,12 @@
 	float getSendRecommendedInterval()
 		{ return m_recommended_send_interval; }
 
+	//Player * getPlayer(u16 peer_id) { return Environment::getPlayer(peer_id); };
+	//Player * getPlayer(const std::string &name);
+
+	KeyValueStorage &getKeyValueStorage(std::string name = "key_value_storage");
+	KeyValueStorage &getPlayerStorage() { return getKeyValueStorage("players"); };
+
 	void kickAllPlayers(AccessDeniedCode reason,
 		const std::string &str_reason, bool reconnect);
 	// Save players
@@ -345,7 +409,7 @@
 		-------------------------------------------
 	*/
 
-	ServerActiveObject* getActiveObject(u16 id);
+	ServerActiveObject* getActiveObject(u16 id, bool removed = false);
 
 	/*
 		Add an active object to the environment.
@@ -357,6 +421,12 @@
 	*/
 	u16 addActiveObject(ServerActiveObject *object);
 
+	epixel::ItemSAO* spawnItemActiveObject(const std::string &itemName, v3f pos,
+			const ItemStack& items);
+
+	epixel::FallingSAO *spawnFallingActiveObject(const std::string &nodeName, v3f pos,
+			const MapNode n, int fast = 2);
+
 	/*
 		Add an active object as a static object to the corresponding
 		MapBlock.
@@ -372,7 +442,7 @@
 	*/
 	void getAddedActiveObjects(Player *player, s16 radius,
 			s16 player_radius,
-			std::set<u16> &current_objects,
+			maybe_concurrent_unordered_map<u16, bool> &current_objects,
 			std::queue<u16> &added_objects);
 
 	/*
@@ -381,7 +451,7 @@
 	*/
 	void getRemovedActiveObjects(Player* player, s16 radius,
 			s16 player_radius,
-			std::set<u16> &current_objects,
+			maybe_concurrent_unordered_map<u16, bool> &current_objects,
 			std::queue<u16> &removed_objects);
 
 	/*
@@ -410,8 +480,8 @@
 	*/
 
 	// Script-aware node setters
-	bool setNode(v3s16 p, const MapNode &n);
-	bool removeNode(v3s16 p);
+	bool setNode(v3s16 p, const MapNode &n, s16 fast = 0);
+	bool removeNode(v3s16 p, s16 fast = 0);
 	bool swapNode(v3s16 p, const MapNode &n);
 
 	// Find all active objects inside a radius around a point
@@ -421,23 +491,38 @@
 	void clearObjects(ClearObjectsMode mode);
 
 	// This makes stuff happen
-	void step(f32 dtime);
+	void step(f32 dtime, float uptime, unsigned int max_cycle_ms);
 
 	//check if there's a line of sight between two positions
 	bool line_of_sight(v3f pos1, v3f pos2, float stepsize=1.0, v3s16 *p=NULL);
 
 	u32 getGameTime() { return m_game_time; }
 
-	void reportMaxLagEstimate(float f) { m_max_lag_estimate = f; }
-	float getMaxLagEstimate() { return m_max_lag_estimate; }
+	void reportMaxLagEstimate(float f) { std::unique_lock<Mutex> lock(m_max_lag_estimate_mutex); m_max_lag_estimate = f; }
+	float getMaxLagEstimate() { std::unique_lock<Mutex> lock(m_max_lag_estimate_mutex); return m_max_lag_estimate; }
+
+	// is weather active in this environment?
+	bool m_use_weather;
+	bool m_use_weather_biome;
+	bool m_more_threads;
+	ABMHandler m_abmhandler;
+	void analyzeBlock(MapBlock * block);
+	IntervalLimiter m_analyze_blocks_interval;
+	IntervalLimiter m_abm_random_interval;
+	std::list<v3POS> m_abm_random_blocks;
+	int analyzeBlocks(float dtime, unsigned int max_cycle_ms);
 
 	std::set<v3s16>* getForceloadedBlocks() { return &m_active_blocks.m_forceloaded_list; };
 
+	u32 m_game_time_start;
+
 	// Sets the static object status all the active objects in the specified block
 	// This is only really needed for deleting blocks from the map
 	void setStaticForActiveObjectsInBlock(v3s16 blockpos,
 		bool static_exists, v3s16 static_block=v3s16(0,0,0));
 
+	void nodeUpdate(const v3s16 pos, u16 recursion_limit = 5, int fast = 2, bool destroy = false);
+	void handleNodeDrops(const ContentFeatures &f, v3f pos, PlayerSAO* player=NULL);
 private:
 
 	/*
@@ -460,7 +545,7 @@
 	/*
 		Remove all objects that satisfy (m_removed && m_known_by_count==0)
 	*/
-	void removeRemovedObjects();
+	void removeRemovedObjects(unsigned int max_cycle_ms = 1000);
 
 	/*
 		Convert stored objects from block to active
@@ -478,6 +563,21 @@
 	*/
 	void deactivateFarObjects(bool force_delete);
 
+
+/*
+	void contrib_player_globalstep(RemotePlayer *player, float dtime);
+	void contrib_lookupitemtogather(RemotePlayer* player, v3f playerPos,
+			Inventory* inv, ServerActiveObject* obj);
+*/
+	void contrib_globalstep(const float dtime);
+	bool checkAttachedNode(v3s16 pos, MapNode n, const ContentFeatures &f);
+/*
+	void explodeNode(const v3s16 pos);
+*/
+
+	std::deque<v3s16> m_nodeupdate_queue;
+	Mutex m_nodeupdate_queue_mutex;
+
 	/*
 		Member variables
 	*/
@@ -488,12 +588,24 @@
 	GameScripting* m_script;
 	// Game definition
 	IGameDef *m_gamedef;
+
+	// Circuit manager
+	Circuit m_circuit;
+	// Key-value storage
+public:
+	std::unordered_map<std::string, KeyValueStorage> m_key_value_storage;
+private:
+
 	// World path
 	const std::string m_path_world;
 	// Active object list
-	std::map<u16, ServerActiveObject*> m_active_objects;
+	maybe_concurrent_map<u16, ServerActiveObject*> m_active_objects;
+	std::vector<u16> objects_to_remove;
+	std::vector<ServerActiveObject*> objects_to_delete;
 	// Outgoing network message buffer for active objects
-	std::queue<ActiveObjectMessage> m_active_object_messages;
+public:
+	Queue<ActiveObjectMessage> m_active_object_messages;
+private:
 	// Some timers
 	float m_send_recommended_timer;
 	IntervalLimiter m_object_management_interval;
@@ -502,17 +614,28 @@
 	IntervalLimiter m_active_blocks_management_interval;
 	IntervalLimiter m_active_block_modifier_interval;
 	IntervalLimiter m_active_blocks_nodemetadata_interval;
-	int m_active_block_interval_overload_skip;
+	//loop breakers
+	u32 m_active_objects_last;
+	u32 m_active_block_abm_last;
+	float m_active_block_abm_dtime;
+	float m_active_block_abm_dtime_counter;
+	u32 m_active_block_timer_last;
+	std::set<v3s16> m_blocks_added;
+	u32 m_blocks_added_last;
+	u32 m_active_block_analyzed_last;
 	// Time from the beginning of the game in seconds.
 	// Incremented in step().
-	u32 m_game_time;
+	std::atomic_uint m_game_time;
+	Mutex m_max_lag_estimate_mutex;
 	// A helper variable for incrementing the latter
 	float m_game_time_fraction_counter;
 	// Time of last clearObjects call (game time).
 	// When a mapblock older than this is loaded, its objects are cleared.
 	u32 m_last_clear_objects_time;
 	// Active block modifiers
+public:
 	std::vector<ABMWithState> m_abms;
+private:
 	LBMManager m_lbm_mgr;
 	// An interval for generally sending object positions and stuff
 	float m_recommended_send_interval;
@@ -577,7 +700,7 @@
 	IGameDef *getGameDef()
 	{ return m_gamedef; }
 
-	void step(f32 dtime);
+	void step(f32 dtime, float uptime, unsigned int max_cycle_ms);
 
 	virtual void addPlayer(Player *player);
 	LocalPlayer * getLocalPlayer();
@@ -648,6 +771,8 @@
 	IGameDef *m_gamedef;
 	IrrlichtDevice *m_irr;
 	std::map<u16, ClientActiveObject*> m_active_objects;
+	u32 m_active_objects_client_last;
+	u32 m_move_max_loop;
 	std::vector<ClientSimpleObject*> m_simple_objects;
 	std::queue<ClientEnvEvent> m_client_event_queue;
 	IntervalLimiter m_active_object_light_update_interval;
