diff -ruN minetest-master/src/collision.cpp minetest-freeminer/src/collision.cpp
--- minetest-master/src/collision.cpp	2016-09-03 16:15:52.629779000 -0700
+++ minetest-freeminer/src/collision.cpp	2016-09-03 15:43:59.774740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+collision.cpp
 Copyright (C) 2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "collision.h"
@@ -30,9 +33,9 @@
 #include "util/timetaker.h"
 #include "profiler.h"
 
-// float error is 10 - 9.96875 = 0.03125
-//#define COLL_ZERO 0.032 // broken unit tests
-#define COLL_ZERO 0
+// float error is 10 - 9.96875 = 0.03125 // default with bug = 0
+#define COLL_ZERO 0.032 // broken unit tests
+#define COLL_ZEROY 0.032 //0.032 // Y only
 
 // Helper function:
 // Checks for collision of a moving aabbox with a static aabbox
@@ -44,9 +47,9 @@
 {
 	//TimeTaker tt("axisAlignedCollision");
 
-	f32 xsize = (staticbox.MaxEdge.X - staticbox.MinEdge.X) - COLL_ZERO;     // reduce box size for solve collision stuck (flying sand)
+	f32 xsize = (staticbox.MaxEdge.X - staticbox.MinEdge.X); // - COLL_ZEROY;     // reduce box size for solve collision stuck (flying sand)
 	f32 ysize = (staticbox.MaxEdge.Y - staticbox.MinEdge.Y); // - COLL_ZERO; // Y - no sense for falling, but maybe try later
-	f32 zsize = (staticbox.MaxEdge.Z - staticbox.MinEdge.Z) - COLL_ZERO;
+	f32 zsize = (staticbox.MaxEdge.Z - staticbox.MinEdge.Z); // - COLL_ZEROY;
 
 	aabb3f relbox(
 			movingbox.MinEdge.X - staticbox.MinEdge.X,
@@ -57,6 +60,15 @@
 			movingbox.MaxEdge.Z - staticbox.MinEdge.Z
 	);
 
+	// These cases can (and should) be rejected immediately
+	if( (speed.X >= 0 && relbox.MinEdge.X > xsize) ||
+	    (speed.X <= 0 && relbox.MaxEdge.X < 0) ||
+	    (speed.Y >= 0 && relbox.MinEdge.Y > ysize) ||
+	    (speed.Y <= 0 && relbox.MaxEdge.Y < 0) ||
+	    (speed.Z >= 0 && relbox.MinEdge.Z > zsize) ||
+	    (speed.Z <= 0 && relbox.MaxEdge.Z < 0))
+	    	return -1;
+
 	if(speed.X > 0) // Check for collision with X- plane
 	{
 		if (relbox.MaxEdge.X <= d) {
@@ -67,10 +79,6 @@
 					(relbox.MaxEdge.Z + speed.Z * (*dtime) > COLL_ZERO))
 				return 0;
 		}
-		else if(relbox.MinEdge.X > xsize)
-		{
-			return -1;
-		}
 	}
 	else if(speed.X < 0) // Check for collision with X+ plane
 	{
@@ -82,10 +90,6 @@
 					(relbox.MaxEdge.Z + speed.Z * (*dtime) > COLL_ZERO))
 				return 0;
 		}
-		else if(relbox.MaxEdge.X < 0)
-		{
-			return -1;
-		}
 	}
 
 	// NO else if here
@@ -100,25 +104,17 @@
 					(relbox.MaxEdge.Z + speed.Z * (*dtime) > COLL_ZERO))
 				return 1;
 		}
-		else if(relbox.MinEdge.Y > ysize)
-		{
-			return -1;
-		}
 	}
 	else if(speed.Y < 0) // Check for collision with Y+ plane
 	{
 		if (relbox.MinEdge.Y >= ysize - d) {
 			*dtime = (ysize - relbox.MinEdge.Y) / speed.Y;
 			if ((relbox.MinEdge.X + speed.X * (*dtime) < xsize) &&
-					(relbox.MaxEdge.X + speed.X * (*dtime) > COLL_ZERO) &&
+					(relbox.MaxEdge.X + speed.X * (*dtime) > COLL_ZEROY) &&
 					(relbox.MinEdge.Z + speed.Z * (*dtime) < zsize) &&
-					(relbox.MaxEdge.Z + speed.Z * (*dtime) > COLL_ZERO))
+					(relbox.MaxEdge.Z + speed.Z * (*dtime) > COLL_ZEROY))
 				return 1;
 		}
-		else if(relbox.MaxEdge.Y < 0)
-		{
-			return -1;
-		}
 	}
 
 	// NO else if here
@@ -133,10 +129,6 @@
 					(relbox.MaxEdge.Y + speed.Y * (*dtime) > COLL_ZERO))
 				return 2;
 		}
-		//else if(relbox.MinEdge.Z > zsize)
-		//{
-		//	return -1;
-		//}
 	}
 	else if(speed.Z < 0) // Check for collision with Z+ plane
 	{
@@ -148,10 +140,6 @@
 					(relbox.MaxEdge.Y + speed.Y * (*dtime) > COLL_ZERO))
 				return 2;
 		}
-		//else if(relbox.MaxEdge.Z < 0)
-		//{
-		//	return -1;
-		//}
 	}
 
 	return -1;
@@ -166,7 +154,8 @@
 {
 	//TimeTaker tt("wouldCollideWithCeiling");
 
-	assert(y_increase >= 0);	// pre-condition
+	if (!(y_increase >= 0))
+		return false;
 
 	for(std::vector<aabb3f>::const_iterator
 			i = staticboxes.begin();
@@ -203,20 +192,22 @@
 	static bool time_notification_done = false;
 	Map *map = &env->getMap();
 	//TimeTaker tt("collisionMoveSimple");
+/*
 	ScopeProfiler sp(g_profiler, "collisionMoveSimple avg", SPT_AVG);
+*/
 
 	collisionMoveResult result;
 
 	/*
 		Calculate new velocity
 	*/
-	if (dtime > 0.5) {
+	if (dtime > 1) {
 		if (!time_notification_done) {
 			time_notification_done = true;
 			infostream << "collisionMoveSimple: maximum step interval exceeded,"
 					" lost movement details!"<<std::endl;
 		}
-		dtime = 0.5;
+		dtime = 1;
 	} else {
 		time_notification_done = false;
 	}
@@ -227,9 +218,9 @@
 		return result;
 
 	// Limit speed for avoiding hangs
-	speed_f->Y = rangelim(speed_f->Y, -5000, 5000);
-	speed_f->X = rangelim(speed_f->X, -5000, 5000);
-	speed_f->Z = rangelim(speed_f->Z, -5000, 5000);
+	speed_f->Y = rangelim(speed_f->Y, -1000, 1000);
+	speed_f->X = rangelim(speed_f->X, -1000, 1000);
+	speed_f->Z = rangelim(speed_f->Z, -1000, 1000);
 
 	/*
 		Collect node boxes in movement range
@@ -242,7 +233,9 @@
 	std::vector<v3s16> node_positions;
 	{
 	//TimeTaker tt2("collisionMoveSimple collect boxes");
+/*
 	ScopeProfiler sp(g_profiler, "collisionMoveSimple collect boxes avg", SPT_AVG);
+*/
 
 	v3s16 oldpos_i = floatToInt(*pos_f, BS);
 	v3s16 newpos_i = floatToInt(*pos_f + *speed_f * dtime, BS);
@@ -341,7 +334,7 @@
 
 	if(collideWithObjects)
 	{
-		ScopeProfiler sp(g_profiler, "collisionMoveSimple objects avg", SPT_AVG);
+		//ScopeProfiler sp(g_profiler, "collisionMoveSimple objects avg", SPT_AVG);
 		//TimeTaker tt3("collisionMoveSimple collect object boxes");
 
 		/* add object boxes to cboxes */
@@ -395,11 +388,13 @@
 		}
 	} //tt3
 
+/*
 	assert(cboxes.size() == is_unloaded.size());    // post-condition
 	assert(cboxes.size() == is_step_up.size());     // post-condition
 	assert(cboxes.size() == bouncy_values.size());  // post-condition
 	assert(cboxes.size() == node_positions.size()); // post-condition
 	assert(cboxes.size() == is_object.size());      // post-condition
+*/
 
 	/*
 		Collision detection
@@ -414,13 +409,16 @@
 	//f32 d = 0.15*BS;
 
 	// This should always apply, otherwise there are glitches
-	assert(d > pos_max_d);	// invariant
+	if(!(d > pos_max_d))
+		return result;
 
 	int loopcount = 0;
 
 	while(dtime > BS * 1e-10) {
 		//TimeTaker tt3("collisionMoveSimple dtime loop");
+/*
         	ScopeProfiler sp(g_profiler, "collisionMoveSimple dtime loop avg", SPT_AVG);
+*/
 
 		// Avoid infinite loop
 		loopcount++;
