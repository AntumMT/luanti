diff -ruN minetest-master/src/camera.cpp minetest-freeminer/src/camera.cpp
--- minetest-master/src/camera.cpp	2016-09-03 16:15:52.489778000 -0700
+++ minetest-freeminer/src/camera.cpp	2016-09-03 15:43:59.866740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+camera.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "camera.h"
@@ -36,9 +39,13 @@
 #include "constants.h"
 #include "fontengine.h"
 
-#define CAMERA_OFFSET_STEP 200
+#define CAMERA_OFFSET_STEP 1000
+
+#include "nodedef.h"
+#include "game.h" // CameraModes
 
 #include "nodedef.h"
+#include "log_types.h"
 
 Camera::Camera(scene::ISceneManager* smgr, MapDrawControl& draw_control,
 		IGameDef *gamedef):
@@ -47,6 +54,8 @@
 	m_cameranode(NULL),
 
 	m_wieldmgr(NULL),
+	m_wieldlight(0),
+	m_wieldlight_add(0),
 	m_wieldnode(NULL),
 
 	m_draw_control(draw_control),
@@ -100,8 +109,12 @@
 	 *       (as opposed to the this local caching). This can be addressed in
 	 *       a later release.
 	 */
+
+	m_cache_movement_fov        = g_settings->getBool("movement_fov");
+
 	m_cache_fall_bobbing_amount = g_settings->getFloat("fall_bobbing_amount");
 	m_cache_view_bobbing_amount = g_settings->getFloat("view_bobbing_amount");
+	m_cache_wanted_fps          = g_settings->getFloat("wanted_fps");
 	m_cache_fov                 = g_settings->getFloat("fov");
 	m_cache_zoom_fov            = g_settings->getFloat("zoom_fov");
 	m_cache_view_bobbing        = g_settings->getBool("view_bobbing");
@@ -260,6 +273,7 @@
 		// Smoothen and invert the above
 		fall_bobbing = sin(fall_bobbing * 0.5 * M_PI) * -1;
 		// Amplify according to the intensity of the impact
+		if (player->camera_impact)
 		fall_bobbing *= (1 - rangelim(50 / player->camera_impact, 0, 1)) * 5;
 
 		fall_bobbing *= m_cache_fall_bobbing_amount;
@@ -389,12 +403,26 @@
 		m_camera_position = my_cp;
 
 	// Get FOV
-	f32 fov_degrees;
+	f32 fov_degrees = m_draw_control.fov;
 	if (player->getPlayerControl().zoom && m_gamedef->checkLocalPrivilege("zoom")) {
-		fov_degrees = m_cache_zoom_fov;
+		m_wieldnode->setVisible(false);
 	} else {
-		fov_degrees = m_cache_fov;
+		m_wieldnode->setVisible(true);
 	}
+
+	// Greater FOV if running
+	v3f speed = player->getSpeed();
+
+	if (m_cache_movement_fov) {
+		auto fov_was = m_draw_control.fov_add;
+		m_draw_control.fov_add = speed.dotProduct(m_camera_direction)/(BS*4);
+		if (m_draw_control.fov_add > fov_was + 1)
+			m_draw_control.fov_add = fov_was + ( m_draw_control.fov_add - fov_was) / 3;
+		else if (m_draw_control.fov_add < fov_was - 1)
+			m_draw_control.fov_add = fov_was - (fov_was - m_draw_control.fov_add) / 3;
+		fov_degrees -= m_draw_control.fov_add;
+	}
+
 	fov_degrees = MYMAX(fov_degrees, 10.0);
 	fov_degrees = MYMIN(fov_degrees, 170.0);
 
@@ -459,7 +487,6 @@
 	// If the player is walking, swimming, or climbing,
 	// view bobbing is enabled and free_move is off,
 	// start (or continue) the view bobbing animation.
-	v3f speed = player->getSpeed();
 	const bool movement_XZ = hypot(speed.X, speed.Z) > BS;
 	const bool movement_Y = fabs(speed.Y) > BS;
 
@@ -489,8 +516,205 @@
 		return;
 	}
 
+//fm dynamic range:
+/*
+	m_added_busytime += busytime_in;
+	m_added_frames += 1;
+
+	m_frametime_counter -= frametime_in;
+	if (m_frametime_counter > 0)
+		return;
+	m_frametime_counter = 0.2; // Same as ClientMap::updateDrawList interval
+*/
+	/*dstream<<FUNCTION_NAME
+			<<": Collected "<<m_added_frames<<" frames, total of "
+			<<m_added_busytime<<"s."<<std::endl;
+
+	dstream<<"m_draw_control.blocks_drawn="
+			<<m_draw_control.blocks_drawn
+			<<", m_draw_control.blocks_would_have_drawn="
+			<<m_draw_control.blocks_would_have_drawn
+			<<std::endl;*/
+
+	// Get current viewing range and FPS settings
+	f32 viewing_range_min = g_settings->getFloat("viewing_range");
+	viewing_range_min = MYMAX(15.0, viewing_range_min);
+
+	f32 viewing_range_max = g_settings->getFloat("viewing_range_max");
+	viewing_range_max = MYMAX(viewing_range_min, viewing_range_max);
+	// vrange+position must be smaller than 32767
+	viewing_range_max = MYMIN(viewing_range_max, 32760 - MYMAX(MYMAX(std::abs(m_camera_position.X/BS), std::abs(m_camera_position.Y/BS)), std::abs(m_camera_position.Z/BS)));
+
+	f32 wanted_fps = m_cache_wanted_fps;
+	wanted_fps = MYMAX(wanted_fps, 1.0);
+
+	// todo: remake
+	if (m_draw_control.fps > wanted_fps && m_draw_control.fps_avg > wanted_fps * 1.2) {
+		m_draw_control.wanted_range += 1;
+	} else if (m_draw_control.fps_avg < wanted_fps) {
+		if (m_draw_control.fps < wanted_fps * 0.7) {
+			m_draw_control.wanted_range *= 0.9;
+		} else if (m_draw_control.fps < wanted_fps) {
+			m_draw_control.wanted_range -= 1;
+		}
+	} else if (m_draw_control.fps < wanted_fps * 0.7) {
+		m_draw_control.wanted_range *= 0.9;
+	}
+
+	// Immediately apply hard limits
+	if(m_draw_control.wanted_range < viewing_range_min)
+		m_draw_control.wanted_range = viewing_range_min;
+	if(m_draw_control.wanted_range > viewing_range_max)
+		m_draw_control.wanted_range = viewing_range_max;
+
+	int farmesh = g_settings->getS32("farmesh");
+	//int farmesh_step = g_settings->getS32("farmesh_step");
+	int farmesh_wanted = g_settings->getS32("farmesh_wanted");
+
+#if OOOOOOOOOOOOOOOld
+	f32 wanted_frametime = 1.0 / wanted_fps;
+
+	//m_draw_control.wanted_min_range = viewing_range_min;
+	//m_draw_control.wanted_max_blocks = (2.0*m_draw_control.blocks_would_have_drawn)+1;
+	//if (m_draw_control.wanted_max_blocks < 10)
+		//m_draw_control.wanted_max_blocks = 10;
+
+/*
+	f32 block_draw_ratio = 1.0;
+	if (m_draw_control.blocks_would_have_drawn != 0)
+	{
+		block_draw_ratio = (f32)m_draw_control.blocks_drawn
+			/ (f32)m_draw_control.blocks_would_have_drawn;
+	}
+*/
+
+	// Calculate the average frametime in the case that all wanted
+	// blocks had been drawn
+	f32 frametime = m_added_busytime / m_added_frames /* / block_draw_ratio */ ;
+
+	m_added_busytime = 0.0;
+	m_added_frames = 0;
+
+	f32 wanted_frametime_change = wanted_frametime - frametime;
+	//dstream<<"wanted_frametime_change="<<wanted_frametime_change<<std::endl;
+	//g_profiler->avg("wanted_frametime_change", wanted_frametime_change);
+#endif
+
+	static int framecnt = 0;
+	m_draw_control.fps_wanted = wanted_fps;
+	if (farmesh) {
+			//infostream<<" m_draw_control.fps="<<m_draw_control.fps<< " wanted_fps="<< wanted_fps << " m_draw_control.fps_avg="<< m_draw_control.fps_avg <<" wanted_fps*1.4="<< wanted_fps*1.4 /*<<" block_draw_ratio="<<block_draw_ratio */<< " wanted_frametime="<< wanted_frametime <<" .blocks_would_have_drawn=" <<m_draw_control.blocks_would_have_drawn <<" .blocks_drawn=" <<m_draw_control.blocks_drawn <<std::endl;
+			if (m_draw_control.fps > wanted_fps && m_draw_control.fps_avg >= wanted_fps*1.3) {
+				if (++framecnt > m_draw_control.fps_avg/2) {
+					if (m_draw_control.wanted_range >= farmesh_wanted) {
+						m_draw_control.farmesh = (int)m_draw_control.farmesh + 1;
+						framecnt = 0;
+					}
+					//if (m_draw_control.farmesh >= farmesh*1.3 && m_draw_control.farmesh_step < farmesh_step) {
+					//	++m_draw_control.farmesh_step;
+					//	framecnt = 0;
+					//}
+				}
+			} else if (m_draw_control.fps <= wanted_fps*0.8){
+				float farmesh_was = m_draw_control.farmesh;
+				if (m_draw_control.fps <= wanted_fps*0.6)
+					m_draw_control.farmesh = farmesh;
+				else if (m_draw_control.fps <= wanted_fps*0.7)
+					m_draw_control.farmesh *= 0.5;
+				else if (m_draw_control.farmesh>10)
+					m_draw_control.farmesh *= 0.8;
+				else
+					m_draw_control.farmesh -= 1;
+				if (m_draw_control.farmesh < farmesh)
+					m_draw_control.farmesh = farmesh;
+				//if (m_draw_control.farmesh <= farmesh && m_draw_control.farmesh_step > 1 && m_draw_control.fps <= wanted_fps*0.3)
+				//	--m_draw_control.farmesh_step;
+				if (farmesh_was != m_draw_control.farmesh)
+					return;
+			}
+	}
+
+#if OOOOOOOOOOOOOOOld
+	// If needed frametime change is small, just return
+	// This value was 0.4 for many months until 2011-10-18 by c55;
+	//if (fabs(wanted_frametime_change) < wanted_frametime*0.33)
+	if (wanted_frametime_change > -wanted_frametime*0.33 && wanted_frametime_change < wanted_frametime*0.15)
+	{
+		//dstream<<"ignoring small wanted_frametime_change"<<std::endl;
+		return;
+	}
+
+	f32 range = m_draw_control.wanted_range;
+	f32 new_range = range;
+
+	f32 d_range = range - m_range_old;
+	f32 d_busytime = busytime_in - m_busytime_old;
+	if (d_range != 0)
+	{
+		m_time_per_range = d_busytime / d_range;
+	}
+	//dstream<<"time_per_range="<<m_time_per_range<<std::endl;
+	//g_profiler->avg("time_per_range", m_time_per_range);
+
+	// The minimum allowed calculated frametime-range derivative:
+	// Practically this sets the maximum speed of changing the range.
+	// The lower this value, the higher the maximum changing speed.
+	// A low value here results in wobbly range (0.001)
+	// A low value can cause oscillation in very nonlinear time/range curves.
+	// A high value here results in slow changing range (0.0025)
+	// SUGG: This could be dynamically adjusted so that when
+	//       the camera is turning, this is lower
+	//f32 min_time_per_range = 0.0010; // Up to 0.4.7
+	f32 min_time_per_range = 0.0005;
+	if(m_time_per_range < min_time_per_range)
+	{
+		m_time_per_range = min_time_per_range;
+		//dstream<<"m_time_per_range="<<m_time_per_range<<" (min)"<<std::endl;
+	}
+	else
+	{
+		//dstream<<"m_time_per_range="<<m_time_per_range<<std::endl;
+	}
+
+	f32 wanted_range_change = wanted_frametime_change / m_time_per_range;
+	// Dampen the change a bit to kill oscillations
+	//wanted_range_change *= 0.9;
+	//wanted_range_change *= 0.75;
+	wanted_range_change *= 0.5;
+	if (wanted_range_change > 1)
+		wanted_range_change *= 0.4;
+	//dstream<<"wanted_range_change="<<wanted_range_change<<std::endl;
+
+	//infostream<< " wanted_range_change=" << wanted_range_change <<" m_time_per_range="<<m_time_per_range << " wanted_frametime_change="<<wanted_frametime_change<< std::endl;
+
+	// If needed range change is very small, just return
+	if(fabs(wanted_range_change) < 0.001)
+	{
+		//dstream<<"ignoring small wanted_range_change"<<std::endl;
+		return;
+	}
+
+	new_range += wanted_range_change;
+
+	//f32 new_range_unclamped = new_range;
+	new_range = MYMAX(new_range, viewing_range_min);
+	new_range = MYMIN(new_range, viewing_range_max);
+	/ * dstream<<"new_range="<<new_range_unclamped
+			<<", clamped to "<<new_range<<std::endl;* /
+
+	m_range_old = m_draw_control.wanted_range;
+	m_busytime_old = busytime_in;
+
+	m_draw_control.wanted_range = new_range;
+#endif
+
+	g_profiler->add("CM: wanted_range", m_draw_control.wanted_range);
+
+	const auto viewing_range = m_draw_control.wanted_range;
+/* mt static range:
 	f32 viewing_range = g_settings->getFloat("viewing_range");
 	m_draw_control.wanted_range = viewing_range;
+*/
 	m_cameranode->setFarValue((viewing_range < 2000) ? 2000 * BS : viewing_range * BS);
 }
 
@@ -509,10 +733,24 @@
 		else if (m_wield_change_timer == 0)
 			m_wield_change_timer = -0.001;
 	}
+	IItemDefManager *idef = m_gamedef->idef();
+	std::string itemname = item.getDefinition(idef).name;
+	m_wieldlight_add = ((ItemGroupList)idef->get(itemname).groups)["wield_light"]*200/14;
 }
 
 void Camera::drawWieldedTool(irr::core::matrix4* translation)
 {
+	// Set vertex colors of wield mesh according to light level
+	u8 li = m_wieldlight;
+	if (g_settings->getBool("enable_shaders"))
+	{
+		if (li+m_wieldlight_add < 200)
+			li += m_wieldlight_add;
+		else
+			li = 200;
+	}
+	video::SColor color(255,li,li,li);
+
 	// Clear Z buffer so that the wielded tool stay in front of world geometry
 	m_wieldmgr->getVideoDriver()->clearZBuffer();
 
@@ -577,6 +815,14 @@
 Nametag *Camera::addNametag(scene::ISceneNode *parent_node,
 		std::string nametag_text, video::SColor nametag_color)
 {
+
+	auto nametag_text_wide = utf8_to_wide(nametag_text);
+	if (nametag_text_wide.size() > 15) {
+		nametag_text_wide.resize(15);
+		nametag_text_wide += L".";
+		nametag_text = wide_to_utf8(nametag_text_wide);
+	}
+
 	Nametag *nametag = new Nametag(parent_node, nametag_text, nametag_color);
 	m_nametags.push_back(nametag);
 	return nametag;
