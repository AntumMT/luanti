diff -ruN minetest-master/src/server.cpp minetest-freeminer/src/server.cpp
--- minetest-master/src/server.cpp	2016-09-03 16:15:52.593779000 -0700
+++ minetest-freeminer/src/server.cpp	2016-09-03 15:43:59.754740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+server.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "server.h"
@@ -37,7 +40,7 @@
 #include "genericobject.h"
 #include "settings.h"
 #include "profiler.h"
-#include "log.h"
+#include "log_types.h"
 #include "scripting_game.h"
 #include "nodedef.h"
 #include "itemdef.h"
@@ -50,18 +53,34 @@
 #include "content_abm.h"
 #include "content_sao.h"
 #include "mods.h"
+#include "util/sha1.h"
+#include "util/base64.h"
+#include "tool.h"
 #include "sound.h" // dummySoundManager
 #include "event_manager.h"
+#include "util/hex.h"
 #include "serverlist.h"
 #include "util/string.h"
+#include "util/pointedthing.h"
 #include "util/mathconstants.h"
 #include "rollback.h"
 #include "util/serialize.h"
 #include "util/thread.h"
 #include "defaultsettings.h"
-#include "util/base64.h"
-#include "util/sha1.h"
-#include "util/hex.h"
+//#include "stat.h"
+
+#include <iomanip>
+#include "msgpack_fix.h"
+#include <chrono>
+#include "threading/thread_pool.h"
+#include "key_value_storage.h"
+#include "database.h"
+
+
+#if !MINETEST_PROTO
+#include "network/fm_serverpacketsender.cpp"
+#endif
+
 
 class ClientNotFoundException : public BaseException
 {
@@ -71,6 +90,10 @@
 	{}
 };
 
+#include "fm_server.cpp"
+
+#if 0
+
 class ServerThread : public Thread
 {
 public:
@@ -117,6 +140,8 @@
 	return NULL;
 }
 
+#endif
+
 v3f ServerSoundParams::getPos(ServerEnvironment *env, bool *pos_exists) const
 {
 	if(pos_exists) *pos_exists = false;
@@ -138,8 +163,6 @@
 	return v3f(0,0,0);
 }
 
-
-
 /*
 	Server
 */
@@ -157,7 +180,7 @@
 	m_async_fatal_error(""),
 	m_env(NULL),
 	m_con(PROTOCOL_ID,
-			512,
+			simple_singleplayer_mode ? MAX_PACKET_SIZE_SINGLEPLAYER : MAX_PACKET_SIZE,
 			CONNECTION_TIMEOUT,
 			ipv6,
 			this),
@@ -166,11 +189,17 @@
 	m_enable_rollback_recording(false),
 	m_emerge(NULL),
 	m_script(NULL),
+	stat(path_world),
 	m_itemdef(createItemDefManager()),
 	m_nodedef(createNodeDefManager()),
 	m_craftdef(createCraftDefManager()),
 	m_event(new EventManager()),
 	m_thread(NULL),
+	m_map_thread(nullptr),
+	m_sendblocks(nullptr),
+	m_liquid(nullptr),
+	m_envthread(nullptr),
+	m_abmthread(nullptr),
 	m_time_of_day_send_timer(0),
 	m_uptime(0),
 	m_clients(&m_con),
@@ -183,15 +212,20 @@
 
 {
 	m_liquid_transform_timer = 0.0;
-	m_liquid_transform_every = 1.0;
+	m_liquid_transform_interval = 1.0;
+	m_liquid_send_timer = 0.0;
+	m_liquid_send_interval = 1.0;
 	m_print_info_timer = 0.0;
 	m_masterserver_timer = 0.0;
 	m_objectdata_timer = 0.0;
-	m_emergethread_trigger_timer = 0.0;
+	//m_emergethread_trigger_timer = 5.0; // to start emerge threads instantly
 	m_savemap_timer = 0.0;
 
 	m_step_dtime = 0.0;
 	m_lag = g_settings->getFloat("dedicated_server_step");
+#if ENABLE_THREADS
+	m_more_threads = g_settings->getBool("more_threads");
+#endif
 
 	if(path_world == "")
 		throw ServerError("Supplied empty world path");
@@ -207,9 +241,12 @@
 	infostream<<"- world:  "<<m_path_world<<std::endl;
 	infostream<<"- game:   "<<m_gamespec.path<<std::endl;
 
-	// Create world if it doesn't exist
-	if(!loadGameConfAndInitWorld(m_path_world, m_gamespec))
-		throw ServerError("Failed to initialize world");
+	// Initialize default settings and override defaults with those provided
+	// by the game
+	set_default_settings(g_settings);
+	Settings gamedefaults;
+	getGameMinetestConfig(gamespec.path, gamedefaults);
+	override_default_settings(g_settings, &gamedefaults);
 
 	// Create server thread
 	m_thread = new ServerThread(this);
@@ -217,6 +254,18 @@
 	// Create emerge manager
 	m_emerge = new EmergeManager(this);
 
+	if (m_more_threads) {
+		m_map_thread = new MapThread(this);
+		m_sendblocks = new SendBlocksThread(this);
+		m_liquid = new LiquidThread(this);
+		m_envthread = new EnvThread(this);
+		m_abmthread = new AbmThread(this);
+	}
+
+	// Create world if it doesn't exist
+	if(!loadGameConfAndInitWorld(m_path_world, m_gamespec))
+		throw ServerError("Failed to initialize world");
+
 	// Create ban manager
 	std::string ban_path = m_path_world + DIR_DELIM "ipban.txt";
 	m_banmanager = new BanManager(ban_path);
@@ -264,7 +313,7 @@
 	}
 
 	//lock environment
-	MutexAutoLock envlock(m_env_mutex);
+	//MutexAutoLock envlock(m_env_mutex);
 
 	// Create the Map (loads map_meta.txt, overriding configured mapgen params)
 	ServerMap *servermap = new ServerMap(path_world, this, m_emerge);
@@ -296,6 +345,10 @@
 				"Only chararacters [a-z0-9_] are allowed.");
 		}
 		std::string script_path = mod.path + DIR_DELIM + "init.lua";
+		if (!fs::PathExists(script_path)) {
+			errorstream << "Ignoring empty mod: "<< mod.name << std::endl;
+			continue;
+		}
 		infostream << "  [" << padStringRight(mod.name, 12) << "] [\""
 				<< script_path << "\"]" << std::endl;
 		m_script->loadMod(script_path, mod.name);
@@ -325,6 +378,8 @@
 
 	// Initialize Environment
 	m_env = new ServerEnvironment(servermap, m_script, this, m_path_world);
+	m_env->m_more_threads = m_more_threads;
+	m_emerge->env = m_env;
 
 	m_clients.setEnv(m_env);
 
@@ -334,11 +389,13 @@
 	// Initialize mapgens
 	m_emerge->initMapgens(servermap->getMapgenParams());
 
+#if USE_SQLITE
 	m_enable_rollback_recording = g_settings->getBool("enable_rollback_recording");
 	if (m_enable_rollback_recording) {
 		// Create rollback manager
 		m_rollback = new RollbackManager(m_path_world, this);
 	}
+#endif
 
 	// Give environment reference to scripting api
 	m_script->initializeEnvironment(m_env);
@@ -357,18 +414,26 @@
 	// Add some test ActiveBlockModifiers to environment
 	add_legacy_abms(m_env, m_nodedef);
 
-	m_liquid_transform_every = g_settings->getFloat("liquid_update");
+	m_env->m_abmhandler.init(m_env->m_abms); // uses result of add_legacy_abms and m_script->initializeEnvironment
+
+	m_liquid_transform_interval = g_settings->getFloat("liquid_update");
+	m_liquid_send_interval = g_settings->getFloat("liquid_send");
+
+	m_emerge->startThreads();
 }
 
 Server::~Server()
 {
 	infostream<<"Server destructing"<<std::endl;
 
+	if (!m_simple_singleplayer_mode && g_settings->getBool("server_announce"))
+		ServerList::sendAnnounce("delete", m_bind_addr.getPort());
+
 	// Send shutdown message
-	SendChatMessage(PEER_ID_INEXISTENT, L"*** Server shutting down");
+	SendChatMessage(PEER_ID_INEXISTENT, "*** Server shutting down");
 
 	{
-		MutexAutoLock envlock(m_env_mutex);
+		//MutexAutoLock envlock(m_env_mutex);
 
 		// Execute script shutdown hooks
 		m_script->on_shutdown();
@@ -397,6 +462,12 @@
 	stop();
 	delete m_thread;
 
+	delete m_liquid;
+	delete m_sendblocks;
+	delete m_map_thread;
+	delete m_abmthread;
+	delete m_envthread;
+
 	// stop all emerge threads before deleting players that may have
 	// requested blocks to be emerged
 	m_emerge->stopThreads();
@@ -421,6 +492,8 @@
 			i != m_detached_inventories.end(); ++i) {
 		delete i->second;
 	}
+	while (!m_unsent_map_edit_queue.empty())
+		delete m_unsent_map_edit_queue.pop_front();
 }
 
 void Server::start(Address bind_addr)
@@ -432,28 +505,52 @@
 	infostream<<"Starting server on "
 			<< bind_addr.serializeString() <<"..."<<std::endl;
 
-	// Stop thread if already running
-	m_thread->stop();
-
 	// Initialize connection
-	m_con.SetTimeoutMs(30);
 	m_con.Serve(bind_addr);
 
 	// Start thread
-	m_thread->start();
+	m_thread->restart();
+	if (m_map_thread)
+		m_map_thread->restart();
+	if (m_sendblocks)
+		m_sendblocks->restart();
+	if (m_liquid)
+		m_liquid->restart();
+	if(m_envthread)
+		m_envthread->restart();
+	if(m_abmthread)
+		m_abmthread->restart();
+
+	actionstream << "\033[1mfree\033[1;33mminer \033[1;36mv" << g_version_hash << "\033[0m \t"
+#if ENABLE_THREADS
+			<< " THREADS \t"
+#endif
+#ifndef NDEBUG
+			<< " DEBUG \t"
+#endif
+#if MINETEST_PROTO
+			<< " MINETEST_PROTO \t"
+#endif
+			<< " cpp=" <<__cplusplus << " \t"
+
+			<< " cores=";
+	auto cores_online = std::thread::hardware_concurrency(), cores_avail = Thread::getNumberOfProcessors();
+	if (cores_online != cores_avail)
+		actionstream << cores_online << "/";
+	actionstream << cores_avail
 
-	// ASCII art for the win!
-	actionstream
-	<<"        .__               __                   __   "<<std::endl
-	<<"  _____ |__| ____   _____/  |_  ____   _______/  |_ "<<std::endl
-	<<" /     \\|  |/    \\_/ __ \\   __\\/ __ \\ /  ___/\\   __\\"<<std::endl
-	<<"|  Y Y  \\  |   |  \\  ___/|  | \\  ___/ \\___ \\  |  |  "<<std::endl
-	<<"|__|_|  /__|___|  /\\___  >__|  \\___  >____  > |__|  "<<std::endl
-	<<"      \\/        \\/     \\/          \\/     \\/        "<<std::endl;
+#if __ANDROID__
+			<< " android=" << porting::android_version_sdk_int
+#endif
+			<< std::endl;
 	actionstream<<"World at ["<<m_path_world<<"]"<<std::endl;
 	actionstream<<"Server for gameid=\""<<m_gamespec.id
+			<< "\" mapgen=\"" << Mapgen::getMapgenName(m_emerge->mgparams->mgtype)
 			<<"\" listening on "<<bind_addr.serializeString()<<":"
 			<<bind_addr.getPort() << "."<<std::endl;
+
+	if (!m_simple_singleplayer_mode && g_settings->getBool("serverlist_lan"))
+		lan_adv_server.serve(m_bind_addr.getPort());
 }
 
 void Server::stop()
@@ -464,9 +561,30 @@
 
 	// Stop threads (set run=false first so both start stopping)
 	m_thread->stop();
+	if (m_liquid)
+		m_liquid->stop();
+	if (m_sendblocks)
+		m_sendblocks->stop();
+	if (m_map_thread)
+		m_map_thread->stop();
+	if(m_abmthread)
+		m_abmthread->stop();
+	if(m_envthread)
+		m_envthread->stop();
+
 	//m_emergethread.setRun(false);
-	m_thread->wait();
+	m_thread->join();
 	//m_emergethread.stop();
+	if (m_liquid)
+		m_liquid->join();
+	if (m_sendblocks)
+		m_sendblocks->join();
+	if (m_map_thread)
+		m_map_thread->join();
+	if(m_abmthread)
+		m_abmthread->join();
+	if(m_envthread)
+		m_envthread->join();
 
 	infostream<<"Server: Threads stopped"<<std::endl;
 }
@@ -481,31 +599,37 @@
 		MutexAutoLock lock(m_step_dtime_mutex);
 		m_step_dtime += dtime;
 	}
-	// Throw if fatal error occurred in thread
+	// Assert if fatal error occurred in thread
 	std::string async_err = m_async_fatal_error.get();
 	if (!async_err.empty()) {
+/*
 		if (!m_simple_singleplayer_mode) {
 			m_env->kickAllPlayers(SERVER_ACCESSDENIED_CRASH,
 				g_settings->get("kick_msg_crash"),
 				g_settings->getBool("ask_reconnect_on_crash"));
 		}
 		throw ServerError(async_err);
+*/
 	}
 }
 
-void Server::AsyncRunStep(bool initial_step)
+void Server::AsyncRunStep(float dtime, bool initial_step)
 {
 	DSTACK(FUNCTION_NAME);
 
+	TimeTaker timer_step("Server step");
 	g_profiler->add("Server::AsyncRunStep (num)", 1);
-
+/*
 	float dtime;
 	{
 		MutexAutoLock lock1(m_step_dtime_mutex);
 		dtime = m_step_dtime;
 	}
+*/
 
+	if (!m_more_threads)
 	{
+		TimeTaker timer_step("Server step: SendBlocks");
 		// Send blocks to clients
 		SendBlocks(dtime);
 	}
@@ -513,15 +637,20 @@
 	if((dtime < 0.001) && (initial_step == false))
 		return;
 
+/*
 	g_profiler->add("Server::AsyncRunStep with dtime (num)", 1);
-
+*/
+	ScopeProfiler sp(g_profiler, "Server::AsyncRunStep, avg", SPT_AVG);
 	//infostream<<"Server steps "<<dtime<<std::endl;
 	//infostream<<"Server::AsyncRunStep(): dtime="<<dtime<<std::endl;
 
+/*
 	{
+		TimeTaker timer_step("Server step: SendBlocks");
 		MutexAutoLock lock1(m_step_dtime_mutex);
 		m_step_dtime -= dtime;
 	}
+*/
 
 	/*
 		Update uptime
@@ -530,43 +659,67 @@
 		m_uptime.set(m_uptime.get() + dtime);
 	}
 
-	handlePeerChanges();
+	f32 dedicated_server_step = g_settings->getFloat("dedicated_server_step");
+	//u32 max_cycle_ms = 1000 * (m_lag > dedicated_server_step ? dedicated_server_step/(m_lag/dedicated_server_step) : dedicated_server_step);
+	u32 max_cycle_ms = 1000 * (dedicated_server_step/(m_lag/dedicated_server_step));
+	if (max_cycle_ms < 40)
+		max_cycle_ms = 40;
+
+	{
+		TimeTaker timer_step("Server step: handlePeerChanges");
+		// This has to be called so that the client list gets synced
+		// with the peer list of the connection
+		handlePeerChanges();
+	}
 
 	/*
 		Update time of day and overall game time
 	*/
-	m_env->setTimeOfDaySpeed(g_settings->getFloat("time_speed"));
+	{
+		TimeTaker timer_step("Server step: pdate time of day and overall game time");
+		//MutexAutoLock envlock(m_env_mutex);
 
-	/*
-		Send to clients at constant intervals
-	*/
+		m_env->setTimeOfDaySpeed(g_settings->getFloat("time_speed"));
 
-	m_time_of_day_send_timer -= dtime;
-	if(m_time_of_day_send_timer < 0.0) {
-		m_time_of_day_send_timer = g_settings->getFloat("time_send_interval");
-		u16 time = m_env->getTimeOfDay();
-		float time_speed = g_settings->getFloat("time_speed");
-		SendTimeOfDay(PEER_ID_INEXISTENT, time, time_speed);
+		/*
+			Send to clients at constant intervals
+		*/
+
+		m_time_of_day_send_timer -= dtime;
+		if(m_time_of_day_send_timer < 0.0)
+		{
+			m_time_of_day_send_timer = g_settings->getFloat("time_send_interval");
+			u16 time = m_env->getTimeOfDay();
+			float time_speed = g_settings->getFloat("time_speed");
+			SendTimeOfDay(PEER_ID_INEXISTENT, time, time_speed);
+
+			// bad place, but every 5s ok
+			lan_adv_server.clients_num = m_clients.getPlayerNames().size();
+		}
 	}
 
 	{
-		MutexAutoLock lock(m_env_mutex);
+		//TimeTaker timer_step("Server step: m_env->step");
+		//MutexAutoLock lock(m_env_mutex);
 		// Figure out and report maximum lag to environment
 		float max_lag = m_env->getMaxLagEstimate();
 		max_lag *= 0.9998; // Decrease slowly (about half per 5 minutes)
 		if(dtime > max_lag){
-			if(dtime > 0.1 && dtime > max_lag * 2.0)
+			if(dtime > dedicated_server_step && dtime > max_lag * 2.0)
 				infostream<<"Server: Maximum lag peaked to "<<dtime
 						<<" s"<<std::endl;
 			max_lag = dtime;
 		}
 		m_env->reportMaxLagEstimate(max_lag);
+		g_profiler->add("Server: dtime max_lag", max_lag);
+		g_profiler->add("Server: dtime", dtime);
 		// Step environment
-		ScopeProfiler sp(g_profiler, "SEnv step");
-		ScopeProfiler sp2(g_profiler, "SEnv step avg", SPT_AVG);
-		m_env->step(dtime);
+		//ScopeProfiler sp(g_profiler, "SEnv step");
+		if (!m_more_threads)
+		m_env->step(dtime, m_uptime.get(), max_cycle_ms);
 	}
 
+/*
 	static const float map_timer_and_unload_dtime = 2.92;
 	if(m_map_timer_and_unload_interval.step(dtime, map_timer_and_unload_dtime))
 	{
@@ -577,6 +730,7 @@
 			g_settings->getFloat("server_unload_unused_data_timeout"),
 			U32_MAX);
 	}
+*/
 
 	/*
 		Listen to the admin chat, if available
@@ -598,47 +752,12 @@
 		Do background stuff
 	*/
 
-	/* Transform liquids */
-	m_liquid_transform_timer += dtime;
-	if(m_liquid_transform_timer >= m_liquid_transform_every)
-	{
-		m_liquid_transform_timer -= m_liquid_transform_every;
+	if (!m_more_threads)
+		AsyncRunMapStep(dtime, dedicated_server_step, false);
 
-		MutexAutoLock lock(m_env_mutex);
-
-		ScopeProfiler sp(g_profiler, "Server: liquid transform");
-
-		std::map<v3s16, MapBlock*> modified_blocks;
-		m_env->getMap().transformLiquids(modified_blocks);
-#if 0
-		/*
-			Update lighting
-		*/
-		core::map<v3s16, MapBlock*> lighting_modified_blocks;
-		ServerMap &map = ((ServerMap&)m_env->getMap());
-		map.updateLighting(modified_blocks, lighting_modified_blocks);
-
-		// Add blocks modified by lighting to modified_blocks
-		for(core::map<v3s16, MapBlock*>::Iterator
-				i = lighting_modified_blocks.getIterator();
-				i.atEnd() == false; i++)
-		{
-			MapBlock *block = i.getNode()->getValue();
-			modified_blocks.insert(block->getPos(), block);
-		}
-#endif
-		/*
-			Set the modified blocks unsent for all the clients
-		*/
-		if(!modified_blocks.empty())
-		{
-			SetBlocksNotSent(modified_blocks);
-		}
-	}
 	m_clients.step(dtime);
 
 	m_lag += (m_lag > dtime ? -1 : 1) * dtime/100;
-#if USE_CURL
 	// send masterserver announce
 	{
 		float &counter = m_masterserver_timer;
@@ -658,23 +777,24 @@
 		}
 		counter += dtime;
 	}
-#endif
 
 	/*
 		Check added and deleted active objects
 	*/
 	{
+		TimeTaker timer_step("Server step: Check added and deleted active objects");
 		//infostream<<"Server: Checking added and deleted active objects"<<std::endl;
-		MutexAutoLock envlock(m_env_mutex);
+		//MutexAutoLock envlock(m_env_mutex);
 
-		m_clients.lock();
-		std::map<u16, RemoteClient*> clients = m_clients.getClientList();
+		auto clients = m_clients.getClientList();
 		ScopeProfiler sp(g_profiler, "Server: checking added and deleted objs");
 
 		// Radius inside which objects are active
 		static const s16 radius =
 			g_settings->getS16("active_object_send_range_blocks") * MAP_BLOCKSIZE;
 
+		static const s16 radius_deactivate = radius * 2;
+
 		// Radius inside which players are active
 		static const bool is_transfer_limited =
 			g_settings->exists("unlimited_player_transfer_distance") &&
@@ -684,11 +804,7 @@
 		if (player_radius == 0 && is_transfer_limited)
 			player_radius = radius;
 
-		for (std::map<u16, RemoteClient*>::iterator
-			i = clients.begin();
-			i != clients.end(); ++i) {
-			RemoteClient *client = i->second;
-
+		for(auto & client : clients) {
 			// If definitions and textures have not been sent, don't
 			// send objects either
 			if (client->getState() < CS_DefinitionsSent)
@@ -705,7 +821,7 @@
 
 			std::queue<u16> removed_objects;
 			std::queue<u16> added_objects;
-			m_env->getRemovedActiveObjects(player, radius, player_radius,
+			m_env->getRemovedActiveObjects(player, radius_deactivate, player_radius,
 					client->m_known_objects, removed_objects);
 			m_env->getAddedActiveObjects(player, radius, player_radius,
 					client->m_known_objects, added_objects);
@@ -715,6 +831,8 @@
 				continue;
 			}
 
+#if MINETEST_PROTO
+
 			std::string data_buffer;
 
 			char buf[4];
@@ -725,7 +843,7 @@
 			while (!removed_objects.empty()) {
 				// Get object
 				u16 id = removed_objects.front();
-				ServerActiveObject* obj = m_env->getActiveObject(id);
+				ServerActiveObject* obj = m_env->getActiveObject(id, true);
 
 				// Add to data buffer for sending
 				writeU16((u8*)buf, id);
@@ -768,7 +886,7 @@
 					data_buffer.append(serializeLongString(""));
 
 				// Add to known objects
-				client->m_known_objects.insert(id);
+				client->m_known_objects.set(id, true);
 
 				if(obj)
 					obj->m_known_by_count++;
@@ -781,15 +899,77 @@
 					<< removed_objects.size() << " removed, "
 					<< added_objects.size() << " added, "
 					<< "packet size is " << pktSize << std::endl;
+
+
+
+#else
+
+
+			std::set<u16> removed_objects_data;
+
+			// Handle removed objects
+			while (!removed_objects.empty()) {
+				// Get object
+				u16 id = removed_objects.front();
+				ServerActiveObject* obj = m_env->getActiveObject(id, true);
+
+				// Remove from known objects
+				client->m_known_objects.erase(id);
+
+				if(obj && obj->m_known_by_count > 0)
+					obj->m_known_by_count--;
+
+				removed_objects_data.insert(id);
+				removed_objects.pop();
+			}
+
+			std::vector<ActiveObjectAddData> added_objects_data;
+
+			// Handle added objects
+			while (!added_objects.empty()) {
+				// Get object
+				u16 id = added_objects.front();
+				added_objects.pop();
+
+				ServerActiveObject* obj = m_env->getActiveObject(id);
+				if(!obj) {
+					warningstream<<FUNCTION_NAME
+							<<": NULL object"<<std::endl;
+					continue;
+				}
+				// Get object type
+				u8 type = obj->getSendType();
+
+				std::string data = obj->getClientInitializationData(client->net_proto_version);
+				if (!data.size())
+					continue;
+
+				added_objects_data.push_back(ActiveObjectAddData(id, type, data));
+
+				// Add to known objects
+				client->m_known_objects.set(id, true);
+
+				obj->m_known_by_count++;
+
+			}
+
+			MSGPACK_PACKET_INIT(TOCLIENT_ACTIVE_OBJECT_REMOVE_ADD, 2);
+			PACK(TOCLIENT_ACTIVE_OBJECT_REMOVE_ADD_REMOVE, removed_objects_data);
+			PACK(TOCLIENT_ACTIVE_OBJECT_REMOVE_ADD_ADD, added_objects_data);
+
+			// Send as reliable
+			m_clients.send(client->peer_id, 0, buffer, true);
+#endif
+
 		}
-		m_clients.unlock();
 	}
 
 	/*
 		Send object messages
 	*/
 	{
-		MutexAutoLock envlock(m_env_mutex);
+		TimeTaker timer_step("Server step: Send object messages");
+		//MutexAutoLock envlock(m_env_mutex);
 		ScopeProfiler sp(g_profiler, "Server: sending object messages");
 
 		// Key = object id
@@ -815,13 +995,11 @@
 			message_list->push_back(aom);
 		}
 
-		m_clients.lock();
-		std::map<u16, RemoteClient*> clients = m_clients.getClientList();
+		auto clients = m_clients.getClientList();
 		// Route data to every client
-		for (std::map<u16, RemoteClient*>::iterator
-			i = clients.begin();
-			i != clients.end(); ++i) {
-			RemoteClient *client = i->second;
+		for (auto & client : clients) {
+
+#if MINETEST_PROTO
 			std::string reliable_data;
 			std::string unreliable_data;
 			// Go through all objects in message buffer
@@ -865,11 +1043,44 @@
 			if(unreliable_data.size() > 0) {
 				SendActiveObjectMessages(client->peer_id, unreliable_data, false);
 			}
-		}
-		m_clients.unlock();
 
+#else
+			ActiveObjectMessages reliable_data;
+			ActiveObjectMessages unreliable_data;
+			// Go through all objects in message buffer
+			for(auto
+					j = buffered_messages.begin();
+					j != buffered_messages.end(); ++j) {
+				// If object is not known by client, skip it
+				u16 id = j->first;
+				if (client->m_known_objects.find(id) == client->m_known_objects.end())
+					continue;
+				// Get message list of object
+				std::vector<ActiveObjectMessage>* list = j->second;
+				// Go through every message
+				for(auto
+						k = list->begin(); k != list->end(); ++k) {
+					// Add data to buffer
+					if(k->reliable)
+						reliable_data.push_back(make_pair(k->id, k->datastring));
+					else
+						unreliable_data.push_back(make_pair(k->id, k->datastring));
+				}
+			}
+			/*
+				reliable_data and unreliable_data are now ready.
+				Send them.
+			*/
+			if(reliable_data.size() > 0) {
+				SendActiveObjectMessages(client->peer_id, reliable_data);
+			}
+			if(unreliable_data.size() > 0) {
+				SendActiveObjectMessages(client->peer_id, unreliable_data, false);
+			}
+#endif
+		}
 		// Clear buffered_messages
-		for(std::map<u16, std::vector<ActiveObjectMessage>* >::iterator
+		for (auto
 				i = buffered_messages.begin();
 				i != buffered_messages.end(); ++i) {
 			delete i->second;
@@ -880,71 +1091,93 @@
 		Send queued-for-sending map edit events.
 	*/
 	{
+		TimeTaker timer_step("Server step: Send queued-for-sending map edit events.");
+		ScopeProfiler sp(g_profiler, "Server: Map events process");
 		// We will be accessing the environment
-		MutexAutoLock lock(m_env_mutex);
+		//MutexAutoLock lock(m_env_mutex);
 
 		// Don't send too many at a time
-		//u32 count = 0;
+		u32 count = 0;
 
 		// Single change sending is disabled if queue size is not small
 		bool disable_single_change_sending = false;
-		if(m_unsent_map_edit_queue.size() >= 4)
+		if(m_unsent_map_edit_queue.size() > 1)
 			disable_single_change_sending = true;
 
-		int event_count = m_unsent_map_edit_queue.size();
+		//int event_count = m_unsent_map_edit_queue.size();
 
 		// We'll log the amount of each
 		Profiler prof;
 
+		u32 end_ms = porting::getTimeMs() + max_cycle_ms;
+#if !ENABLE_THREADS
+		auto lock = m_env->getMap().m_nothread_locker.lock_shared_rec();
+		if (lock->owns_lock())
+#endif
 		while(m_unsent_map_edit_queue.size() != 0)
 		{
-			MapEditEvent* event = m_unsent_map_edit_queue.front();
-			m_unsent_map_edit_queue.pop();
+			auto event = std::unique_ptr<MapEditEvent>(m_unsent_map_edit_queue.pop_front());
 
 			// Players far away from the change are stored here.
 			// Instead of sending the changes, MapBlocks are set not sent
 			// for them.
 			std::vector<u16> far_players;
 
-			switch (event->type) {
-			case MEET_ADDNODE:
-			case MEET_SWAPNODE:
+			if(event->type == MEET_ADDNODE || event->type == MEET_SWAPNODE) {
+				//infostream<<"Server: MEET_ADDNODE"<<std::endl;
 				prof.add("MEET_ADDNODE", 1);
-				sendAddNode(event->p, event->n, event->already_known_by_peer,
-						&far_players, disable_single_change_sending ? 5 : 30,
-						event->type == MEET_ADDNODE);
-				break;
-			case MEET_REMOVENODE:
+				if(disable_single_change_sending)
+					sendAddNode(event->p, event->n, event->already_known_by_peer,
+							&far_players, 5, event->type == MEET_ADDNODE);
+				else
+					sendAddNode(event->p, event->n, event->already_known_by_peer,
+							&far_players, 30, event->type == MEET_ADDNODE);
+			}
+			else if(event->type == MEET_REMOVENODE) {
+				//infostream<<"Server: MEET_REMOVENODE"<<std::endl;
 				prof.add("MEET_REMOVENODE", 1);
-				sendRemoveNode(event->p, event->already_known_by_peer,
-						&far_players, disable_single_change_sending ? 5 : 30);
-				break;
-			case MEET_BLOCK_NODE_METADATA_CHANGED:
-				infostream << "Server: MEET_BLOCK_NODE_METADATA_CHANGED" << std::endl;
-						prof.add("MEET_BLOCK_NODE_METADATA_CHANGED", 1);
-						setBlockNotSent(event->p);
-				break;
-			case MEET_OTHER:
-				infostream << "Server: MEET_OTHER" << std::endl;
+				if(disable_single_change_sending)
+					sendRemoveNode(event->p, event->already_known_by_peer,
+							&far_players, 5);
+				else
+					sendRemoveNode(event->p, event->already_known_by_peer,
+							&far_players, 30);
+			}
+			else if(event->type == MEET_BLOCK_NODE_METADATA_CHANGED) {
+/*
+				infostream<<"Server: MEET_BLOCK_NODE_METADATA_CHANGED"<<std::endl;
+*/
+				prof.add("MEET_BLOCK_NODE_METADATA_CHANGED", 1);
+				setBlockNotSent(event->p);
+			}
+			else if(event->type == MEET_OTHER) {
+/*
+				infostream<<"Server: MEET_OTHER"<<std::endl;
+*/
 				prof.add("MEET_OTHER", 1);
+/*
 				for(std::set<v3s16>::iterator
 						i = event->modified_blocks.begin();
-						i != event->modified_blocks.end(); ++i) {
+						i != event->modified_blocks.end(); ++i)
+				{
 					setBlockNotSent(*i);
 				}
-				break;
-			default:
+*/
+				SetBlocksNotSent();
+			}
+			else {
 				prof.add("unknown", 1);
 				warningstream << "Server: Unknown MapEditEvent "
 						<< ((u32)event->type) << std::endl;
-				break;
+				//break;
 			}
 
 			/*
 				Set blocks not sent to far players
 			*/
-			if(!far_players.empty()) {
+			if (!far_players.empty()) {
 				// Convert list format to that wanted by SetBlocksNotSent
+/*
 				std::map<v3s16, MapBlock*> modified_blocks2;
 				for(std::set<v3s16>::iterator
 						i = event->modified_blocks.begin();
@@ -952,31 +1185,38 @@
 					modified_blocks2[*i] =
 							m_env->getMap().getBlockNoCreateNoEx(*i);
 				}
-
+*/
 				// Set blocks not sent
-				for(std::vector<u16>::iterator
+				for (auto
 						i = far_players.begin();
 						i != far_players.end(); ++i) {
-					if(RemoteClient *client = getClient(*i))
-						client->SetBlocksNotSent(modified_blocks2);
+					u16 peer_id = *i;
+					RemoteClient *client = getClient(peer_id);
+					if(client==NULL)
+						continue;
+					client->SetBlocksNotSent(/*modified_blocks2*/);
 				}
 			}
 
-			delete event;
+			//delete event;
 
+			++count;
 			/*// Don't send too many at a time
-			count++;
 			if(count >= 1 && m_unsent_map_edit_queue.size() < 100)
 				break;*/
+			if (porting::getTimeMs() > end_ms)
+				break;
 		}
 
-		if(event_count >= 5){
-			infostream<<"Server: MapEditEvents:"<<std::endl;
+/*
+		if(event_count >= 10){
+			infostream<<"Server: MapEditEvents count="<<count<<"/"<<event_count<<" :"<<std::endl;
 			prof.print(infostream);
 		} else if(event_count != 0){
-			verbosestream<<"Server: MapEditEvents:"<<std::endl;
+			verbosestream<<"Server: MapEditEvents count="<<count<<"/"<<event_count<<" :"<<std::endl;
 			prof.print(verbosestream);
 		}
+*/
 
 	}
 
@@ -984,7 +1224,10 @@
 		Trigger emergethread (it somehow gets to a non-triggered but
 		bysy state sometimes)
 	*/
+/*
+	if (!maintenance_status)
 	{
+		TimeTaker timer_step("Server step: Trigger emergethread");
 		float &counter = m_emergethread_trigger_timer;
 		counter += dtime;
 		if (counter >= 2.0) {
@@ -993,46 +1236,89 @@
 			m_emerge->startThreads();
 		}
 	}
+*/
 
-	// Save map, players and auth stuff
 	{
+		if (porting::g_sighup) {
+			porting::g_sighup = false;
+			if(!maintenance_status) {
+				maintenance_status = 1;
+				maintenance_start();
+				maintenance_status = 2;
+			} else if(maintenance_status == 2) {
+				maintenance_status = 3;
+				maintenance_end();
+				maintenance_status = 0;
+			}
+		}
+		if (porting::g_siginfo) {
+			// todo: add here more info
+			porting::g_siginfo = false;
+			infostream<<"uptime="<< (int)m_uptime.get()<<std::endl;
+			m_clients.UpdatePlayerList(); //print list
+			g_profiler->print(infostream);
+			g_profiler->clear();
+		}
+	}
+}
+
+int Server::save(float dtime, float dedicated_server_step, bool breakable) {
+	// Save map, players and auth stuff
+	int ret = 0;
 		float &counter = m_savemap_timer;
 		counter += dtime;
 		static const float save_interval =
 			g_settings->getFloat("server_map_save_interval");
 		if (counter >= save_interval) {
 			counter = 0.0;
-			MutexAutoLock lock(m_env_mutex);
+			TimeTaker timer_step("Server step: Save map, players and auth stuff");
+			//MutexAutoLock lock(m_env_mutex);
 
 			ScopeProfiler sp(g_profiler, "Server: saving stuff");
 
+			// Save changed parts of map
+			if(m_env->getMap().save(MOD_STATE_WRITE_NEEDED, dedicated_server_step, breakable)) {
+				// partial save, will continue on next step
+				counter = g_settings->getFloat("server_map_save_interval");
+				++ret;
+				if (breakable)
+					goto save_break;
+			}
+
 			// Save ban file
 			if (m_banmanager->isModified()) {
 				m_banmanager->save();
 			}
 
-			// Save changed parts of map
-			m_env->getMap().save(MOD_STATE_WRITE_NEEDED);
-
 			// Save players
 			m_env->saveLoadedPlayers();
 
 			// Save environment metadata
 			m_env->saveMeta();
+
+			stat.save();
 		}
-	}
+		save_break:;
+
+	return ret;
 }
 
-void Server::Receive()
+u16 Server::Receive(int ms)
 {
 	DSTACK(FUNCTION_NAME);
 	SharedBuffer<u8> data;
-	u16 peer_id;
+	u16 peer_id = 0;
+	u16 received = 0;
 	try {
+		TimeTaker timer_step("Server recieve one packet");
+
 		NetworkPacket pkt;
-		m_con.Receive(&pkt);
+		auto size = m_con.Receive(&pkt, ms);
 		peer_id = pkt.getPeerId();
-		ProcessData(&pkt);
+		if (size) {
+			ProcessData(&pkt);
+			++received;
+		}
 	}
 	catch(con::InvalidIncomingDataException &e) {
 		infostream<<"Server::Receive(): "
@@ -1051,28 +1337,30 @@
 	}
 	catch(con::PeerNotFoundException &e) {
 		// Do nothing
+	} catch (ClientNotFoundException &e) {
+		//verbosestream<<"Server: recieve: clientnotfound:"<< e.what() <<std::endl;
+	} catch (msgpack::v1::type_error &e) {
+		verbosestream<<"Server: recieve: msgpack:"<< e.what() <<std::endl;
+	} catch (std::exception &e) {
+#if !MINETEST_PROTO
+		infostream<<"Server: recieve: exception:"<< e.what() <<std::endl;
+#endif
 	}
+	return received;
 }
 
 PlayerSAO* Server::StageTwoClientInit(u16 peer_id)
 {
 	std::string playername = "";
 	PlayerSAO *playersao = NULL;
-	m_clients.lock();
-	try {
 		RemoteClient* client = m_clients.lockedGetClientNoEx(peer_id, CS_InitDone);
 		if (client != NULL) {
 			playername = client->getName();
 			playersao = emergePlayer(playername.c_str(), peer_id, client->net_proto_version);
 		}
-	} catch (std::exception &e) {
-		m_clients.unlock();
-		throw;
-	}
-	m_clients.unlock();
 
 	RemotePlayer *player =
-		static_cast<RemotePlayer*>(m_env->getPlayer(playername.c_str()));
+		static_cast<RemotePlayer*>(m_env->getPlayer(playername));
 
 	// If failed, cancel
 	if ((playersao == NULL) || (player == NULL)) {
@@ -1119,16 +1407,20 @@
 		// Send information about server to player in chat
 		SendChatMessage(peer_id, getStatusString());
 	}
+
+/*
 	Address addr = getPeerAddress(player->peer_id);
 	std::string ip_str = addr.serializeString();
 	actionstream<<player->getName() <<" [" << ip_str << "] joins game. " << std::endl;
+*/
 	/*
 		Print out action
 	*/
 	{
 		std::vector<std::string> names = m_clients.getPlayerNames();
 
-		actionstream<<player->getName() <<" joins game. List of players: ";
+		actionstream<<player->getName() << " ["<<getPeerAddress(peer_id).serializeString()<<"]"<<
+		" joins game. List of players: ";
 
 		for (std::vector<std::string>::iterator i = names.begin();
 				i != names.end(); ++i) {
@@ -1150,7 +1442,7 @@
 {
 	DSTACK(FUNCTION_NAME);
 	// Environment is locked first.
-	MutexAutoLock envlock(m_env_mutex);
+	//MutexAutoLock envlock(m_env_mutex);
 
 	ScopeProfiler sp(g_profiler, "Server::ProcessData");
 	u32 peer_id = pkt->getPeerId();
@@ -1183,6 +1475,11 @@
 	}
 
 	try {
+#if !MINETEST_PROTO
+		if (!pkt->packet_unpack())
+			return;
+#endif
+
 		ToServerCommand command = (ToServerCommand) pkt->getCommand();
 
 		// Command must be handled into ToServerCommandHandler
@@ -1192,6 +1489,16 @@
 			return;
 		}
 
+		if (overload) {
+			if (command == TOSERVER_PLAYERPOS || command == TOSERVER_DRAWCONTROL)
+				return;
+			if (overload > 2000 && command == TOSERVER_BREATH)
+				return;
+			if (overload > 30000 && command == TOSERVER_INTERACT) // FMTODO queue here for post-process
+				return;
+			//errorstream << "overload cmd=" << command << " n="<< toServerCommandTable[command].name << "\n";
+		}
+
 		if (toServerCommandTable[command].state == TOSERVER_STATE_NOT_CONNECTED) {
 			handleCommand(pkt);
 			return;
@@ -1241,10 +1548,13 @@
 
 void Server::onMapEditEvent(MapEditEvent *event)
 {
+	//infostream<<"Server::onMapEditEvent()"<<std::endl;
 	if(m_ignore_map_edit_events)
 		return;
+/* thread unsafe
 	if(m_ignore_map_edit_events_area.contains(event->getArea()))
 		return;
+*/
 	MapEditEvent *e = event->clone();
 	m_unsent_map_edit_queue.push(e);
 }
@@ -1282,7 +1592,6 @@
 	}
 		break;
 	default:
-		sanity_check(false); // abort
 		break;
 	}
 	return NULL;
@@ -1306,65 +1615,68 @@
 
 		SendInventory(playersao);
 	}
-		break;
+	break;
 	case InventoryLocation::NODEMETA:
 	{
 		v3s16 blockpos = getNodeBlockPos(loc.p);
 
-		MapBlock *block = m_env->getMap().getBlockNoCreateNoEx(blockpos);
+		MapBlock *block = m_env->getMap().getBlockNoCreateNoEx(blockpos, false, true);
 		if(block)
-			block->raiseModified(MOD_STATE_WRITE_NEEDED);
+			block->raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_REPORT_META_CHANGE);
 
 		setBlockNotSent(blockpos);
 	}
-		break;
+	break;
 	case InventoryLocation::DETACHED:
 	{
 		sendDetachedInventory(loc.name,PEER_ID_INEXISTENT);
 	}
-		break;
+	break;
 	default:
-		sanity_check(false); // abort
 		break;
 	}
 }
 
 void Server::SetBlocksNotSent(std::map<v3s16, MapBlock *>& block)
 {
+	SetBlocksNotSent();
+}
+
+void Server::SetBlocksNotSent()
+{
 	std::vector<u16> clients = m_clients.getClientIDs();
-	m_clients.lock();
 	// Set the modified blocks unsent for all the clients
-	for (std::vector<u16>::iterator i = clients.begin();
+	for (auto
+		 i = clients.begin();
 		 i != clients.end(); ++i) {
 			if (RemoteClient *client = m_clients.lockedGetClientNoEx(*i))
-				client->SetBlocksNotSent(block);
+				client->SetBlocksNotSent();
 	}
-	m_clients.unlock();
 }
 
-void Server::peerAdded(con::Peer *peer)
+void Server::peerAdded(u16 peer_id)
 {
 	DSTACK(FUNCTION_NAME);
 	verbosestream<<"Server::peerAdded(): peer->id="
-			<<peer->id<<std::endl;
+			<<peer_id<<std::endl;
 
 	con::PeerChange c;
 	c.type = con::PEER_ADDED;
-	c.peer_id = peer->id;
+	c.peer_id = peer_id;
 	c.timeout = false;
 	m_peer_change_queue.push(c);
 }
 
-void Server::deletingPeer(con::Peer *peer, bool timeout)
+void Server::deletingPeer(u16 peer_id, bool timeout)
 {
 	DSTACK(FUNCTION_NAME);
 	verbosestream<<"Server::deletingPeer(): peer->id="
-			<<peer->id<<", timeout="<<timeout<<std::endl;
+			<<peer_id<<", timeout="<<timeout<<std::endl;
 
-	m_clients.event(peer->id, CSE_Disconnect);
+	m_clients.event(peer_id, CSE_Disconnect);
 	con::PeerChange c;
 	c.type = con::PEER_REMOVED;
-	c.peer_id = peer->id;
+	c.peer_id = peer_id;
 	c.timeout = timeout;
 	m_peer_change_queue.push(c);
 }
@@ -1389,11 +1701,9 @@
 	)
 {
 	*state = m_clients.getClientState(peer_id);
-	m_clients.lock();
 	RemoteClient* client = m_clients.lockedGetClientNoEx(peer_id, CS_Invalid);
 
 	if (client == NULL) {
-		m_clients.unlock();
 		return false;
 	}
 
@@ -1406,8 +1716,6 @@
 	*patch = client->getPatch();
 	*vers_string = client->getPatch();
 
-	m_clients.unlock();
-
 	return true;
 }
 
@@ -1415,8 +1723,7 @@
 {
 	while(m_peer_change_queue.size() > 0)
 	{
-		con::PeerChange c = m_peer_change_queue.front();
-		m_peer_change_queue.pop();
+		con::PeerChange c = m_peer_change_queue.pop_front();
 
 		verbosestream<<"Server: Handling peer change: "
 				<<"id="<<c.peer_id<<", timeout="<<c.timeout
@@ -1424,17 +1731,17 @@
 
 		switch(c.type)
 		{
-		case con::PEER_ADDED:
-			m_clients.CreateClient(c.peer_id);
-			break;
+			case con::PEER_ADDED:
+				m_clients.CreateClient(c.peer_id);
+				break;
 
-		case con::PEER_REMOVED:
-			DeleteClient(c.peer_id, c.timeout?CDR_TIMEOUT:CDR_LEAVE);
-			break;
+			case con::PEER_REMOVED:
+				DeleteClient(c.peer_id, c.timeout?CDR_TIMEOUT:CDR_LEAVE);
+				break;
 
-		default:
-			FATAL_ERROR("Invalid peer change event received!");
-			break;
+			default:
+				assert("Invalid peer change event received!" == 0);
+				break;
 		}
 	}
 }
@@ -1449,8 +1756,10 @@
 	}
 }
 
+#if MINETEST_PROTO
 void Server::Send(NetworkPacket* pkt)
 {
+	g_profiler->add("Server: Packets sended", 1);
 	m_clients.send(pkt->getPeerId(),
 		clientCommandFactoryTable[pkt->getCommand()].channel,
 		pkt,
@@ -1479,6 +1788,7 @@
 
 	Send(&pkt);
 }
+#endif
 
 void Server::SendPlayerHPOrDie(PlayerSAO *playersao)
 {
@@ -1494,6 +1804,8 @@
 		DiePlayer(peer_id);
 }
 
+
+#if MINETEST_PROTO
 void Server::SendHP(u16 peer_id, u8 hp)
 {
 	DSTACK(FUNCTION_NAME);
@@ -1515,24 +1827,25 @@
 void Server::SendAccessDenied(u16 peer_id, AccessDeniedCode reason,
 		const std::string &custom_reason, bool reconnect)
 {
-	assert(reason < SERVER_ACCESSDENIED_MAX);
+	if (reason >= SERVER_ACCESSDENIED_MAX)
+		return;
 
 	NetworkPacket pkt(TOCLIENT_ACCESS_DENIED, 1, peer_id);
 	pkt << (u8)reason;
 	if (reason == SERVER_ACCESSDENIED_CUSTOM_STRING)
-		pkt << custom_reason;
+		pkt << narrow_to_wide(custom_reason);
 	else if (reason == SERVER_ACCESSDENIED_SHUTDOWN ||
 			reason == SERVER_ACCESSDENIED_CRASH)
-		pkt << custom_reason << (u8)reconnect;
+		pkt << narrow_to_wide(custom_reason) << (u8)reconnect;
 	Send(&pkt);
 }
 
-void Server::SendAccessDenied_Legacy(u16 peer_id,const std::wstring &reason)
+void Server::SendAccessDenied_Legacy(u16 peer_id,const std::string &reason)
 {
 	DSTACK(FUNCTION_NAME);
 
 	NetworkPacket pkt(TOCLIENT_ACCESS_DENIED_LEGACY, 0, peer_id);
-	pkt << reason;
+	pkt << narrow_to_wide(reason);
 	Send(&pkt);
 }
 
@@ -1622,12 +1935,12 @@
 	Send(&pkt);
 }
 
-void Server::SendChatMessage(u16 peer_id, const std::wstring &message)
+void Server::SendChatMessage(u16 peer_id, const std::string &message)
 {
 	DSTACK(FUNCTION_NAME);
 
 	NetworkPacket pkt(TOCLIENT_CHAT_MESSAGE, 0, peer_id);
-	pkt << message;
+	pkt << narrow_to_wide(message);
 
 	if (peer_id != PEER_ID_INEXISTENT) {
 		Send(&pkt);
@@ -2110,18 +2423,26 @@
 	}
 }
 
+#endif
+
+void Server::SendChatMessage(u16 peer_id, const std::wstring &message) {
+	SendChatMessage(peer_id, wide_to_narrow(message));
+}
+
 void Server::setBlockNotSent(v3s16 p)
 {
-	std::vector<u16> clients = m_clients.getClientIDs();
-	m_clients.lock();
-	for(std::vector<u16>::iterator i = clients.begin();
-		i != clients.end(); ++i) {
+	auto clients = m_clients.getClientIDs();
+	for(auto
+		i = clients.begin();
+		i != clients.end(); ++i)
+	{
 		RemoteClient *client = m_clients.lockedGetClientNoEx(*i);
-		client->SetBlockNotSent(p);
+		client->SetBlocksNotSent();
 	}
-	m_clients.unlock();
 }
 
+#if MINETEST_PROTO
+
 void Server::SendBlockNoLock(u16 peer_id, MapBlock *block, u8 ver, u16 net_proto_version)
 {
 	DSTACK(FUNCTION_NAME);
@@ -2144,36 +2465,38 @@
 	Send(&pkt);
 }
 
-void Server::SendBlocks(float dtime)
+#endif
+
+int Server::SendBlocks(float dtime)
 {
+	//TimeTaker timer("SendBlocks inside");
 	DSTACK(FUNCTION_NAME);
 
-	MutexAutoLock envlock(m_env_mutex);
+	//MutexAutoLock envlock(m_env_mutex);
 	//TODO check if one big lock could be faster then multiple small ones
 
-	ScopeProfiler sp(g_profiler, "Server: sel and send blocks to clients");
+	//ScopeProfiler sp(g_profiler, "Server: sel and send blocks to clients");
 
-	std::vector<PrioritySortedBlockTransfer> queue;
+	int total = 0;
 
-	s32 total_sending = 0;
+	std::vector<PrioritySortedBlockTransfer> queue;
 
 	{
-		ScopeProfiler sp(g_profiler, "Server: selecting blocks for sending");
+		//ScopeProfiler sp(g_profiler, "Server: selecting blocks for sending");
 
 		std::vector<u16> clients = m_clients.getClientIDs();
 
-		m_clients.lock();
-		for(std::vector<u16>::iterator i = clients.begin();
-			i != clients.end(); ++i) {
-			RemoteClient *client = m_clients.lockedGetClientNoEx(*i, CS_Active);
+		for(auto
+			i = clients.begin();
+			i != clients.end(); ++i)
+		{
+			auto client = m_clients.getClient(*i, CS_Active);
 
 			if (client == NULL)
 				continue;
 
-			total_sending += client->SendingCount();
-			client->GetNextBlocks(m_env,m_emerge, dtime, queue);
+			total += client->GetNextBlocks(m_env, m_emerge, dtime, m_uptime.get() + m_env->m_game_time_start, queue);
 		}
-		m_clients.unlock();
 	}
 
 	// Sort.
@@ -2181,19 +2504,18 @@
 	// Lowest is most important.
 	std::sort(queue.begin(), queue.end());
 
-	m_clients.lock();
 	for(u32 i=0; i<queue.size(); i++)
 	{
 		//TODO: Calculate limit dynamically
-		if(total_sending >= g_settings->getS32
-				("max_simultaneous_block_sends_server_total"))
-			break;
 
 		PrioritySortedBlockTransfer q = queue[i];
 
 		MapBlock *block = NULL;
 		try
 		{
+#if !ENABLE_THREADS
+			auto lock = m_env->getServerMap().m_nothread_locker.lock_shared_rec();
+#endif
 			block = m_env->getMap().getBlockNoCreate(q.pos);
 		}
 		catch(InvalidPositionException &e)
@@ -2206,12 +2528,19 @@
 		if(!client)
 			continue;
 
+		{
+		auto lock = block->try_lock_shared_rec();
+		if (!lock->owns_lock())
+			continue;
+
+		// maybe sometimes blocks will not load (must wait 1+ minute), but reduce network load: q.priority<=4
 		SendBlockNoLock(q.peer_id, block, client->serialization_version, client->net_proto_version);
+		}
 
-		client->SentBlock(q.pos);
-		total_sending++;
+		client->SentBlock(q.pos, m_uptime.get() + m_env->m_game_time_start);
+		++total;
 	}
-	m_clients.unlock();
+	return total;
 }
 
 void Server::fillMediaCache()
@@ -2221,7 +2550,7 @@
 	infostream<<"Server: Calculating media file checksums"<<std::endl;
 
 	// Collect all media file paths
-	std::vector<std::string> paths;
+	std::list<std::string> paths;
 	for(std::vector<ModSpec>::iterator i = m_mods.begin();
 			i != m_mods.end(); ++i) {
 		const ModSpec &mod = *i;
@@ -2232,9 +2561,11 @@
 	}
 	paths.push_back(porting::path_user + DIR_DELIM + "textures" + DIR_DELIM + "server");
 
+	unsigned int size_total = 0, files_total = 0;
 	// Collect media file information from paths into cache
-	for(std::vector<std::string>::iterator i = paths.begin();
-			i != paths.end(); ++i) {
+	for(auto i = paths.begin();
+			i != paths.end(); ++i)
+	{
 		std::string mediapath = *i;
 		std::vector<fs::DirListNode> dirlist = fs::GetDirListing(mediapath);
 		for (u32 j = 0; j < dirlist.size(); j++) {
@@ -2244,7 +2575,7 @@
 			// If name contains illegal characters, ignore the file
 			if (!string_allowed(filename, TEXTURENAME_ALLOWED_CHARS)) {
 				infostream<<"Server: ignoring illegal file name: \""
-						<< filename << "\"" << std::endl;
+						<<filename<<"\""<<std::endl;
 				continue;
 			}
 			// If name is not in a supported format, ignore it
@@ -2255,9 +2586,9 @@
 				".x", ".b3d", ".md2", ".obj",
 				NULL
 			};
-			if (removeStringEnd(filename, supported_ext) == ""){
-				infostream << "Server: ignoring unsupported file extension: \""
-						<< filename << "\"" << std::endl;
+			if (removeStringEnd(filename, supported_ext) == "") {
+				infostream<<"Server: ignoring unsupported file extension: \""
+						<<filename<<"\""<<std::endl;
 				continue;
 			}
 			// Ok, attempt to load the file and add to cache
@@ -2265,13 +2596,13 @@
 			// Read data
 			std::ifstream fis(filepath.c_str(), std::ios_base::binary);
 			if (!fis.good()) {
-				errorstream << "Server::fillMediaCache(): Could not open \""
-						<< filename << "\" for reading" << std::endl;
+				errorstream<<"Server::fillMediaCache(): Could not open \""
+						<<filename<<"\" for reading"<<std::endl;
 				continue;
 			}
 			std::ostringstream tmp_os(std::ios_base::binary);
 			bool bad = false;
-			for(;;) {
+			for (;;) {
 				char buf[1024];
 				fis.read(buf, 1024);
 				std::streamsize len = fis.gcount();
@@ -2283,16 +2614,18 @@
 					break;
 				}
 			}
-			if(bad) {
+			if (bad) {
 				errorstream<<"Server::fillMediaCache(): Failed to read \""
-						<< filename << "\"" << std::endl;
+						<<filename<<"\""<<std::endl;
 				continue;
 			}
-			if(tmp_os.str().length() == 0) {
-				errorstream << "Server::fillMediaCache(): Empty file \""
-						<< filepath << "\"" << std::endl;
+			if (tmp_os.str().length() == 0) {
+				errorstream<<"Server::fillMediaCache(): Empty file \""
+						<<filepath<<"\""<<std::endl;
 				continue;
 			}
+			size_total += tmp_os.str().length();
+			++files_total;
 
 			SHA1 sha1;
 			sha1.addBytes(tmp_os.str().c_str(), tmp_os.str().length());
@@ -2303,13 +2636,16 @@
 			free(digest);
 
 			// Put in list
-			m_media[filename] = MediaInfo(filepath, sha1_base64);
-			verbosestream << "Server: " << sha1_hex << " is " << filename
-					<< std::endl;
+			this->m_media[filename] = MediaInfo(filepath, sha1_base64);
+			verbosestream<<"Server: "<<sha1_hex<<" is "<<filename<<std::endl;
 		}
 	}
+	actionstream << "Serving " << files_total <<" files, " << size_total << " bytes" << std::endl;
 }
 
+
+#if MINETEST_PROTO
+
 void Server::sendMediaAnnouncement(u16 peer_id)
 {
 	DSTACK(FUNCTION_NAME);
@@ -2332,6 +2668,8 @@
 	Send(&pkt);
 }
 
+#endif
+
 struct SendableMedia
 {
 	std::string name;
@@ -2346,6 +2684,8 @@
 	{}
 };
 
+#if MINETEST_PROTO
+
 void Server::sendRequestedMedia(u16 peer_id,
 		const std::vector<std::string> &tosend)
 {
@@ -2364,11 +2704,11 @@
 
 	u32 file_size_bunch_total = 0;
 
-	for(std::vector<std::string>::const_iterator i = tosend.begin();
+	for (std::vector<std::string>::const_iterator i = tosend.begin();
 			i != tosend.end(); ++i) {
 		const std::string &name = *i;
 
-		if(m_media.find(name) == m_media.end()) {
+		if (m_media.find(name) == m_media.end()) {
 			errorstream<<"Server::sendRequestedMedia(): Client asked for "
 					<<"unknown file \""<<(name)<<"\""<<std::endl;
 			continue;
@@ -2379,27 +2719,27 @@
 
 		// Read data
 		std::ifstream fis(tpath.c_str(), std::ios_base::binary);
-		if(fis.good() == false){
+		if (!fis.good()) {
 			errorstream<<"Server::sendRequestedMedia(): Could not open \""
 					<<tpath<<"\" for reading"<<std::endl;
 			continue;
 		}
 		std::ostringstream tmp_os(std::ios_base::binary);
 		bool bad = false;
-		for(;;) {
+		for (;;) {
 			char buf[1024];
 			fis.read(buf, 1024);
 			std::streamsize len = fis.gcount();
 			tmp_os.write(buf, len);
 			file_size_bunch_total += len;
-			if(fis.eof())
+			if (fis.eof())
 				break;
-			if(!fis.good()) {
+			if (!fis.good()) {
 				bad = true;
 				break;
 			}
 		}
-		if(bad) {
+		if (bad) {
 			errorstream<<"Server::sendRequestedMedia(): Failed to read \""
 					<<name<<"\""<<std::endl;
 			continue;
@@ -2411,7 +2751,7 @@
 				SendableMedia(name, tpath, tmp_os.str()));
 
 		// Start next bunch if got enough data
-		if(file_size_bunch_total >= bytes_per_bunch) {
+		if (file_size_bunch_total >= bytes_per_bunch) {
 			file_bunches.push_back(std::vector<SendableMedia>());
 			file_size_bunch_total = 0;
 		}
@@ -2421,7 +2761,7 @@
 	/* Create and send packets */
 
 	u16 num_bunches = file_bunches.size();
-	for(u16 i = 0; i < num_bunches; i++) {
+	for (u16 i = 0; i < num_bunches; i++) {
 		/*
 			u16 command
 			u16 total number of texture bunches
@@ -2438,7 +2778,7 @@
 		NetworkPacket pkt(TOCLIENT_MEDIA, 4 + 0, peer_id);
 		pkt << num_bunches << i << (u32) file_bunches[i].size();
 
-		for(std::vector<SendableMedia>::iterator
+		for (std::vector<SendableMedia>::iterator
 				j = file_bunches[i].begin();
 				j != file_bunches[i].end(); ++j) {
 			pkt << j->name;
@@ -2479,6 +2819,8 @@
 	}
 }
 
+#endif
+
 void Server::sendDetachedInventories(u16 peer_id)
 {
 	DSTACK(FUNCTION_NAME);
@@ -2500,13 +2842,20 @@
 {
 	DSTACK(FUNCTION_NAME);
 	PlayerSAO *playersao = getPlayerSAO(peer_id);
+
 	// In some rare cases this can be NULL -- if the player is disconnected
 	// when a Lua function modifies l_punch, for example
 	if (!playersao)
 		return;
 
+	playersao->m_ms_from_last_respawn = 0;
+
+	auto player = playersao->getPlayer();
+	if (!player)
+		return;
+
 	infostream << "Server::DiePlayer(): Player "
-			<< playersao->getPlayer()->getName()
+			<< player->getName()
 			<< " dies" << std::endl;
 
 	playersao->setHP(0);
@@ -2516,6 +2865,8 @@
 
 	SendPlayerHP(peer_id);
 	SendDeathscreen(peer_id, false, v3f(0,0,0));
+
+	stat.add("die", player->getName());
 }
 
 void Server::RespawnPlayer(u16 peer_id)
@@ -2523,7 +2874,8 @@
 	DSTACK(FUNCTION_NAME);
 
 	PlayerSAO *playersao = getPlayerSAO(peer_id);
-	assert(playersao);
+	if (!playersao)
+		return;
 
 	infostream << "Server::RespawnPlayer(): Player "
 			<< playersao->getPlayer()->getName()
@@ -2539,11 +2891,17 @@
 	if(!repositioned){
 		v3f pos = findSpawnPos();
 		// setPos will send the new position to client
+		playersao->getPlayer()->setSpeed(v3f(0,0,0));
 		playersao->setPos(pos);
 	}
+
+	playersao->m_ms_from_last_respawn = 0;
+
+	stat.add("respawn", playersao->getPlayer()->getName());
 }
 
 
+#if MINETEST_PROTO
 void Server::DenySudoAccess(u16 peer_id)
 {
 	DSTACK(FUNCTION_NAME);
@@ -2551,6 +2909,7 @@
 	NetworkPacket pkt(TOCLIENT_DENY_SUDO_MODE, 0, peer_id);
 	Send(&pkt);
 }
+#endif
 
 
 void Server::DenyAccessVerCompliant(u16 peer_id, u16 proto_ver, AccessDeniedCode reason,
@@ -2559,10 +2918,12 @@
 	if (proto_ver >= 25) {
 		SendAccessDenied(peer_id, reason, str_reason, reconnect);
 	} else {
-		std::wstring wreason = utf8_to_wide(
+		std::string wreason = (
 			reason == SERVER_ACCESSDENIED_CUSTOM_STRING ? str_reason :
 			accessDeniedStrings[(u8)reason]);
+#if MINETEST_PROTO
 		SendAccessDenied_Legacy(peer_id, wreason);
+#endif
 	}
 
 	m_clients.event(peer_id, CSE_SetDenied);
@@ -2579,17 +2940,19 @@
 	m_con.DisconnectPeer(peer_id);
 }
 
-// 13/03/15: remove this function when protocol version 25 will become
-// the minimum version for MT users, maybe in 1 year
-void Server::DenyAccess_Legacy(u16 peer_id, const std::wstring &reason)
+//fmtodo: remove:
+void Server::DenyAccess(u16 peer_id, const std::string &custom_reason)
 {
-	DSTACK(FUNCTION_NAME);
+    DenyAccess(peer_id, SERVER_ACCESSDENIED_CUSTOM_STRING, custom_reason);
+}
 
-	SendAccessDenied_Legacy(peer_id, reason);
-	m_clients.event(peer_id, CSE_SetDenied);
-	m_con.DisconnectPeer(peer_id);
+//fmtodo: remove:
+void Server::DenyAccess_Legacy(u16 peer_id, const std::wstring &custom_reason)
+{
+    DenyAccess(peer_id, SERVER_ACCESSDENIED_CUSTOM_STRING, wide_to_narrow(custom_reason));
 }
 
+#if MINETEST_PROTO
 void Server::acceptAuth(u16 peer_id, bool forSudoMode)
 {
 	DSTACK(FUNCTION_NAME);
@@ -2620,11 +2983,12 @@
 		m_clients.event(peer_id, CSE_SudoSuccess);
 	}
 }
+#endif
 
 void Server::DeleteClient(u16 peer_id, ClientDeletionReason reason)
 {
 	DSTACK(FUNCTION_NAME);
-	std::wstring message;
+	std::string message;
 	{
 		/*
 			Clear references to playing sounds
@@ -2664,13 +3028,14 @@
 				std::ostringstream os(std::ios_base::binary);
 				std::vector<u16> clients = m_clients.getClientIDs();
 
-				for(std::vector<u16>::iterator i = clients.begin();
-					i != clients.end(); ++i) {
+				for(auto
+					i = clients.begin();
+					i != clients.end(); ++i)
+				{
 					// Get player
 					Player *player = m_env->getPlayer(*i);
 					if(!player)
 						continue;
-
 					// Get name of player
 					os << player->getName() << " ";
 				}
@@ -2685,7 +3050,7 @@
 			}
 		}
 		{
-			MutexAutoLock env_lock(m_env_mutex);
+			//MutexAutoLock env_lock(m_env_mutex);
 			m_clients.DeleteClient(peer_id);
 		}
 	}
@@ -2709,8 +3074,8 @@
 
 	// Put the new preview in
 	InventoryList *plist = player->inventory.getList("craftpreview");
-	sanity_check(plist);
-	sanity_check(plist->getSize() >= 1);
+	assert(plist);
+	assert(plist->getSize() >= 1);
 	plist->changeItem(0, preview);
 }
 
@@ -2839,40 +3204,41 @@
 	return player->getPlayerSAO();
 }
 
-std::wstring Server::getStatusString()
+std::string Server::getStatusString()
 {
-	std::wostringstream os(std::ios_base::binary);
-	os<<L"# Server: ";
+	std::ostringstream os(std::ios_base::binary);
+	os<<"# Server: ";
 	// Version
-	os<<L"version="<<narrow_to_wide(g_version_string);
+	os<<"version="<<(g_version_string);
 	// Uptime
-	os<<L", uptime="<<m_uptime.get();
+	os<<", uptime="<<m_uptime.get();
 	// Max lag estimate
-	os<<L", max_lag="<<m_env->getMaxLagEstimate();
+	os<<", max_lag="<<m_env->getMaxLagEstimate();
 	// Information about clients
 	bool first = true;
-	os<<L", clients={";
+	os<<", clients={";
 	std::vector<u16> clients = m_clients.getClientIDs();
-	for(std::vector<u16>::iterator i = clients.begin();
-		i != clients.end(); ++i) {
+	for(auto i = clients.begin();
+		i != clients.end(); ++i)
+	{
 		// Get player
 		Player *player = m_env->getPlayer(*i);
 		// Get name of player
-		std::wstring name = L"unknown";
+		std::string name = "unknown";
 		if(player != NULL)
-			name = narrow_to_wide(player->getName());
+			name = player->getName();
 		// Add name to information string
 		if(!first)
-			os << L", ";
+			os<<", ";
 		else
 			first = false;
-		os << name;
+		os<<name;
 	}
-	os << L"}";
+	os<<"}";
 	if(((ServerMap*)(&m_env->getMap()))->isSavingEnabled() == false)
-		os<<std::endl<<L"# Server: "<<" WARNING: Map saving is disabled.";
+		os<<std::endl<<"# Server: "<<" WARNING: Map saving is disabled.";
 	if(g_settings->get("motd") != "")
-		os<<std::endl<<L"# Server: "<<narrow_to_wide(g_settings->get("motd"));
+		os<<std::endl<<"# Server: "<<g_settings->get("motd");
 	return os.str();
 }
 
@@ -2891,10 +3257,11 @@
 
 void Server::reportPrivsModified(const std::string &name)
 {
-	if(name == "") {
+	if(name == ""){
 		std::vector<u16> clients = m_clients.getClientIDs();
-		for(std::vector<u16>::iterator i = clients.begin();
-				i != clients.end(); ++i) {
+		for(auto
+				i = clients.begin();
+				i != clients.end(); ++i){
 			Player *player = m_env->getPlayer(*i);
 			reportPrivsModified(player->getName());
 		}
@@ -2935,14 +3302,14 @@
 	return m_banmanager->getBanDescription(ip_or_name);
 }
 
-void Server::notifyPlayer(const char *name, const std::wstring &msg)
+void Server::notifyPlayer(const char *name, const std::string &msg)
 {
 	// m_env will be NULL if the server is initializing
 	if (!m_env)
 		return;
 
 	if (m_admin_nick == name && !m_admin_nick.empty()) {
-		m_admin_chat->outgoing_queue.push_back(new ChatEventChat("", msg));
+		m_admin_chat->outgoing_queue.push_back(new ChatEventChat("", utf8_to_wide(msg)));
 	}
 
 	Player *player = m_env->getPlayer(name);
@@ -2953,6 +3320,7 @@
 	if (player->peer_id == PEER_ID_INEXISTENT)
 		return;
 
+	//fmold: SendChatMessage(player->peer_id, std::string("\v#ffffff") + msg);
 	SendChatMessage(player->peer_id, msg);
 }
 
@@ -3046,13 +3414,14 @@
 	return player->getHotbarItemcount();
 }
 
-void Server::hudSetHotbarImage(Player *player, std::string name)
+void Server::hudSetHotbarImage(Player *player, std::string name, int items)
 {
 	if (!player)
 		return;
 
 	player->setHotbarImage(name);
 	SendHUDSetParam(player->peer_id, HUD_PARAM_HOTBAR_IMAGE, name);
+	SendHUDSetParam(player->peer_id, HUD_PARAM_HOTBAR_IMAGE_ITEMS, std::string() + std::to_string(items));
 }
 
 std::string Server::hudGetHotbarImage(Player *player)
@@ -3123,7 +3492,7 @@
 	return true;
 }
 
-void Server::notifyPlayers(const std::wstring &msg)
+void Server::notifyPlayers(const std::string &msg)
 {
 	SendChatMessage(PEER_ID_INEXISTENT,msg);
 }
@@ -3212,7 +3581,7 @@
 		infostream<<"Server creating detached inventory \""<<name<<"\""<<std::endl;
 	}
 	Inventory *inv = new Inventory(m_itemdef);
-	sanity_check(inv);
+	assert(inv);
 	m_detached_inventories[name] = inv;
 	//TODO find a better way to do this
 	sendDetachedInventory(name,PEER_ID_INEXISTENT);
@@ -3356,6 +3725,12 @@
 		return nodeposf * BS;
 	}
 
+//todo: remove
+	s16 water_level = map.getWaterLevel();
+	s16 vertical_spawn_range = g_settings->getS16("vertical_spawn_range");
+//============
+	auto cache_block_before_spawn = g_settings->getBool("cache_block_before_spawn");
+
 	bool is_good = false;
 
 	// Try to find a good place a few times
@@ -3366,11 +3741,20 @@
 				-range + (myrand() % (range * 2)),
 				-range + (myrand() % (range * 2)));
 
+// FM version:
+		// Get ground height at point
+		s16 spawn_level = map.findGroundLevel(nodepos2d, cache_block_before_spawn);
+		// Don't go underwater or to high places
+		if (spawn_level <= water_level ||
+				spawn_level > water_level + vertical_spawn_range)
+
+/*MT :
 		// Get spawn level at point
 		s16 spawn_level = m_emerge->getSpawnLevelAtPoint(nodepos2d);
 		// Continue if MAX_MAP_GENERATION_LIMIT was returned by
 		// the mapgen to signify an unsuitable spawn position
 		if (spawn_level == MAX_MAP_GENERATION_LIMIT)
+*/
 			continue;
 
 		v3s16 nodepos(nodepos2d.X, spawn_level, nodepos2d.Y);
@@ -3378,7 +3762,7 @@
 		s32 air_count = 0;
 		for (s32 i = 0; i < 10; i++) {
 			v3s16 blockpos = getNodeBlockPos(nodepos);
-			map.emergeBlock(blockpos, true);
+			map.emergeBlock(blockpos, false);
 			content_t c = map.getNodeNoEx(nodepos).getContent();
 			if (c == CONTENT_AIR || c == CONTENT_IGNORE) {
 				air_count++;
@@ -3400,12 +3784,13 @@
 
 PlayerSAO* Server::emergePlayer(const char *name, u16 peer_id, u16 proto_version)
 {
+	RemotePlayer *player = NULL;
 	bool newplayer = false;
 
 	/*
 		Try to get an existing player
 	*/
-	RemotePlayer *player = static_cast<RemotePlayer*>(m_env->getPlayer(name));
+	player = static_cast<RemotePlayer*>(m_env->getPlayer(name));
 
 	// If player is already connected, cancel
 	if(player != NULL && player->peer_id != 0)
@@ -3424,6 +3809,11 @@
 		return NULL;
 	}
 
+	if (!player && maintenance_status) {
+		infostream<<"emergePlayer(): Maintenance in progress, disallowing loading player"<<std::endl;
+		return nullptr;
+	}
+
 	// Load player if it isn't already loaded
 	if (!player) {
 		player = static_cast<RemotePlayer*>(m_env->loadPlayer(name));
@@ -3439,9 +3829,6 @@
 		v3f pos = findSpawnPos();
 		player->setPosition(pos);
 
-		// Make sure the player is saved
-		player->setModified(true);
-
 		// Add player to environment
 		m_env->addPlayer(player);
 	} else {
@@ -3481,10 +3868,10 @@
 {
 	DSTACK(FUNCTION_NAME);
 
-	verbosestream<<"dedicated_server_loop()"<<std::endl;
-
 	IntervalLimiter m_profiler_interval;
 
+	int errors = 0;
+	double run_time = 0;
 	static const float steplen = g_settings->getFloat("dedicated_server_step");
 	static const float profiler_print_interval =
 			g_settings->getFloat("profiler_print_interval");
@@ -3493,25 +3880,38 @@
 		// This is kind of a hack but can be done like this
 		// because server.step() is very light
 		{
+/*
 			ScopeProfiler sp(g_profiler, "dedicated server sleep");
+*/
 			sleep_ms((int)(steplen*1000.0));
 		}
+		try {
 		server.step(steplen);
-
+		}
+		//TODO: more errors here
+		catch(std::exception &e) {
+			if (!errors++ || !(errors % (int)(60/steplen)))
+				errorstream<<"Fatal error n="<<errors<< " : "<<e.what()<<std::endl;
+		}
+		catch (...){
+			if (!errors++ || !(errors % (int)(60/steplen)))
+				errorstream<<"Fatal error unknown "<<errors<<std::endl;
+		}
 		if(server.getShutdownRequested() || kill)
 		{
 			infostream<<"Dedicated server quitting"<<std::endl;
-#if USE_CURL
-			if(g_settings->getBool("server_announce"))
-				ServerList::sendAnnounce("delete", server.m_bind_addr.getPort());
-#endif
 			break;
 		}
 
+		run_time += steplen; // wrong not real time
+		if (server.m_autoexit && run_time > server.m_autoexit && !server.lan_adv_server.clients_num) {
+			server.requestShutdown();
+		}
+
 		/*
 			Profiler
 		*/
-		if (profiler_print_interval != 0) {
+		if (server.m_clients.getClientList().size() && profiler_print_interval) {
 			if(m_profiler_interval.step(steplen, profiler_print_interval))
 			{
 				infostream<<"Profiler:"<<std::endl;
@@ -3520,4 +3920,10 @@
 			}
 		}
 	}
+
+	if (server.m_autoexit || g_profiler_enabled) {
+		actionstream << "Profiler:" << std::fixed << std::setprecision(9) << std::endl;
+		g_profiler->print(actionstream);
+	}
+
 }
