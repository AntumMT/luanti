diff -ruN minetest-master/src/script/lua_api/l_env.cpp minetest-freeminer/src/script/lua_api/l_env.cpp
--- minetest-master/src/script/lua_api/l_env.cpp	2016-09-03 16:15:52.625779000 -0700
+++ minetest-freeminer/src/script/lua_api/l_env.cpp	2016-09-03 15:43:59.958741000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+script/lua_api/l_env.cpp
 Copyright (C) 2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "lua_api/l_env.h"
@@ -35,6 +38,7 @@
 #include "treegen.h"
 #include "emerge.h"
 #include "pathfinder.h"
+#include <unordered_set>
 
 struct EnumString ModApiEnvMod::es_ClearObjectsMode[] =
 {
@@ -45,11 +49,16 @@
 
 ///////////////////////////////////////////////////////////////////////////////
 
+v3s16 start_pos;
 
 void LuaABM::trigger(ServerEnvironment *env, v3s16 p, MapNode n,
-		u32 active_object_count, u32 active_object_count_wider)
+		u32 active_object_count, u32 active_object_count_wider, MapNode neighbor, bool activate)
 {
 	GameScripting *scriptIface = env->getScriptIface();
+	auto _script_lock = RecursiveMutexAutoLock(scriptIface->m_luastackmutex, std::try_to_lock);
+	if (!_script_lock.owns_lock()) {
+		return;
+	}
 	scriptIface->realityCheck();
 
 	lua_State *L = scriptIface->getStack();
@@ -68,7 +77,8 @@
 	lua_pushnumber(L, m_id);
 	lua_gettable(L, -2);
 	if(lua_isnil(L, -1))
-		FATAL_ERROR("");
+		//FATAL_ERROR("");
+		return;
 	lua_remove(L, -2); // Remove registered_abms
 
 	scriptIface->setOriginFromTable(-1);
@@ -82,8 +92,10 @@
 	pushnode(L, n, env->getGameDef()->ndef());
 	lua_pushnumber(L, active_object_count);
 	lua_pushnumber(L, active_object_count_wider);
+	pushnode(L, neighbor, env->getGameDef()->ndef());
+	lua_pushboolean(L, activate);
 
-	int result = lua_pcall(L, 4, 0, error_handler);
+	int result = lua_pcall(L, 6, 0, error_handler);
 	if (result)
 		scriptIface->scriptError(result, "LuaABM::trigger");
 
@@ -93,6 +105,10 @@
 void LuaLBM::trigger(ServerEnvironment *env, v3s16 p, MapNode n)
 {
 	GameScripting *scriptIface = env->getScriptIface();
+	auto _script_lock = RecursiveMutexAutoLock(scriptIface->m_luastackmutex, std::try_to_lock);
+	if (!_script_lock.owns_lock()) {
+		return;
+	}
 	scriptIface->realityCheck();
 
 	lua_State *L = scriptIface->getStack();
@@ -110,7 +126,11 @@
 	// Get registered_lbms[m_id]
 	lua_pushnumber(L, m_id);
 	lua_gettable(L, -2);
-	FATAL_ERROR_IF(lua_isnil(L, -1), "Entry with given id not found in registered_lbms table");
+	//FATAL_ERROR_IF(lua_isnil(L, -1), "Entry with given id not found in registered_lbms table");
+	if (lua_isnil(L, -1)) {
+		errorstream << "Entry with given id " << m_id << " not found in registered_lbms table" << std::endl;
+		return;
+	}
 	lua_remove(L, -2); // Remove registered_lbms
 
 	scriptIface->setOriginFromTable(-1);
@@ -147,7 +167,7 @@
 
 // Exported functions
 
-// set_node(pos, node)
+// set_node(pos, node, fast)
 // pos = {x=num, y=num, z=num}
 int ModApiEnvMod::l_set_node(lua_State *L)
 {
@@ -158,7 +178,7 @@
 	v3s16 pos = read_v3s16(L, 1);
 	MapNode n = readnode(L, 2, ndef);
 	// Do it
-	bool succeeded = env->setNode(pos, n);
+	bool succeeded = env->setNode(pos, n, lua_tonumber(L, 3));
 	lua_pushboolean(L, succeeded);
 	return 1;
 }
@@ -168,7 +188,7 @@
 	return l_set_node(L);
 }
 
-// remove_node(pos)
+// remove_node(pos, fast)
 // pos = {x=num, y=num, z=num}
 int ModApiEnvMod::l_remove_node(lua_State *L)
 {
@@ -177,7 +197,7 @@
 	// parameters
 	v3s16 pos = read_v3s16(L, 1);
 	// Do it
-	bool succeeded = env->removeNode(pos);
+	bool succeeded = env->removeNode(pos, lua_tonumber(L, 2));
 	lua_pushboolean(L, succeeded);
 	return 1;
 }
@@ -371,10 +391,14 @@
 	GET_ENV_PTR;
 
 	v3s16 pos = read_v3s16(L, 1);
-	u8 level = 1;
+	s16 level = 1;
 	if(lua_isnumber(L, 2))
 		level = lua_tonumber(L, 2);
 	MapNode n = env->getMap().getNodeNoEx(pos);
+	if(n.getContent() == CONTENT_IGNORE){
+		lua_pushnumber(L, 0);
+		return 1;
+	}
 	lua_pushnumber(L, n.setLevel(env->getGameDef()->ndef(), level));
 	env->setNode(pos, n);
 	return 1;
@@ -388,11 +412,39 @@
 	GET_ENV_PTR;
 
 	v3s16 pos = read_v3s16(L, 1);
-	u8 level = 1;
+	s16 level = 1;
+	bool compress = 0;
 	if(lua_isnumber(L, 2))
 		level = lua_tonumber(L, 2);
+	if(lua_isnumber(L, 3))
+		compress = lua_tonumber(L, 3);
 	MapNode n = env->getMap().getNodeNoEx(pos);
-	lua_pushnumber(L, n.addLevel(env->getGameDef()->ndef(), level));
+	if(n.getContent() == CONTENT_IGNORE){
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+	lua_pushnumber(L, n.addLevel(env->getGameDef()->ndef(), level, compress));
+	env->setNode(pos, n);
+	return 1;
+}
+
+// freeze_melt(pos, direction)
+// pos = {x=num, y=num, z=num}
+// direction: -1 (freeze), 1 (melt)
+int ModApiEnvMod::l_freeze_melt(lua_State *L)
+{
+	GET_ENV_PTR;
+
+	v3s16 pos = read_v3s16(L, 1);
+	int direction = 1;
+	if(lua_isnumber(L, 2))
+		direction = lua_tonumber(L, 2);
+	MapNode n = env->getMap().getNodeNoEx(pos);
+	if(n.getContent() == CONTENT_IGNORE){
+		lua_pushnumber(L, 0);
+		return 1;
+	}
+	lua_pushnumber(L, n.freeze_melt(env->getGameDef()->ndef(), direction));
 	env->setNode(pos, n);
 	return 1;
 }
@@ -524,6 +576,8 @@
 	std::vector<u16>::const_iterator iter = ids.begin();
 	for(u32 i = 0; iter != ids.end(); iter++) {
 		ServerActiveObject *obj = env->getActiveObject(*iter);
+		if (!obj)
+			continue;
 		// Insert object reference into table
 		script->objectrefGetOrCreate(L, obj);
 		lua_rawseti(L, -2, ++i);
@@ -590,7 +644,7 @@
 	INodeDefManager *ndef = getServer(L)->ndef();
 	v3s16 pos = read_v3s16(L, 1);
 	int radius = luaL_checkinteger(L, 2);
-	std::set<content_t> filter;
+	std::unordered_set<content_t> filter;
 	if(lua_istable(L, 3)){
 		int table = 3;
 		lua_pushnil(L);
@@ -629,7 +683,7 @@
 	INodeDefManager *ndef = getServer(L)->ndef();
 	v3s16 minp = read_v3s16(L, 1);
 	v3s16 maxp = read_v3s16(L, 2);
-	std::set<content_t> filter;
+	std::unordered_set<content_t> filter;
 	if(lua_istable(L, 3)) {
 		int table = 3;
 		lua_pushnil(L);
@@ -660,7 +714,7 @@
 				}
 	}
 	lua_newtable(L);
-	for (std::set<content_t>::iterator it = filter.begin();
+	for (auto it = filter.begin();
 			it != filter.end(); ++it) {
 		lua_pushnumber(L, individual_count[*it]);
 		lua_setfield(L, -2, ndef->get(*it).name.c_str());
@@ -684,7 +738,7 @@
 	INodeDefManager *ndef = getServer(L)->ndef();
 	v3s16 minp = read_v3s16(L, 1);
 	v3s16 maxp = read_v3s16(L, 2);
-	std::set<content_t> filter;
+	std::unordered_set<content_t> filter;
 
 	if (lua_istable(L, 3)) {
 		int table = 3;
@@ -893,7 +947,7 @@
 		v3s16 bp(x, y, z);
 		if (map.deleteBlock(bp)) {
 			env->setStaticForActiveObjectsInBlock(bp, false);
-			event.modified_blocks.insert(bp);
+			//event.modified_blocks.insert(bp);
 		} else {
 			success = false;
 		}
@@ -947,6 +1001,30 @@
 	return 0;
 }
 
+// get_surface(basepos,yoffset,walkable_only=false)
+int ModApiEnvMod::l_get_surface(lua_State *L)
+{
+	GET_ENV_PTR;
+
+	v3s16 basepos = read_v3s16(L, 1);
+	int max_y = luaL_checkint(L, 2);
+	bool walkable_only = false;
+
+	if (!lua_isnil(L,3)) {
+		walkable_only = lua_toboolean(L, -1);
+	}
+
+	int result = env->getMap().getSurface(basepos,max_y,walkable_only);
+
+	if (result >= basepos.Y) {
+		lua_pushnumber(L,result);
+		return 1;
+	}
+
+	lua_pushnil(L);
+	return 1;
+}
+
 // spawn_tree(pos, treedef)
 int ModApiEnvMod::l_spawn_tree(lua_State *L)
 {
@@ -1011,8 +1089,31 @@
 {
 	GET_ENV_PTR;
 
-	v3s16 p0 = read_v3s16(L, 1);
-	env->getMap().transforming_liquid_add(p0);
+	auto pos = read_v3POS(L, 1);
+	env->getMap().transforming_liquid_add(pos);
+	return 1;
+}
+
+// freeminer.get_heat(pos)
+// pos = {x=num, y=num, z=num}
+int ModApiEnvMod::l_get_heat(lua_State *L)
+{
+	GET_ENV_PTR;
+
+	auto pos = read_v3POS(L, 1);
+
+	lua_pushnumber(L, env->getServerMap().updateBlockHeat(env, pos));
+	return 1;
+}
+
+// freeminer.get_humidity(pos)
+// pos = {x=num, y=num, z=num}
+int ModApiEnvMod::l_get_humidity(lua_State *L)
+{
+	GET_ENV_PTR;
+
+	auto pos = read_v3POS(L, 1);
+	lua_pushnumber(L, env->getServerMap().updateBlockHumidity(env, pos));
 	return 1;
 }
 
@@ -1055,6 +1156,7 @@
 	API_FCT(get_node_level);
 	API_FCT(set_node_level);
 	API_FCT(add_node_level);
+	API_FCT(freeze_melt);
 	API_FCT(add_entity);
 	API_FCT(find_nodes_with_meta);
 	API_FCT(get_meta);
@@ -1078,6 +1180,17 @@
 	API_FCT(find_path);
 	API_FCT(line_of_sight);
 	API_FCT(transforming_liquid_add);
+	API_FCT(get_heat);
+	API_FCT(get_humidity);
+	API_FCT(get_surface);
 	API_FCT(forceload_block);
 	API_FCT(forceload_free_block);
+
+//epixel:
+	API_FCT(spawn_item_activeobject);
+	API_FCT(spawn_falling_node);
+	API_FCT(nodeupdate);
+/*
+	API_FCT(make_explosion);
+*/
 }
