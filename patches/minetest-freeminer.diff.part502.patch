diff -ruN minetest-master/src/serverlist.cpp minetest-freeminer/src/serverlist.cpp
--- minetest-master/src/serverlist.cpp	2016-09-03 16:15:52.613779000 -0700
+++ minetest-freeminer/src/serverlist.cpp	2016-09-03 15:43:59.762740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+serverlist.cpp
 Copyright (C) 2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include <fstream>
@@ -23,6 +26,7 @@
 #include <algorithm>
 
 #include "version.h"
+//#include <fstream>
 #include "settings.h"
 #include "serverlist.h"
 #include "filesys.h"
@@ -33,6 +37,7 @@
 #include "convert_json.h"
 #include "httpfetch.h"
 #include "util/string.h"
+#include "config.h"
 
 namespace ServerList
 {
@@ -41,8 +46,7 @@
 {
 	std::string serverlist_file = g_settings->get("serverlist_file");
 
-	std::string dir_path = "client" DIR_DELIM "serverlist" DIR_DELIM;
-	fs::CreateDir(porting::path_user + DIR_DELIM  "client");
+	std::string dir_path = std::string("client") + DIR_DELIM;
 	fs::CreateDir(porting::path_user + DIR_DELIM + dir_path);
 	return porting::path_user + DIR_DELIM + dir_path + serverlist_file;
 }
@@ -66,6 +70,8 @@
 }
 
 
+std::vector<ServerListSpec> cached_online;
+
 std::vector<ServerListSpec> getOnline()
 {
 	std::ostringstream geturl;
@@ -95,6 +101,7 @@
 		}
 	}
 
+	cached_online = server_list; 
 	return server_list;
 }
 
@@ -144,44 +151,26 @@
 std::vector<ServerListSpec> deSerialize(const std::string &liststring)
 {
 	std::vector<ServerListSpec> serverlist;
+	Json::Value root;
+	Json::Reader reader;
 	std::istringstream stream(liststring);
-	std::string line, tmp;
-	while (std::getline(stream, line)) {
-		std::transform(line.begin(), line.end(), line.begin(), ::toupper);
-		if (line == "[SERVER]") {
-			ServerListSpec server;
-			std::getline(stream, tmp);
-			server["name"] = tmp;
-			std::getline(stream, tmp);
-			server["address"] = tmp;
-			std::getline(stream, tmp);
-			server["port"] = tmp;
-			std::getline(stream, tmp);
-			server["description"] = tmp;
-			serverlist.push_back(server);
-		}
+	if (!liststring.size()) {
+		return serverlist;
 	}
+	if (!reader.parse( stream, root ) )
+	{
+		errorstream  << "Failed to parse server list " << reader.getFormattedErrorMessages();
+		return serverlist;
+	}
+	if (root["list"].isArray())
+		for (unsigned int i = 0; i < root["list"].size(); i++)
+			if (root["list"][i].isObject())
+				serverlist.push_back(root["list"][i]);
 	return serverlist;
 }
 
 const std::string serialize(const std::vector<ServerListSpec> &serverlist)
 {
-	std::string liststring;
-	for (std::vector<ServerListSpec>::const_iterator it = serverlist.begin();
-			it != serverlist.end();
-			++it) {
-		liststring += "[server]\n";
-		liststring += (*it)["name"].asString() + '\n';
-		liststring += (*it)["address"].asString() + '\n';
-		liststring += (*it)["port"].asString() + '\n';
-		liststring += (*it)["description"].asString() + '\n';
-		liststring += '\n';
-	}
-	return liststring;
-}
-
-const std::string serializeJson(const std::vector<ServerListSpec> &serverlist)
-{
 	Json::Value root;
 	Json::Value list(Json::arrayValue);
 	for (std::vector<ServerListSpec>::const_iterator it = serverlist.begin();
@@ -190,12 +179,11 @@
 		list.append(*it);
 	}
 	root["list"] = list;
-	Json::FastWriter writer;
+	Json::StyledWriter writer;
 	return writer.write(root);
 }
 
 
-#if USE_CURL
 void sendAnnounce(const std::string &action,
 		const u16 port,
 		const std::vector<std::string> &clients_names,
@@ -206,6 +194,7 @@
 		const std::string &mg_name,
 		const std::vector<ModSpec> &mods)
 {
+#if USE_CURL
 	Json::Value server;
 	server["action"] = action;
 	server["port"] = port;
@@ -224,8 +213,10 @@
 		server["damage"]       = g_settings->getBool("enable_damage");
 		server["password"]     = g_settings->getBool("disallow_empty_password");
 		server["pvp"]          = g_settings->getBool("enable_pvp");
-		server["uptime"]       = (int) uptime;
-		server["game_time"]    = game_time;
+		if (uptime >= 1)
+			server["uptime"]   = (int) uptime;
+		if (game_time >= 1)
+			server["game_time"]= game_time;
 		server["clients"]      = (int) clients_names.size();
 		server["clients_max"]  = g_settings->getU16("max_users");
 		server["clients_list"] = Json::Value(Json::arrayValue);
@@ -235,14 +226,17 @@
 			server["clients_list"].append(*it);
 		}
 		if (gameid != "") server["gameid"] = gameid;
+		server["proto"]        = g_settings->get("server_proto");
 	}
 
 	if (action == "start") {
 		server["dedicated"]         = g_settings->getBool("server_dedicated");
 		server["rollback"]          = g_settings->getBool("enable_rollback_recording");
 		server["mapgen"]            = mg_name;
-		server["privs"]             = g_settings->get("default_privs");
+		server["privs"]             = g_settings->getBool("creative_mode") ? g_settings->get("default_privs_creative") : g_settings->get("default_privs");
 		server["can_see_far_names"] = g_settings->getS16("player_transfer_distance") <= 0;
+		server["liquid_real"]       = g_settings->getBool("liquid_real");
+		server["version_hash"]      = g_version_hash;
 		server["mods"]              = Json::Value(Json::arrayValue);
 		for (std::vector<ModSpec>::const_iterator it = mods.begin();
 				it != mods.end();
@@ -257,11 +251,53 @@
 
 	Json::FastWriter writer;
 	HTTPFetchRequest fetch_request;
+	fetch_request.timeout = fetch_request.connect_timeout = 59000;
 	fetch_request.url = g_settings->get("serverlist_url") + std::string("/announce");
+
+#if !MINETEST_PROTO
+	// todo: need to patch masterserver script to parse multipart posts
+	std::string query = std::string("json=") + urlencode(writer.write(server));
+	if (query.size() < 1000)
+		fetch_request.url += "?" + query;
+	else
+		fetch_request.post_data = query;
+#else
 	fetch_request.post_fields["json"] = writer.write(server);
 	fetch_request.multipart = true;
+#endif
+
 	httpfetch_async(fetch_request);
-}
 #endif
+}
+
+
+lan_adv lan_adv_client;
+
+void lan_get() {
+	if (!g_settings->getBool("serverlist_lan"))
+		return;
+	ServerList::lan_adv_client.ask();
+}
+
+void lan_apply(std::vector<ServerListSpec> & servers) {
+	auto lock = lan_adv_client.collected.lock_unique_rec();
+	if (lan_adv_client.collected.size()) {
+		if (servers.size()) {
+			Json::Value separator;
+			separator["name"] = "-----lan-servers-end-----";
+			servers.insert(servers.begin(), separator);
+		}
+		for (auto & i : lan_adv_client.collected) {
+			servers.insert(servers.begin(), i.second);
+		}
+	}
+}
+
+bool lan_fresh() {
+	auto result = lan_adv_client.fresh.load();
+	lan_adv_client.fresh = false;
+	return result;
+}
+
 
 } //namespace ServerList
