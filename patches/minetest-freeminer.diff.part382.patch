diff -ruN minetest-master/src/network/connection.cpp minetest-freeminer/src/network/connection.cpp
--- minetest-master/src/network/connection.cpp	2016-09-03 16:15:52.577779000 -0700
+++ minetest-freeminer/src/network/connection.cpp	2016-09-03 15:43:59.730739000 -0700
@@ -1,22 +1,33 @@
 /*
-Minetest
+connection.cpp
 Copyright (C) 2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#include "config.h"
+
+#if !MINETEST_PROTO
+#include "network/fm_connection.cpp"
+#else
+//Not used, keep for reduce MT merge conflicts
+
+
 #include <iomanip>
 #include <errno.h>
 #include "connection.h"
@@ -53,6 +64,11 @@
 #undef DEBUG_CONNECTION_KBPS
 #endif
 
+#undef LOG
+#define LOG(a) a
+#undef PROFILE
+#define PROFILE(a)
+#undef DEBUG_CONNECTION_KBPS
 
 static inline float CALC_DTIME(unsigned int lasttime, unsigned int curtime) {
 	float value = ( curtime - lasttime) / 1000.0;
@@ -208,7 +224,9 @@
 	ReliablePacketBuffer
 */
 
-ReliablePacketBuffer::ReliablePacketBuffer(): m_list_size(0) {}
+ReliablePacketBuffer::ReliablePacketBuffer() {
+	m_list_size = 0;
+}
 
 void ReliablePacketBuffer::print()
 {
@@ -971,8 +989,10 @@
 
 		if (profiler_id != "")
 		{
+/*
 			g_profiler->graphAdd(profiler_id + "_rtt", rtt);
 			g_profiler->graphAdd(profiler_id + "_jitter", jitter);
+*/
 		}
 	}
 	/* save values required for next loop */
@@ -1283,10 +1303,13 @@
 	PROFILE(std::stringstream ThreadIdentifier);
 	PROFILE(ThreadIdentifier << "ConnectionSend: [" << m_connection->getDesc() << "]");
 
+	porting::setThreadName("ConnectionSend");
+	porting::setThreadPriority(90);
+
 	/* if stop is requested don't stop immediately but try to send all        */
 	/* packets first */
 	while(!stopRequested() || packetsQueued()) {
-		BEGIN_DEBUG_EXCEPTION_HANDLER
+		EXCEPTION_HANDLER_BEGIN;
 		PROFILE(ScopeProfiler sp(g_profiler, ThreadIdentifier.str(), SPT_AVG));
 
 		m_iteration_packets_avaialble = m_max_data_packets_per_iteration;
@@ -1319,7 +1342,7 @@
 		/* send non reliable packets */
 		sendPackets(dtime);
 
-		END_DEBUG_EXCEPTION_HANDLER
+		EXCEPTION_HANDLER_END;
 	}
 
 	PROFILE(g_profiler->remove(ThreadIdentifier.str()));
@@ -1435,10 +1458,11 @@
 			for(std::list<BufferedPacket>::iterator k = timed_outs.begin();
 				k != timed_outs.end(); ++k)
 			{
+/*
 				u16 peer_id = readPeerId(*(k->data));
 				u8 channelnum  = readChannel(*(k->data));
 				u16 seqnum  = readU16(&(k->data[BASE_HEADER_SIZE+1]));
-
+*/
 				channel->UpdateBytesLost(k->data.getSize());
 				k->resend_count++;
 
@@ -1449,6 +1473,7 @@
 					break;
 				}
 
+/*
 				LOG(derr_con<<m_connection->getDesc()
 						<<"RE-SENDING timed-out RELIABLE to "
 						<< k->address.serializeString()
@@ -1457,6 +1482,7 @@
 						<<", channel="<<((int)channelnum&0xff)
 						<<", seqnum="<<seqnum
 						<<std::endl);
+*/
 
 				rawSend(*k);
 
@@ -1753,7 +1779,7 @@
 	Address bind_addr;
 
 	if (address.isIPv6())
-		bind_addr.setAddress((IPv6AddressBytes*) NULL);
+		bind_addr.setAddress(in6addr_any);
 	else
 		bind_addr.setAddress(0,0,0,0);
 
@@ -2046,6 +2072,9 @@
 	PROFILE(std::stringstream ThreadIdentifier);
 	PROFILE(ThreadIdentifier << "ConnectionReceive: [" << m_connection->getDesc() << "]");
 
+	porting::setThreadName("ConnectionReceive");
+	porting::setThreadPriority(90);
+
 #ifdef DEBUG_CONNECTION_KBPS
 	u32 curtime = porting::getTimeMs();
 	u32 lasttime = curtime;
@@ -2053,7 +2082,7 @@
 #endif
 
 	while(!stopRequested()) {
-		BEGIN_DEBUG_EXCEPTION_HANDLER
+		EXCEPTION_HANDLER_BEGIN;
 		PROFILE(ScopeProfiler sp(g_profiler, ThreadIdentifier.str(), SPT_AVG));
 
 #ifdef DEBUG_CONNECTION_KBPS
@@ -2117,7 +2146,7 @@
 			}
 		}
 #endif
-		END_DEBUG_EXCEPTION_HANDLER
+		EXCEPTION_HANDLER_END;
 	}
 
 	PROFILE(g_profiler->remove(ThreadIdentifier.str()));
@@ -2130,7 +2159,7 @@
 	// use IPv6 minimum allowed MTU as receive buffer size as this is
 	// theoretical reliable upper boundary of a udp packet for all IPv6 enabled
 	// infrastructure
-	unsigned int packet_maxsize = 1500;
+	unsigned int packet_maxsize = 16384;
 	SharedBuffer<u8> packetdata(packet_maxsize);
 
 	bool packet_queued = true;
@@ -2420,10 +2449,12 @@
 				}
 			}
 			catch(NotFoundException &e) {
+/*
 				LOG(derr_con<<m_connection->getDesc()
 						<<"WARNING: ACKed packet not "
 						"in outgoing queue"
 						<<std::endl);
+*/
 				channel->UpdatePacketTooLateCounter();
 			}
 			throw ProcessedSilentlyException("Got an ACK");
@@ -2678,7 +2709,6 @@
 	m_udpSocket(ipv6),
 	m_command_queue(),
 	m_event_queue(),
-	m_peer_id(0),
 	m_protocol_id(protocol_id),
 	m_sendThread(max_packet_size, timeout),
 	m_receiveThread(max_packet_size),
@@ -2689,6 +2719,8 @@
 	m_next_remote_peer_id(2)
 
 {
+	m_peer_id = 0;
+
 	m_udpSocket.setTimeoutMs(5);
 
 	m_sendThread.setParent(this);
@@ -2884,10 +2916,10 @@
 	putCommand(c);
 }
 
-void Connection::Receive(NetworkPacket* pkt)
+u32 Connection::Receive(NetworkPacket* pkt, int timeout)
 {
 	for(;;) {
-		ConnectionEvent e = waitEvent(m_bc_receive_timeout);
+		ConnectionEvent e = waitEvent(timeout ? timeout : m_bc_receive_timeout);
 		if (e.type != CONNEVENT_NONE)
 			LOG(dout_con << getDesc() << ": Receive: got event: "
 					<< e.describe() << std::endl);
@@ -2901,17 +2933,17 @@
 			}
 
 			pkt->putRawPacket(*e.data, e.data.getSize(), e.peer_id);
-			return;
+			return e.data.getSize();
 		case CONNEVENT_PEER_ADDED: {
-			UDPPeer tmp(e.peer_id, e.address, this);
+			//UDPPeer tmp(e.peer_id, e.address, this);
 			if (m_bc_peerhandler)
-				m_bc_peerhandler->peerAdded(&tmp);
+				m_bc_peerhandler->peerAdded(e.peer_id);
 			continue;
 		}
 		case CONNEVENT_PEER_REMOVED: {
-			UDPPeer tmp(e.peer_id, e.address, this);
+			//UDPPeer tmp(e.peer_id, e.address, this);
 			if (m_bc_peerhandler)
-				m_bc_peerhandler->deletingPeer(&tmp, e.timeout);
+				m_bc_peerhandler->deletingPeer(e.peer_id, e.timeout);
 			continue;
 		}
 		case CONNEVENT_BIND_FAILED:
@@ -2919,9 +2951,13 @@
 					"(port already in use?)");
 		}
 	}
+	return 0;
+/*
 	throw NoIncomingDataException("No incoming data");
+*/
 }
 
+
 void Connection::Send(u16 peer_id, u8 channelnum,
 		NetworkPacket* pkt, bool reliable)
 {
@@ -2955,6 +2991,9 @@
 {
 	PeerHelper peer = getPeerNoEx(PEER_ID_SERVER);
 
+	if (!peer)
+		return 0;
+
 	FATAL_ERROR_IF(!peer, "Connection::getLocalStat we couldn't get our own peer? are you serious???");
 
 	float retval = 0.0;
@@ -3110,3 +3149,6 @@
 }
 
 } // namespace
+
+
+#endif
