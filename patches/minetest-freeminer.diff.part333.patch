diff -ruN minetest-master/src/mapblock.h minetest-freeminer/src/mapblock.h
--- minetest-master/src/mapblock.h	2016-09-03 16:15:52.457778000 -0700
+++ minetest-freeminer/src/mapblock.h	2016-09-03 15:43:59.854740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+mapblock.h
 Copyright (C) 2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifndef MAPBLOCK_HEADER
@@ -31,6 +34,7 @@
 #include "nodetimer.h"
 #include "modifiedstate.h"
 #include "util/numeric.h" // getContainerPos
+#include "threading/lock.h"
 #include "settings.h"
 
 class Map;
@@ -38,6 +42,9 @@
 class IGameDef;
 class MapBlockMesh;
 class VoxelManipulator;
+class Circuit;
+class ServerEnvironment;
+struct ActiveABM;
 
 #define BLOCK_TIMESTAMP_UNDEFINED 0xffffffff
 
@@ -67,6 +74,7 @@
 	// The block and all its neighbors have been generated
 	BLOCKGEN_FULLY_GENERATED=6
 };*/
+static MapNode ignoreNode(CONTENT_IGNORE);
 
 #if 0
 enum
@@ -92,12 +100,22 @@
 			return getNode(p);
 		}
 		catch(InvalidPositionException &e){
-			return MapNode(CONTENT_IGNORE);
+			return ignoreNode;
 		}
 	}
 };
 #endif
 
+struct abm_trigger_one {
+	ActiveABM * abm;
+	v3POS pos;
+	content_t content;
+	u32 active_object_count;
+	u32 active_object_count_wider;
+	v3POS neighbor_pos;
+	bool activate;
+};
+
 ////
 //// MapBlock modified reason flags
 ////
@@ -128,6 +146,7 @@
 ////
 
 class MapBlock /*: public NodeContainer*/
+: public maybe_locker
 {
 public:
 	MapBlock(Map *parent, v3s16 pos, IGameDef *gamedef, bool dummy=false);
@@ -145,19 +164,31 @@
 
 	void reallocate()
 	{
-		delete[] data;
-		data = new MapNode[nodecount];
+		auto lock = lock_unique_rec();
+		if(data != NULL)
+			delete data;
+		data = reinterpret_cast<MapNode*>( ::operator new(nodecount * sizeof(MapNode)));
+		if (!CONTENT_IGNORE)
+			memset(data, 0, nodecount * sizeof(MapNode));
+		else
 		for (u32 i = 0; i < nodecount; i++)
-			data[i] = MapNode(CONTENT_IGNORE);
-
-		raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_REALLOCATE);
+			data[i] = ignoreNode;
 	}
 
+	/*
+		Flags
+	*/
+
+	enum modified_light {modified_light_no = 0, modified_light_yes};
+	void raiseModified(u32 mod, modified_light light = modified_light_no);
+
 	////
 	//// Modification tracking methods
 	////
-	void raiseModified(u32 mod, u32 reason=MOD_REASON_UNKNOWN)
+	void raiseModified(u32 mod, u32 reason)
 	{
+		raiseModified(mod, modified_light_no);
+#ifdef WTFdebug
 		if (mod > m_modified) {
 			m_modified = mod;
 			m_modified_reason = reason;
@@ -166,6 +197,7 @@
 		} else if (mod == m_modified) {
 			m_modified_reason |= reason;
 		}
+#endif
 	}
 
 	inline u32 getModified()
@@ -173,11 +205,6 @@
 		return m_modified;
 	}
 
-	inline u32 getModifiedReason()
-	{
-		return m_modified_reason;
-	}
-
 	std::string getModifiedReasonString();
 
 	inline void resetModified()
@@ -192,12 +219,13 @@
 
 	inline bool isDummy()
 	{
-		return (data == NULL);
+		return false;
+		//return (data == NULL);
 	}
 
 	inline void unDummify()
 	{
-		assert(isDummy()); // Pre-condition
+		//assert(isDummy()); // Pre-condition
 		reallocate();
 	}
 
@@ -210,15 +238,22 @@
 	inline void setIsUnderground(bool a_is_underground)
 	{
 		is_underground = a_is_underground;
+/*
 		raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_SET_IS_UNDERGROUND);
+*/
 	}
 
 	inline void setLightingExpired(bool expired)
 	{
+/*
 		if (expired != m_lighting_expired){
+*/
 			m_lighting_expired = expired;
+
+/*
 			raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_SET_LIGHTING_EXPIRED);
 		}
+*/
 	}
 
 	inline bool getLightingExpired()
@@ -234,15 +269,19 @@
 	inline void setGenerated(bool b)
 	{
 		if (b != m_generated) {
+/*
 			raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_SET_GENERATED);
+*/
 			m_generated = b;
 		}
 	}
 
 	inline bool isValid()
 	{
+/*
 		if (m_lighting_expired)
 			return false;
+*/
 		if (data == NULL)
 			return false;
 		return true;
@@ -287,28 +326,33 @@
 		return isValidPosition(p.X, p.Y, p.Z);
 	}
 
-	inline MapNode getNode(s16 x, s16 y, s16 z, bool *valid_position)
+	inline MapNode getNode(v3POS p, bool *valid_position)
 	{
-		*valid_position = isValidPosition(x, y, z);
+		*valid_position = isValidPosition(p.X, p.Y, p.Z);
 
 		if (!*valid_position)
-			return MapNode(CONTENT_IGNORE);
+			return ignoreNode;
 
-		return data[z * zstride + y * ystride + x];
+		auto lock = lock_shared_rec();
+		return data[p.Z * zstride + p.Y * ystride + p.X];
 	}
 
-	inline MapNode getNode(v3s16 p, bool *valid_position)
+	MapNode getNodeNoEx(v3POS p);
+
+	MapNode getNode(v3s16 p)
 	{
-		return getNode(p.X, p.Y, p.Z, valid_position);
+		return getNodeNoEx(p);
 	}
 
-	inline MapNode getNodeNoEx(v3s16 p)
+	MapNode getNodeTry(v3s16 p)
 	{
-		bool is_valid;
-		MapNode node = getNode(p.X, p.Y, p.Z, &is_valid);
-		return is_valid ? node : MapNode(CONTENT_IGNORE);
+		auto lock = try_lock_shared_rec();
+		if (!lock->owns_lock())
+			return ignoreNode;
+		return getNodeNoLock(p);
 	}
 
+/*
 	inline void setNode(s16 x, s16 y, s16 z, MapNode & n)
 	{
 		if (!isValidPosition(x, y, z))
@@ -317,10 +361,15 @@
 		data[z * zstride + y * ystride + x] = n;
 		raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_SET_NODE);
 	}
+*/
+
+	void setNode(v3s16 p, MapNode & n);
 
-	inline void setNode(v3s16 p, MapNode & n)
+	MapNode getNodeNoLock(v3POS p)
 	{
-		setNode(p.X, p.Y, p.Z, n);
+		if (!data)
+			return ignoreNode;
+		return data[p.Z*zstride + p.Y*ystride + p.X];
 	}
 
 	////
@@ -331,8 +380,9 @@
 	{
 		*valid_position = data != NULL;
 		if (!valid_position)
-			return MapNode(CONTENT_IGNORE);
+			return ignoreNode;
 
+		auto lock = lock_shared_rec();
 		return data[z * zstride + y * ystride + x];
 	}
 
@@ -341,37 +391,35 @@
 		return getNodeNoCheck(p.X, p.Y, p.Z, valid_position);
 	}
 
-	inline void setNodeNoCheck(s16 x, s16 y, s16 z, MapNode & n)
+	inline void setNodeNoCheck(v3s16 p, MapNode & n)
 	{
-		if (data == NULL)
-			throw InvalidPositionException();
+		//if (data == NULL)
+		//	throw InvalidPositionException("setNodeNoCheck data=NULL");
 
-		data[z * zstride + y * ystride + x] = n;
-		raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_SET_NODE_NO_CHECK);
-	}
+		auto lock = lock_unique_rec();
 
-	inline void setNodeNoCheck(v3s16 p, MapNode & n)
-	{
-		setNodeNoCheck(p.X, p.Y, p.Z, n);
+		data[p.Z * zstride + p.Y * ystride + p.X] = n;
+		raiseModified(MOD_STATE_WRITE_NEEDED, MOD_REASON_SET_NODE_NO_CHECK);
 	}
 
 	// These functions consult the parent container if the position
 	// is not valid on this MapBlock.
 	bool isValidPositionParent(v3s16 p);
 	MapNode getNodeParent(v3s16 p, bool *is_valid_position = NULL);
-	void setNodeParent(v3s16 p, MapNode & n);
 
 	inline void drawbox(s16 x0, s16 y0, s16 z0, s16 w, s16 h, s16 d, MapNode node)
 	{
 		for (u16 z = 0; z < d; z++)
 		for (u16 y = 0; y < h; y++)
 		for (u16 x = 0; x < w; x++)
-			setNode(x0 + x, y0 + y, z0 + z, node);
+			setNode(v3s16(x0+x, y0+y, z0+z), node);
 	}
 
+/*
 	// See comments in mapblock.cpp
 	bool propagateSunlight(std::set<v3s16> &light_sources,
 		bool remove_light=false, bool *black_air_left=NULL);
+*/
 
 	// Copies data to VoxelManipulator to getPosRelative()
 	void copyTo(VoxelManipulator &dst);
@@ -442,16 +490,16 @@
 
 	inline void resetUsageTimer()
 	{
+		std::lock_guard<Mutex> lock(m_usage_timer_mutex);
 		m_usage_timer = 0;
+		usage_timer_multiplier = 1;
 	}
 
-	inline void incrementUsageTimer(float dtime)
-	{
-		m_usage_timer += dtime;
-	}
+	void incrementUsageTimer(float dtime);
 
 	inline float getUsageTimer()
 	{
+		std::lock_guard<Mutex> lock(m_usage_timer_mutex);
 		return m_usage_timer;
 	}
 
@@ -505,14 +553,23 @@
 	// These don't write or read version by itself
 	// Set disk to true for on-disk format, false for over-the-network format
 	// Precondition: version >= SER_FMT_VER_LOWEST_WRITE
-	void serialize(std::ostream &os, u8 version, bool disk);
+	void serialize(std::ostream &os, u8 version, bool disk, bool use_content_only = false);
 	// If disk == true: In addition to doing other things, will add
 	// unknown blocks from id-name mapping to wndef
-	void deSerialize(std::istream &is, u8 version, bool disk);
+	bool deSerialize(std::istream &is, u8 version, bool disk);
 
 	void serializeNetworkSpecific(std::ostream &os, u16 net_proto_version);
 	void deSerializeNetworkSpecific(std::istream &is);
 
+	void pushElementsToCircuit(Circuit* circuit);
+
+#ifndef SERVER // Only on client
+	typedef std::shared_ptr<MapBlockMesh> mesh_type;
+
+	MapBlock::mesh_type getMesh(int step = 1);
+	void setMesh(MapBlock::mesh_type & rmesh);
+#endif
+
 private:
 	/*
 		Private methods
@@ -527,7 +584,7 @@
 	inline MapNode &getNodeRef(s16 x, s16 y, s16 z)
 	{
 		if (!isValidPosition(x, y, z))
-			throw InvalidPositionException();
+			throw InvalidPositionException("getNodeRef InvalidPosition");
 
 		return data[z * zstride + y * ystride + x];
 	}
@@ -543,12 +600,48 @@
 	*/
 
 #ifndef SERVER // Only on client
-	MapBlockMesh *mesh;
+	mesh_type mesh, mesh_old;
+	mesh_type mesh2, mesh4, mesh8, mesh16;
+	std::atomic_uint mesh_size;
 #endif
 
 	NodeMetadataList m_node_metadata;
 	NodeTimerList m_node_timers;
 	StaticObjectList m_static_objects;
+	
+	std::atomic_short heat;
+	std::atomic_short humidity;
+	std::atomic_short heat_add;
+	std::atomic_short humidity_add;
+	std::atomic_ulong heat_last_update;
+	u32 humidity_last_update;
+	float m_uptime_timer_last;
+	std::atomic_short usage_timer_multiplier;
+
+	// Last really changed time (need send to client)
+	std::atomic_uint m_changed_timestamp;
+	u32 m_next_analyze_timestamp;
+	typedef std::list<abm_trigger_one> abm_triggers_type;
+	std::unique_ptr<abm_triggers_type> abm_triggers;
+	Mutex abm_triggers_mutex;
+	void abmTriggersRun(ServerEnvironment * m_env, u32 time, bool activate = false);
+	u32 m_abm_timestamp;
+
+	u32 getActualTimestamp() {
+		u32 block_timestamp = 0;
+		if (m_changed_timestamp && m_changed_timestamp != BLOCK_TIMESTAMP_UNDEFINED) {
+			block_timestamp = m_changed_timestamp;
+		} else if (m_disk_timestamp && m_disk_timestamp != BLOCK_TIMESTAMP_UNDEFINED) {
+			block_timestamp = m_disk_timestamp;
+		}
+		return block_timestamp;
+	}
+
+	// Set to content type of a node if the block consists solely of nodes of one type, otherwise set to CONTENT_IGNORE
+	content_t content_only;
+	u8 content_only_param1, content_only_param2;
+	content_t analyzeContent();
+	std::atomic_short lighting_broken;
 
 	static const u32 ystride = MAP_BLOCKSIZE;
 	static const u32 zstride = MAP_BLOCKSIZE * MAP_BLOCKSIZE;
@@ -606,11 +699,11 @@
 		If this is false, lighting is exactly right.
 		If this is true, lighting might be wrong or right.
 	*/
-	bool m_lighting_expired;
+	std::atomic_bool m_lighting_expired;
 
 	// Whether day and night lighting differs
 	bool m_day_night_differs;
-	bool m_day_night_differs_expired;
+	std::atomic_bool m_day_night_differs_expired;
 
 	bool m_generated;
 
@@ -618,7 +711,7 @@
 		When block is removed from active blocks, this is set to gametime.
 		Value BLOCK_TIMESTAMP_UNDEFINED=0xffffffff means there is no timestamp.
 	*/
-	u32 m_timestamp;
+	std::atomic_uint m_timestamp;
 	// The on-disk (or to-be on-disk) timestamp value
 	u32 m_disk_timestamp;
 
@@ -627,12 +720,13 @@
 		Map will unload the block when this reaches a timeout.
 	*/
 	float m_usage_timer;
+	Mutex m_usage_timer_mutex;
 
 	/*
 		Reference count; currently used for determining if this block is in
 		the list of blocks to be drawn.
 	*/
-	int m_refcount;
+	std::atomic_int m_refcount;
 };
 
 typedef std::vector<MapBlock*> MapBlockVect;
@@ -664,19 +758,12 @@
 /*
 	Returns the position of the block where the node is located
 */
-inline v3s16 getNodeBlockPos(v3s16 p)
-{
-	return getContainerPos(p, MAP_BLOCKSIZE);
-}
-
-inline v2s16 getNodeSectorPos(v2s16 p)
+inline v3s16 getNodeBlockPos(const v3s16 &p)
 {
+	return v3s16(p.X >> MAP_BLOCKP, p.Y >> MAP_BLOCKP, p.Z >> MAP_BLOCKP);
+/*
 	return getContainerPos(p, MAP_BLOCKSIZE);
-}
-
-inline s16 getNodeBlockY(s16 y)
-{
-	return getContainerPos(y, MAP_BLOCKSIZE);
+*/
 }
 
 inline void getNodeBlockPosWithOffset(const v3s16 &p, v3s16 &block, v3s16 &offset)
@@ -694,4 +781,7 @@
 */
 std::string analyze_block(MapBlock *block);
 
+//typedef std::shared_ptr<MapBlock> MapBlockP;
+typedef MapBlock * MapBlockP;
+
 #endif
