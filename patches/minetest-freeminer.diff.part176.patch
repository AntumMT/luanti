diff -ruN minetest-master/src/clientiface.cpp minetest-freeminer/src/clientiface.cpp
--- minetest-master/src/clientiface.cpp	2016-09-03 16:15:52.661779000 -0700
+++ minetest-freeminer/src/clientiface.cpp	2016-09-03 15:43:59.794740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+clientiface.cpp
 Copyright (C) 2010-2014 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include <sstream>
@@ -30,9 +33,57 @@
 #include "map.h"
 #include "emerge.h"
 #include "serverobject.h"              // TODO this is used for cleanup of only
-#include "log.h"
+#include "log_types.h"
 #include "util/srp.h"
 
+#include "util/numeric.h"
+#include "util/mathconstants.h"
+#include "profiler.h"
+#include "gamedef.h"
+
+
+//VERY BAD COPYPASTE FROM clientmap.cpp!
+static bool isOccluded(Map *map, v3s16 p0, v3s16 p1, float step, float stepfac,
+		float start_off, float end_off, u32 needed_count, INodeDefManager *nodemgr,
+		unordered_map_v3POS<bool> & occlude_cache)
+{
+	float d0 = (float)1 * p0.getDistanceFrom(p1);
+	v3s16 u0 = p1 - p0;
+	v3f uf = v3f(u0.X, u0.Y, u0.Z);
+	uf.normalize();
+	v3f p0f = v3f(p0.X, p0.Y, p0.Z);
+	u32 count = 0;
+	for(float s=start_off; s<d0+end_off; s+=step){
+		v3f pf = p0f + uf * s;
+		v3s16 p = floatToInt(pf, 1);
+		bool is_transparent = false;
+		bool cache = true;
+		if (occlude_cache.count(p)) {
+			cache = false;
+			is_transparent = occlude_cache[p];
+		} else {
+		MapNode n = map->getNodeTry(p);
+		if (!n) {
+			return true; // ONE DIFFERENCE FROM clientmap.cpp
+		}
+		const ContentFeatures &f = nodemgr->get(n);
+		if(f.solidness == 0)
+			is_transparent = (f.visual_solidness != 2);
+		else
+			is_transparent = (f.solidness != 2);
+		}
+		if (cache)
+			occlude_cache[p] = is_transparent;
+		if(!is_transparent){
+			if(count == needed_count)
+				return true;
+			count++;
+		}
+		step *= stepfac;
+	}
+	return false;
+}
+
 const char *ClientInterface::statenames[] = {
 	"Invalid",
 	"Disconnecting",
@@ -56,42 +107,45 @@
 void RemoteClient::ResendBlockIfOnWire(v3s16 p)
 {
 	// if this block is on wire, mark it for sending again as soon as possible
-	if (m_blocks_sending.find(p) != m_blocks_sending.end()) {
-		SetBlockNotSent(p);
-	}
+	SetBlockNotSent(p);
 }
 
-void RemoteClient::GetNextBlocks (
+int RemoteClient::GetNextBlocks (
 		ServerEnvironment *env,
 		EmergeManager * emerge,
 		float dtime,
+		double m_uptime,
 		std::vector<PrioritySortedBlockTransfer> &dest)
 {
 	DSTACK(FUNCTION_NAME);
 
+	auto lock = lock_unique_rec();
+	if (!lock->owns_lock())
+		return 0;
 
 	// Increment timers
 	m_nothing_to_send_pause_timer -= dtime;
 	m_nearest_unsent_reset_timer += dtime;
+	m_time_from_building += dtime;
+
+	if (m_nearest_unsent_reset) {
+		m_nearest_unsent_reset = 0;
+		m_nearest_unsent_reset_timer = 999;
+		m_nothing_to_send_pause_timer = 0;
+	}
 
 	if(m_nothing_to_send_pause_timer >= 0)
-		return;
+		return 0;
 
 	Player *player = env->getPlayer(peer_id);
 	// This can happen sometimes; clients and players are not in perfect sync.
 	if(player == NULL)
-		return;
-
-	// Won't send anything if already sending
-	if(m_blocks_sending.size() >= g_settings->getU16
-			("max_simultaneous_block_sends_per_client"))
-	{
-		//infostream<<"Not sending any blocks, Queue full."<<std::endl;
-		return;
-	}
+		return 0;
 
 	v3f playerpos = player->getPosition();
 	v3f playerspeed = player->getSpeed();
+	if(playerspeed.getLength() > 1000.0*BS) //cheater or bug, ignore him
+		return 0;
 	v3f playerspeeddir(0,0,0);
 	if(playerspeed.getLength() > 1.0*BS)
 		playerspeeddir = playerspeed / playerspeed.getLength();
@@ -108,8 +162,7 @@
 	camera_dir.rotateYZBy(player->getPitch());
 	camera_dir.rotateXZBy(player->getYaw());
 
-	/*infostream<<"camera_dir=("<<camera_dir.X<<","<<camera_dir.Y<<","
-			<<camera_dir.Z<<")"<<std::endl;*/
+	//infostream<<"camera_dir=("<<camera_dir<<")"<< " camera_pos="<<camera_pos<<std::endl;
 
 	/*
 		Get the starting value of the block finder radius.
@@ -117,20 +170,25 @@
 
 	if(m_last_center != center)
 	{
-		m_nearest_unsent_d = 0;
 		m_last_center = center;
+		m_nearest_unsent_reset_timer = 999;
+	}
+
+	if (m_last_direction.getDistanceFrom(camera_dir)>0.4) { // 1 = 90deg
+		m_last_direction = camera_dir;
+		m_nearest_unsent_reset_timer = 999;
 	}
 
 	/*infostream<<"m_nearest_unsent_reset_timer="
 			<<m_nearest_unsent_reset_timer<<std::endl;*/
 
 	// Reset periodically to workaround for some bugs or stuff
-	if(m_nearest_unsent_reset_timer > 20.0)
+	if(m_nearest_unsent_reset_timer > 120.0)
 	{
 		m_nearest_unsent_reset_timer = 0;
 		m_nearest_unsent_d = 0;
-		//infostream<<"Resetting m_nearest_unsent_d for "
-		//		<<server->getPlayerName(peer_id)<<std::endl;
+		m_nearest_unsent_reset = 0;
+		//infostream<<"Resetting m_nearest_unsent_d for "<<peer_id<<std::endl;
 	}
 
 	//s16 last_nearest_unsent_d = m_nearest_unsent_d;
@@ -138,27 +196,35 @@
 
 	//infostream<<"d_start="<<d_start<<std::endl;
 
-	u16 max_simul_sends_setting = g_settings->getU16
+	static const u16 max_simul_sends_setting = g_settings->getU16
 			("max_simultaneous_block_sends_per_client");
-	u16 max_simul_sends_usually = max_simul_sends_setting;
+	static const u16 max_simul_sends_usually = max_simul_sends_setting;
 
 	/*
 		Check the time from last addNode/removeNode.
 
 		Decrease send rate if player is building stuff.
 	*/
-	m_time_from_building += dtime;
-	if(m_time_from_building < g_settings->getFloat(
-				"full_block_send_enable_min_time_from_building"))
+	static const auto full_block_send_enable_min_time_from_building = g_settings->getFloat("full_block_send_enable_min_time_from_building");
+	if(m_time_from_building < full_block_send_enable_min_time_from_building)
 	{
+		/*
 		max_simul_sends_usually
 			= LIMITED_MAX_SIMULTANEOUS_BLOCK_SENDS;
+		*/
+		if(d_start<=1)
+			d_start=2;
+		++m_nearest_unsent_reset_want;
+	} else if (m_nearest_unsent_reset_want) {
+		m_nearest_unsent_reset_want = 0;
+		m_nearest_unsent_reset_timer = 999; //magical number more than ^ other number 120 - need to reset d on next iteration
 	}
 
 	/*
 		Number of blocks sending + number of blocks selected for sending
 	*/
-	u32 num_blocks_selected = m_blocks_sending.size();
+	u32 num_blocks_selected = 0;
+	u32 num_blocks_sending = 0;
 
 	/*
 		next time d will be continued from the d from which the nearest
@@ -169,31 +235,99 @@
 	*/
 	s32 new_nearest_unsent_d = -1;
 
-	const s16 full_d_max = g_settings->getS16("max_block_send_distance");
+	static const auto max_block_send_distance = g_settings->getS16("max_block_send_distance");
+	s16 full_d_max = max_block_send_distance;
+	if (wanted_range) {
+		s16 wanted_blocks = wanted_range / MAP_BLOCKSIZE + 1;
+		if (wanted_blocks < full_d_max)
+			full_d_max = wanted_blocks;
+	}
+
 	s16 d_max = full_d_max;
-	s16 d_max_gen = g_settings->getS16("max_block_generate_distance");
+	static const s16 d_max_gen = g_settings->getS16("max_block_generate_distance");
 
 	// Don't loop very much at a time
-	s16 max_d_increment_at_time = 2;
+	s16 max_d_increment_at_time = 10;
 	if(d_max > d_start + max_d_increment_at_time)
 		d_max = d_start + max_d_increment_at_time;
+	/*if(d_max_gen > d_start+2)
+		d_max_gen = d_start+2;*/
+
+	//infostream<<"Starting from "<<d_start<<std::endl;
 
 	s32 nearest_emerged_d = -1;
 	s32 nearest_emergefull_d = -1;
 	s32 nearest_sent_d = -1;
 	//bool queue_is_full = false;
 
+	f32 speed_in_blocks = (playerspeed/(MAP_BLOCKSIZE*BS)).getLength();
+
+	int num_blocks_air = 0;
+	int blocks_occlusion_culled = 0;
+	static const bool server_occlusion = g_settings->getBool("server_occlusion");
+	bool occlusion_culling_enabled = server_occlusion;
+
+	auto cam_pos_nodes = floatToInt(playerpos, BS);
+
+	auto nodemgr = env->getGameDef()->getNodeDefManager();
+	MapNode n;
+	{
+#if !ENABLE_THREADS
+		auto lock = env->getServerMap().m_nothread_locker.lock_shared_rec();
+#endif
+		n = env->getMap().getNodeTry(cam_pos_nodes);
+	}
+
+	if(n && nodemgr->get(n).solidness == 2)
+		occlusion_culling_enabled = false;
+
+	unordered_map_v3POS<bool> occlude_cache;
+
 	s16 d;
 	for(d = d_start; d <= d_max; d++) {
+		/*errorstream<<"checking d="<<d<<" for "
+				<<server->getPlayerName(peer_id)<<std::endl;*/
+		//infostream<<"RemoteClient::SendBlocks(): d="<<d<<" d_start="<<d_start<<" d_max="<<d_max<<" d_max_gen="<<d_max_gen<<std::endl;
+
+		std::vector<v3POS> list;
+		if (d > 2 && d == d_start && !m_nearest_unsent_reset_want && m_nearest_unsent_reset_timer != 999) { // oops, again magic number from up ^
+			list.push_back(v3POS(0,0,0));
+		}
+
+		bool can_skip = d > 1;
+		// Fast fall/move optimize. speed_in_blocks now limited to 6.4
+		if (speed_in_blocks>0.8 && d <= 2) {
+			can_skip = false;
+			if (d == 0) {
+				for(s16 addn = 0; addn < (speed_in_blocks+1)*2; ++addn)
+					list.push_back(floatToInt(playerspeeddir*addn, 1));
+			} else if (d == 1) {
+				for(s16 addn = 0; addn < (speed_in_blocks+1)*1.5; ++addn) {
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( 0,  0,  1)); // back
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( -1, 0,  0)); // left
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( 1,  0,  0)); // right
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( 0,  0, -1)); // front
+				}
+			} else if (d == 2) {
+				for(s16 addn = 0; addn < (speed_in_blocks+1)*1.5; ++addn) {
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( -1, 0,  1)); // back left
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( 1,  0,  1)); // left right
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( -1, 0, -1)); // right left
+					list.push_back(floatToInt(playerspeeddir*addn, 1) + v3POS( 1,  0, -1)); // front right
+				}
+			}
+		} else {
 		/*
 			Get the border/face dot coordinates of a "d-radiused"
 			box
 		*/
-		std::vector<v3s16> list = FacePositionCache::getFacePositions(d);
+			list = FacePositionCache::getFacePositions(d);
+		}
+
 
-		std::vector<v3s16>::iterator li;
-		for(li = list.begin(); li != list.end(); ++li) {
-			v3s16 p = *li + center;
+		for(auto li=list.begin(); li!=list.end(); ++li)
+		{
+			v3POS p = *li + center;
 
 			/*
 				Send throttling
@@ -211,15 +345,11 @@
 				max_simul_dynamic = max_simul_sends_setting;
 
 			// Don't select too many blocks for sending
-			if (num_blocks_selected >= max_simul_dynamic) {
+			if (num_blocks_selected + num_blocks_sending >= max_simul_dynamic) {
 				//queue_is_full = true;
 				goto queue_full_break;
 			}
 
-			// Don't send blocks that are currently being transferred
-			if (m_blocks_sending.find(p) != m_blocks_sending.end())
-				continue;
-
 			/*
 				Do not go over-limit
 			*/
@@ -234,19 +364,23 @@
 				if(abs(p.Y - center.Y) > d_max_gen - d_max_gen / 3)
 					generate = false;*/
 
+				/* maybe good idea (if not use block culling) but brokes far (25+) area generate by flooding emergequeue with no generate blocks
 				// Limit the send area vertically to 1/2
-				if (abs(p.Y - center.Y) > full_d_max / 2)
-					continue;
+				if(can_skip && abs(p.Y - center.Y) > full_d_max / 2)
+					generate = false;
+				*/
 			}
 
+
+			//infostream<<"d="<<d<<std::endl;
 			/*
 				Don't generate or send if not in sight
 				FIXME This only works if the client uses a small enough
 				FOV setting. The default of 72 degrees is fine.
 			*/
 
-			float camera_fov = (72.0*M_PI/180) * 4./3.;
-			if(isBlockInSight(p, camera_pos, camera_dir, camera_fov, 10000*BS) == false)
+			float camera_fov = ((fov+5)*M_PI/180) * 4./3.;
+			if(can_skip && isBlockInSight(p, camera_pos, camera_dir, camera_fov, 10000*BS) == false)
 			{
 				continue;
 			}
@@ -254,32 +388,104 @@
 			/*
 				Don't send already sent blocks
 			*/
+			unsigned int block_sent = 0;
 			{
-				if(m_blocks_sent.find(p) != m_blocks_sent.end())
-				{
-					continue;
-				}
+				auto lock = m_blocks_sent.lock_shared_rec();
+				block_sent = m_blocks_sent.find(p) != m_blocks_sent.end() ? m_blocks_sent.get(p) : 0;
+			}
+
+			if(block_sent > 0 && (/* (block_overflow && d>1) || */ block_sent + (d <= 2 ? 1 : d*d*d) > m_uptime)) {
+				continue;
 			}
 
 			/*
 				Check if map has this block
 			*/
-			MapBlock *block = env->getMap().getBlockNoCreateNoEx(p);
 
-			bool surely_not_found_on_disk = false;
+			MapBlock *block;
+			{
+#if !ENABLE_THREADS
+			auto lock = env->getServerMap().m_nothread_locker.lock_shared_rec();
+#endif
+
+			block = env->getMap().getBlockNoCreateNoEx(p);
+			}
+
+			//bool surely_not_found_on_disk = false;
 			bool block_is_invalid = false;
 			if(block != NULL)
 			{
+
+				/*if (d > 3 && block->content_only == CONTENT_AIR) {
+					continue;
+				}*/
+
+				if (block_sent > 0 && block_sent >= block->m_changed_timestamp) {
+					continue;
+				}
+
+		if (occlusion_culling_enabled) {
+			ScopeProfiler sp(g_profiler, "SMap: Occusion calls");
+			//Occlusion culling
+			auto cpn = p*MAP_BLOCKSIZE;
+
+			// No occlusion culling when free_move is on and camera is
+			// inside ground
+			cpn += v3POS(MAP_BLOCKSIZE/2, MAP_BLOCKSIZE/2, MAP_BLOCKSIZE/2);
+
+			float step = 1;
+			float stepfac = 1.3;
+			float startoff = 5;
+			float endoff = -MAP_BLOCKSIZE;
+			v3POS spn = cam_pos_nodes + v3POS(0,0,0);
+			s16 bs2 = MAP_BLOCKSIZE/2 + 1;
+			u32 needed_count = 1;
+#if !ENABLE_THREADS
+			auto lock = env->getServerMap().m_nothread_locker.lock_shared_rec();
+#endif
+			//VERY BAD COPYPASTE FROM clientmap.cpp!
+			if( can_skip &&
+				occlusion_culling_enabled &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(0,0,0),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(bs2,bs2,bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(bs2,bs2,-bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(bs2,-bs2,bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(bs2,-bs2,-bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(-bs2,bs2,bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(-bs2,bs2,-bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(-bs2,-bs2,bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache) &&
+				isOccluded(&env->getMap(), spn, cpn + v3POS(-bs2,-bs2,-bs2),
+					step, stepfac, startoff, endoff, needed_count, nodemgr, occlude_cache)
+			)
+			{
+				//infostream<<" occlusion player="<<cam_pos_nodes<<" d="<<d<<" block="<<cpn<<" total="<<blocks_occlusion_culled<<"/"<<num_blocks_selected<<std::endl;
+				g_profiler->add("SMap: Occlusion skip", 1);
+				blocks_occlusion_culled++;
+				continue;
+			}
+		}
+
 				// Reset usage timer, this block will be of use in the future.
 				block->resetUsageTimer();
 
-				// Block is dummy if data doesn't exist.
-				// It means it has been not found from disk and not generated
-				if(block->isDummy())
-				{
-					surely_not_found_on_disk = true;
+				if (block->getLightingExpired()) {
+					//env->getServerMap().lighting_modified_blocks.set(p, nullptr);
+					env->getServerMap().lighting_modified_add(p, d);
+					if (block_sent && can_skip)
+						continue;
 				}
 
+				if (block->lighting_broken > 0 && (block_sent || can_skip))
+					continue;
+
 				// Block is valid if lighting is up-to-date and data exists
 				if(block->isValid() == false)
 				{
@@ -287,7 +493,9 @@
 				}
 
 				if(block->isGenerated() == false)
-					block_is_invalid = true;
+				{
+					continue;
+				}
 
 				/*
 					If block is not close, don't send it unless it is near
@@ -296,28 +504,35 @@
 					Block is near ground level if night-time mesh
 					differs from day-time mesh.
 				*/
+/*
 				if(d >= 4)
 				{
 					if(block->getDayNightDiff() == false)
 						continue;
 				}
+*/
 			}
 
 			/*
 				If block has been marked to not exist on disk (dummy)
 				and generating new ones is not wanted, skip block.
 			*/
+			/*
 			if(generate == false && surely_not_found_on_disk == true)
 			{
 				// get next one.
 				continue;
 			}
+			*/
 
 			/*
 				Add inexistent block to emerge queue.
 			*/
-			if(block == NULL || surely_not_found_on_disk || block_is_invalid)
+			if(!block || /*surely_not_found_on_disk ||*/ block_is_invalid)
 			{
+				//infostream<<"start gen d="<<d<<" p="<<p<<" notfound="<<surely_not_found_on_disk<<" invalid="<< block_is_invalid<<" block="<<block<<" generate="<<generate<<std::endl;
+				if (generate || !env->getServerMap().m_db_miss.count(p)) {
+
 				if (emerge->enqueueBlockEmerge(peer_id, p, generate)) {
 					if (nearest_emerged_d == -1)
 						nearest_emerged_d = d;
@@ -326,6 +541,9 @@
 						nearest_emergefull_d = d;
 					goto queue_full_break;
 				}
+				} else {
+					//infostream << "skip tryload " << p << "\n";
+				}
 
 				// get next one.
 				continue;
@@ -337,25 +555,37 @@
 			/*
 				Add block to send queue
 			*/
+
 			PrioritySortedBlockTransfer q((float)d, p, peer_id);
 
 			dest.push_back(q);
 
+			if (block->content_only == CONTENT_AIR)
+				++num_blocks_air;
+			else
 			num_blocks_selected += 1;
 		}
 	}
 queue_full_break:
 
+	//infostream<<"Stopped at "<<d<<" d_start="<<d_start<< " d_max="<<d_max<<" nearest_emerged_d="<<nearest_emerged_d<<" nearest_emergefull_d="<<nearest_emergefull_d<< " new_nearest_unsent_d="<<new_nearest_unsent_d<< " sel="<<num_blocks_selected<< "+"<<num_blocks_sending << " air="<<num_blocks_air<< " culled=" << blocks_occlusion_culled <<" cEN="<<occlusion_culling_enabled<<std::endl;
+	num_blocks_selected += num_blocks_sending;
+	if(!num_blocks_selected && !num_blocks_air && d_start <= d) {
+		//new_nearest_unsent_d = 0;
+		m_nothing_to_send_pause_timer = 1.0;
+	}
+		
+
 	// If nothing was found for sending and nothing was queued for
 	// emerging, continue next time browsing from here
-	if(nearest_emerged_d != -1){
+	if(nearest_emerged_d != -1 && nearest_emerged_d > nearest_emergefull_d){
 		new_nearest_unsent_d = nearest_emerged_d;
 	} else if(nearest_emergefull_d != -1){
 		new_nearest_unsent_d = nearest_emergefull_d;
 	} else {
-		if(d > g_settings->getS16("max_block_send_distance")){
+		if(d > full_d_max){
 			new_nearest_unsent_d = 0;
-			m_nothing_to_send_pause_timer = 2.0;
+			m_nothing_to_send_pause_timer = 10.0;
 		} else {
 			if(nearest_sent_d != -1)
 				new_nearest_unsent_d = nearest_sent_d;
@@ -364,10 +594,14 @@
 		}
 	}
 
-	if(new_nearest_unsent_d != -1)
+	if(new_nearest_unsent_d != -1) {
 		m_nearest_unsent_d = new_nearest_unsent_d;
+	}
+
+	return num_blocks_selected - num_blocks_sending;
 }
 
+/*
 void RemoteClient::GotBlock(v3s16 p)
 {
 	if (m_blocks_modified.find(p) == m_blocks_modified.end()) {
@@ -379,7 +613,14 @@
 		m_blocks_sent.insert(p);
 	}
 }
+*/
+
+void RemoteClient::SentBlock(v3s16 p, double time)
+{
+	m_blocks_sent.set(p, time);
+}
 
+/*
 void RemoteClient::SentBlock(v3s16 p)
 {
 	if (m_blocks_modified.find(p) != m_blocks_modified.end())
@@ -391,9 +632,12 @@
 		infostream<<"RemoteClient::SentBlock(): Sent block"
 				" already in m_blocks_sending"<<std::endl;
 }
+*/
 
 void RemoteClient::SetBlockNotSent(v3s16 p)
 {
+	++m_nearest_unsent_reset;
+/*
 	m_nearest_unsent_d = 0;
 	m_nothing_to_send_pause_timer = 0;
 
@@ -402,25 +646,30 @@
 	if(m_blocks_sent.find(p) != m_blocks_sent.end())
 		m_blocks_sent.erase(p);
 	m_blocks_modified.insert(p);
+*/
 }
 
-void RemoteClient::SetBlocksNotSent(std::map<v3s16, MapBlock*> &blocks)
+void RemoteClient::SetBlocksNotSent()
 {
-	m_nearest_unsent_d = 0;
-	m_nothing_to_send_pause_timer = 0;
+	++m_nearest_unsent_reset;
+}
 
+void RemoteClient::SetBlocksNotSent(std::map<v3s16, MapBlock*> &blocks)
+{
+	++m_nearest_unsent_reset;
+/*
 	for(std::map<v3s16, MapBlock*>::iterator
 			i = blocks.begin();
 			i != blocks.end(); ++i)
 	{
 		v3s16 p = i->first;
 		m_blocks_modified.insert(p);
-
-		if(m_blocks_sending.find(p) != m_blocks_sending.end())
-			m_blocks_sending.erase(p);
-		if(m_blocks_sent.find(p) != m_blocks_sent.end())
-			m_blocks_sent.erase(p);
 	}
+*/
+}
+
+void RemoteClient::SetBlockDeleted(v3s16 p) {
+	m_blocks_sent.erase(p);
 }
 
 void RemoteClient::notifyEvent(ClientStateEvent event)
@@ -599,29 +848,14 @@
 }
 ClientInterface::~ClientInterface()
 {
-	/*
-		Delete clients
-	*/
-	{
-		MutexAutoLock clientslock(m_clients_mutex);
-
-		for(std::map<u16, RemoteClient*>::iterator
-			i = m_clients.begin();
-			i != m_clients.end(); ++i)
-		{
-
-			// Delete client
-			delete i->second;
-		}
-	}
 }
 
 std::vector<u16> ClientInterface::getClientIDs(ClientState min_state)
 {
 	std::vector<u16> reply;
-	MutexAutoLock clientslock(m_clients_mutex);
+	auto clientslock = m_clients.lock_shared_rec();
 
-	for(std::map<u16, RemoteClient*>::iterator
+	for(auto
 		i = m_clients.begin();
 		i != m_clients.end(); ++i)
 	{
@@ -640,6 +874,7 @@
 
 void ClientInterface::step(float dtime)
 {
+	g_profiler->add("Server: Clients", m_clients.size());
 	m_print_info_timer += dtime;
 	if(m_print_info_timer >= 30.0)
 	{
@@ -655,11 +890,16 @@
 		std::vector<u16> clients = getClientIDs();
 		m_clients_names.clear();
 
+		auto now = porting::getTimeMs();
+		static auto last_print = now;
+		bool print = now >= last_print;
+		if (print)
+			last_print = now + 5000;
 
-		if(!clients.empty())
-			infostream<<"Players:"<<std::endl;
+		if (print && !clients.empty())
+			infostream<<"Players ["<<clients.size()<<"]:"<<std::endl;
 
-		for(std::vector<u16>::iterator
+		for(auto
 			i = clients.begin();
 			i != clients.end(); ++i) {
 			Player *player = m_env->getPlayer(*i);
@@ -667,20 +907,40 @@
 			if (player == NULL)
 				continue;
 
+		  if (print) {
 			infostream << "* " << player->getName() << "\t";
 
 			{
-				MutexAutoLock clientslock(m_clients_mutex);
+				//MutexAutoLock clientslock(m_clients_mutex);
 				RemoteClient* client = lockedGetClientNoEx(*i);
 				if(client != NULL)
 					client->PrintInfo(infostream);
 			}
+		  }
 
 			m_clients_names.push_back(player->getName());
 		}
 	}
 }
 
+
+
+#if !MINETEST_PROTO
+void ClientInterface::send(u16 peer_id,u8 channelnum,
+		SharedBuffer<u8> data, bool reliable)
+{
+	m_con->Send(peer_id, channelnum, data, reliable);
+}
+
+void ClientInterface::send(u16 peer_id,u8 channelnum,
+		const msgpack::sbuffer &buffer, bool reliable)
+{
+	SharedBuffer<u8> data((unsigned char*)buffer.data(), buffer.size());
+	send(peer_id, channelnum, data, reliable);
+}
+#endif
+
+#if MINETEST_PROTO
 void ClientInterface::send(u16 peer_id, u8 channelnum,
 		NetworkPacket* pkt, bool reliable)
 {
@@ -690,11 +950,12 @@
 void ClientInterface::sendToAll(u16 channelnum,
 		NetworkPacket* pkt, bool reliable)
 {
-	MutexAutoLock clientslock(m_clients_mutex);
-	for(std::map<u16, RemoteClient*>::iterator
+	auto clientslock = m_clients.lock_shared_rec();
+	for(auto
 		i = m_clients.begin();
-		i != m_clients.end(); ++i) {
-		RemoteClient *client = i->second;
+		i != m_clients.end(); ++i)
+	{
+		RemoteClient *client = i->second.get();
 
 		if (client->net_proto_version != 0) {
 			m_con->Send(client->peer_id, channelnum, pkt, reliable);
@@ -702,11 +963,43 @@
 	}
 }
 
+#else
+
+void ClientInterface::sendToAll(u16 channelnum,
+		SharedBuffer<u8> data, bool reliable)
+{
+	auto lock = m_clients.lock_shared_rec();
+	for(auto
+		i = m_clients.begin();
+		i != m_clients.end(); ++i)
+	{
+		RemoteClient *client = i->second.get();
+
+		if (client->net_proto_version != 0)
+		{
+			m_con->Send(client->peer_id, channelnum, data, reliable);
+		}
+	}
+}
+
+void ClientInterface::sendToAll(u16 channelnum,
+		const msgpack::sbuffer &buffer, bool reliable)
+{
+	SharedBuffer<u8> data((unsigned char*)buffer.data(), buffer.size());
+	sendToAll(channelnum, data, reliable);
+}
+#endif
+
+//TODO: return here shared_ptr
 RemoteClient* ClientInterface::getClientNoEx(u16 peer_id, ClientState state_min)
 {
-	MutexAutoLock clientslock(m_clients_mutex);
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
+	auto client = getClient(peer_id, state_min);
+	return client.get();
+}
+
+std::shared_ptr<RemoteClient> ClientInterface::getClient(u16 peer_id, ClientState state_min) {
+	auto clientslock = m_clients.lock_shared_rec();
+	auto n = m_clients.find(peer_id);
 	// The client may not exist; clients are immediately removed if their
 	// access is denied, and this event occurs later then.
 	if(n == m_clients.end())
@@ -720,24 +1013,13 @@
 
 RemoteClient* ClientInterface::lockedGetClientNoEx(u16 peer_id, ClientState state_min)
 {
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
-	// The client may not exist; clients are immediately removed if their
-	// access is denied, and this event occurs later then.
-	if(n == m_clients.end())
-		return NULL;
-
-	if (n->second->getState() >= state_min)
-		return n->second;
-	else
-		return NULL;
+	return getClientNoEx(peer_id, state_min);
 }
 
 ClientState ClientInterface::getClientState(u16 peer_id)
 {
-	MutexAutoLock clientslock(m_clients_mutex);
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
+	auto clientslock = m_clients.lock_shared_rec();
+	auto n = m_clients.find(peer_id);
 	// The client may not exist; clients are immediately removed if their
 	// access is denied, and this event occurs later then.
 	if(n == m_clients.end())
@@ -748,80 +1030,65 @@
 
 void ClientInterface::setPlayerName(u16 peer_id,std::string name)
 {
-	MutexAutoLock clientslock(m_clients_mutex);
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
-	// The client may not exist; clients are immediately removed if their
-	// access is denied, and this event occurs later then.
-	if(n != m_clients.end())
-		n->second->setName(name);
+	auto client = getClient(peer_id, CS_Invalid);
+	if(!client)
+		return;
+
+	client->setName(name);
 }
 
 void ClientInterface::DeleteClient(u16 peer_id)
 {
-	MutexAutoLock conlock(m_clients_mutex);
-
-	// Error check
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
-	// The client may not exist; clients are immediately removed if their
-	// access is denied, and this event occurs later then.
-	if(n == m_clients.end())
+	auto client = getClient(peer_id, CS_Invalid);
+	if(!client)
 		return;
 
 	/*
 		Mark objects to be not known by the client
 	*/
 	//TODO this should be done by client destructor!!!
-	RemoteClient *client = n->second;
 	// Handle objects
-	for(std::set<u16>::iterator
+	{
+	auto lock = client->m_known_objects.lock_unique_rec();
+	for(auto
 			i = client->m_known_objects.begin();
 			i != client->m_known_objects.end(); ++i)
 	{
 		// Get object
-		u16 id = *i;
-		ServerActiveObject* obj = m_env->getActiveObject(id);
+		u16 id = i->first;
+		ServerActiveObject* obj = m_env->getActiveObject(id, true);
 
 		if(obj && obj->m_known_by_count > 0)
 			obj->m_known_by_count--;
 	}
+	}
 
 	// Delete client
-	delete m_clients[peer_id];
+	//delete m_clients.get(peer_id);
 	m_clients.erase(peer_id);
 }
 
 void ClientInterface::CreateClient(u16 peer_id)
 {
-	MutexAutoLock conlock(m_clients_mutex);
-
-	// Error check
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
-	// The client shouldn't already exist
-	if(n != m_clients.end()) return;
+	{
+		auto client = getClient(peer_id, CS_Invalid);
+		if(client)
+			return;
+	}
 
 	// Create client
-	RemoteClient *client = new RemoteClient();
+	auto client = std::shared_ptr<RemoteClient>(new RemoteClient(m_env));
 	client->peer_id = peer_id;
-	m_clients[client->peer_id] = client;
+	m_clients.set(client->peer_id, client);
 }
 
 void ClientInterface::event(u16 peer_id, ClientStateEvent event)
 {
-	{
-		MutexAutoLock clientlock(m_clients_mutex);
+	auto client = getClient(peer_id, CS_Invalid);
+	if(!client)
+		return;
 
-		// Error check
-		std::map<u16, RemoteClient*>::iterator n;
-		n = m_clients.find(peer_id);
-
-		// No client to deliver event
-		if (n == m_clients.end())
-			return;
-		n->second->notifyEvent(event);
-	}
+	client->notifyEvent(event);
 
 	if ((event == CSE_SetClientReady) ||
 		(event == CSE_Disconnect)     ||
@@ -833,30 +1100,18 @@
 
 u16 ClientInterface::getProtocolVersion(u16 peer_id)
 {
-	MutexAutoLock conlock(m_clients_mutex);
-
-	// Error check
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
-
-	// No client to get version
-	if (n == m_clients.end())
+	auto client = getClient(peer_id, CS_Invalid);
+	if(!client)
 		return 0;
 
-	return n->second->net_proto_version;
+	return client->net_proto_version;
 }
 
 void ClientInterface::setClientVersion(u16 peer_id, u8 major, u8 minor, u8 patch, std::string full)
 {
-	MutexAutoLock conlock(m_clients_mutex);
-
-	// Error check
-	std::map<u16, RemoteClient*>::iterator n;
-	n = m_clients.find(peer_id);
-
-	// No client to set versions
-	if (n == m_clients.end())
+	auto client = getClient(peer_id, CS_Invalid);
+	if(!client)
 		return;
 
-	n->second->setVersionInfo(major,minor,patch,full);
+	client->setVersionInfo(major,minor,patch,full);
 }
