diff -ruN minetest-master/src/noise.cpp minetest-freeminer/src/noise.cpp
--- minetest-master/src/noise.cpp	2016-09-03 16:15:52.609779000 -0700
+++ minetest-freeminer/src/noise.cpp	2016-09-03 15:43:59.934741000 -0700
@@ -1,27 +1,25 @@
 /*
- * Minetest
+noise.cpp
  * Copyright (C) 2010-2014 celeron55, Perttu Ahola <celeron55@gmail.com>
  * Copyright (C) 2010-2014 kwolekr, Ryan Kwolek <kwolekr@minetest.net>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are
- * permitted provided that the following conditions are met:
- *  1. Redistributions of source code must retain the above copyright notice, this list of
- *     conditions and the following disclaimer.
- *  2. Redistributions in binary form must reproduce the above copyright notice, this list
- *     of conditions and the following disclaimer in the documentation and/or other materials
- *     provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
+*/
+
+/*
+This file is part of Freeminer.
+
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Freeminer  is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
+*/
 
 #include <math.h>
 #include "noise.h"
@@ -29,8 +27,10 @@
 #include <string.h> // memset
 #include "debug.h"
 #include "util/numeric.h"
+#include "constants.h"
 #include "util/string.h"
 #include "exceptions.h"
+#include "log_types.h"
 
 #define NOISE_MAGIC_X    1619
 #define NOISE_MAGIC_Y    31337
@@ -128,7 +128,7 @@
 s32 PcgRandom::range(s32 min, s32 max)
 {
 	if (max < min)
-		throw PrngException("Invalid range (max < min)");
+		throw PrngException("Invalid range (max < min) min=" + std::to_string(min) + " max=" + std::to_string(max));
 
 	u32 bound = max - min + 1;
 	return range(bound) + min;
@@ -170,6 +170,7 @@
 	unsigned int n = (NOISE_MAGIC_X * x + NOISE_MAGIC_Y * y
 			+ NOISE_MAGIC_SEED * seed) & 0x7fffffff;
 	n = (n >> 13) ^ n;
+
 	n = (n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;
 	return 1.f - (float)(int)n / 0x40000000;
 }
@@ -370,16 +371,29 @@
 
 
 ///////////////////////// [ New noise ] ////////////////////////////
+	std::ostream & operator<<(std::ostream & os, NoiseParams & np)
+	 {
+		os << "noiseprms[offset="<<np.offset<<",scale="<<np.scale<<",spread="<<np.spread<<",seed="<<np.seed<<",octaves="<<np.octaves<<",persist="<<np.persist<<",lacunarity="<<np.lacunarity<<",flags="<<np.flags
+		<<",farscale="<<np.far_scale<<",farspread="<<np.far_spread<<",farpersist="<<np.far_persist<<",farlacunarity="<<np.far_lacunarity
+		<<"]";
+		return os;
+	}
+
 
 
 float NoisePerlin2D(NoiseParams *np, float x, float y, s32 seed)
 {
+	auto far_scale = farscale(np->far_scale, x, y);
+	auto far_spread = farscale(np->far_spread, x, y);
+	auto far_lacunarity = farscale(np->far_lacunarity, x, y);
+	auto far_persist = farscale(np->far_persist, x, y);
+
 	float a = 0;
 	float f = 1.0;
 	float g = 1.0;
 
-	x /= np->spread.X;
-	y /= np->spread.Y;
+	x /= np->spread.X * far_spread;
+	y /= np->spread.Y * far_spread;
 	seed += np->seed;
 
 	for (size_t i = 0; i < np->octaves; i++) {
@@ -390,23 +404,28 @@
 			noiseval = fabs(noiseval);
 
 		a += g * noiseval;
-		f *= np->lacunarity;
-		g *= np->persist;
+		f *= np->lacunarity * far_lacunarity;
+		g *= np->persist * far_persist;
 	}
 
-	return np->offset + a * np->scale;
+	return np->offset + a * np->scale * far_scale;
 }
 
 
 float NoisePerlin3D(NoiseParams *np, float x, float y, float z, s32 seed)
 {
+	auto far_scale = farscale(np->far_scale, x, y, z);
+	auto far_spread = farscale(np->far_spread, x, y, z);
+	auto far_lacunarity = farscale(np->far_lacunarity, x, y, z);
+	auto far_persist = farscale(np->far_persist, x, y, z);
+
 	float a = 0;
 	float f = 1.0;
 	float g = 1.0;
 
-	x /= np->spread.X;
-	y /= np->spread.Y;
-	z /= np->spread.Z;
+	x /= np->spread.X * far_spread;
+	y /= np->spread.Y * far_spread;
+	z /= np->spread.Z * far_spread;
 	seed += np->seed;
 
 	for (size_t i = 0; i < np->octaves; i++) {
@@ -417,11 +436,11 @@
 			noiseval = fabs(noiseval);
 
 		a += g * noiseval;
-		f *= np->lacunarity;
-		g *= np->persist;
+		f *= np->lacunarity * far_lacunarity;
+		g *= np->persist * far_persist;
 	}
 
-	return np->offset + a * np->scale;
+	return np->offset + a * np->scale * far_scale;
 }
 
 
@@ -447,6 +466,11 @@
 	delete[] persist_buf;
 	delete[] noise_buf;
 	delete[] result;
+
+	gradient_buf = nullptr;
+	persist_buf = nullptr;
+	noise_buf = nullptr;
+	result = nullptr;
 }
 
 
@@ -706,11 +730,16 @@
 
 float *Noise::perlinMap2D(float x, float y, float *persistence_map)
 {
+	auto far_scale = farscale(np.far_scale, x, y);
+	auto far_spread = farscale(np.far_spread, x, y);
+	auto far_lacunarity = farscale(np.far_lacunarity, x, y);
+	auto far_persist = farscale(np.far_persist, x, y);
+
 	float f = 1.0, g = 1.0;
 	size_t bufsize = sx * sy;
 
-	x /= np.spread.X;
-	y /= np.spread.Y;
+	x /= np.spread.X * far_spread;
+	y /= np.spread.Y * far_spread;
 
 	memset(result, 0, sizeof(float) * bufsize);
 
@@ -723,18 +752,18 @@
 
 	for (size_t oct = 0; oct < np.octaves; oct++) {
 		gradientMap2D(x * f, y * f,
-			f / np.spread.X, f / np.spread.Y,
+			f / (np.spread.X * far_spread), f / (np.spread.Y * far_spread),
 			seed + np.seed + oct);
 
 		updateResults(g, persist_buf, persistence_map, bufsize);
 
-		f *= np.lacunarity;
-		g *= np.persist;
+		f *= np.lacunarity * far_lacunarity;
+		g *= np.persist * far_persist;
 	}
 
 	if (fabs(np.offset - 0.f) > 0.00001 || fabs(np.scale - 1.f) > 0.00001) {
 		for (size_t i = 0; i != bufsize; i++)
-			result[i] = result[i] * np.scale + np.offset;
+			result[i] = result[i] * np.scale * far_scale + np.offset;
 	}
 
 	return result;
@@ -743,12 +772,17 @@
 
 float *Noise::perlinMap3D(float x, float y, float z, float *persistence_map)
 {
+	auto far_scale = farscale(np.far_scale, x, y, z);
+	auto far_spread = farscale(np.far_spread, x, y, z);
+	auto far_lacunarity = farscale(np.far_lacunarity, x, y, z);
+	auto far_persist = farscale(np.far_persist, x, y, z);
+
 	float f = 1.0, g = 1.0;
 	size_t bufsize = sx * sy * sz;
 
-	x /= np.spread.X;
-	y /= np.spread.Y;
-	z /= np.spread.Z;
+	x /= np.spread.X * far_spread;
+	y /= np.spread.Y * far_spread;
+	z /= np.spread.Z * far_spread;
 
 	memset(result, 0, sizeof(float) * bufsize);
 
@@ -761,18 +795,18 @@
 
 	for (size_t oct = 0; oct < np.octaves; oct++) {
 		gradientMap3D(x * f, y * f, z * f,
-			f / np.spread.X, f / np.spread.Y, f / np.spread.Z,
+			f / (np.spread.X * far_spread), f / (np.spread.Y * far_spread), f / (np.spread.Z * far_spread),
 			seed + np.seed + oct);
 
 		updateResults(g, persist_buf, persistence_map, bufsize);
 
-		f *= np.lacunarity;
-		g *= np.persist;
+		f *= np.lacunarity * far_lacunarity;
+		g *= np.persist * far_persist;
 	}
 
 	if (fabs(np.offset - 0.f) > 0.00001 || fabs(np.scale - 1.f) > 0.00001) {
 		for (size_t i = 0; i != bufsize; i++)
-			result[i] = result[i] * np.scale + np.offset;
+			result[i] = result[i] * np.scale * far_scale + np.offset;
 	}
 
 	return result;
@@ -806,3 +840,16 @@
 		}
 	}
 }
+
+float farscale(float scale, float z) {
+	return ( 1 + ( 1 - (MAX_MAP_GENERATION_LIMIT * 1 - (fabs(z))                     ) / (MAX_MAP_GENERATION_LIMIT * 1) ) * (scale - 1) );
+}
+
+float farscale(float scale, float x, float z) {
+	return ( 1 + ( 1 - (MAX_MAP_GENERATION_LIMIT * 2 - (fabs(x) + fabs(z))           ) / (MAX_MAP_GENERATION_LIMIT * 2) ) * (scale - 1) );
+}
+
+float farscale(float scale, float x, float y, float z) {
+	return ( 1 + ( 1 - (MAX_MAP_GENERATION_LIMIT * 3 - (fabs(x) + fabs(y) + fabs(z)) ) / (MAX_MAP_GENERATION_LIMIT * 3) ) * (scale - 1) );
+}
+
