diff -ruN minetest-master/src/util/string.cpp minetest-freeminer/src/util/string.cpp
--- minetest-master/src/util/string.cpp	2016-09-03 16:15:52.493778000 -0700
+++ minetest-freeminer/src/util/string.cpp	2016-09-03 15:43:59.866740000 -0700
@@ -1,34 +1,154 @@
 /*
-Minetest
+util/string.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "string.h"
 #include "pointer.h"
 #include "numeric.h"
-#include "log.h"
+
+#include <cctype>
 
 #include "hex.h"
 #include "../porting.h"
+#include "../log.h"
+
+#include "../config.h"
+
+#if defined(_WIN32)
+
+#include <windows.h>
+
+std::wstring narrow_to_wide(const std::string &input) {
+	size_t outbuf_size = input.size() + 1;
+	wchar_t *outbuf = new wchar_t[outbuf_size];
+	memset(outbuf, 0, outbuf_size * sizeof(wchar_t));
+	MultiByteToWideChar(CP_UTF8, 0, input.c_str(), input.size(), outbuf, outbuf_size);
+	std::wstring out(outbuf);
+	delete[] outbuf;
+	return out;
+}
+
+std::string wide_to_narrow(const std::wstring &input) {
+	size_t outbuf_size = (input.size() + 1) * 6;
+	char *outbuf = new char[outbuf_size];
+	memset(outbuf, 0, outbuf_size);
+	WideCharToMultiByte(CP_UTF8, 0, input.c_str(), input.size(), outbuf, outbuf_size, NULL, NULL);
+	std::string out(outbuf);
+	delete[] outbuf;
+	return out;
+}
+
+#elif USE_ICONV
+
+#include <iconv.h>
+
+size_t convert(const char *to, const char *from, char *outbuf, size_t outbuf_size, char *inbuf, size_t inbuf_size) {
+	iconv_t cd = iconv_open(to, from);
+
+	char *inbuf_ptr = inbuf;
+	char *outbuf_ptr = outbuf;
+
+	size_t *inbuf_left_ptr = &inbuf_size;
+	size_t *outbuf_left_ptr = &outbuf_size;
+
+	while (inbuf_size > 0)
+		iconv(cd, sloppy<char**>(&inbuf_ptr), inbuf_left_ptr, &outbuf_ptr, outbuf_left_ptr);
+
+	iconv_close(cd);
+	return 0;
+}
+
+std::wstring narrow_to_wide(const std::string &input) {
+	size_t inbuf_size = input.length() + 1;
+	// maximum possible size, every character is sizeof(wchar_t) bytes
+	size_t outbuf_size = (input.length() + 1) * (sizeof(wchar_t)+2);
+
+	char *inbuf = new char[inbuf_size];
+	memcpy(inbuf, input.c_str(), inbuf_size);
+	char *outbuf = new char[outbuf_size];
+	memset(outbuf, 0, outbuf_size);
+
+	convert("WCHAR_T", "UTF-8", outbuf, outbuf_size, inbuf, inbuf_size);
+	std::wstring out((wchar_t*)outbuf);
+
+	delete[] inbuf;
+	delete[] outbuf;
+
+	return out;
+}
+
+std::string wide_to_narrow(const std::wstring &input) {
+	size_t inbuf_size = (input.length() + 1) * sizeof(wchar_t);
+	// maximum possible size: utf-8 encodes codepoints using 1 up to 6 bytes
+	size_t outbuf_size = (input.length() + 1) * 6;
+
+	char *inbuf = new char[inbuf_size];
+	memcpy(inbuf, input.c_str(), inbuf_size);
+	char *outbuf = new char[outbuf_size];
+	memset(outbuf, 0, outbuf_size);
+
+	convert("UTF-8", "WCHAR_T", outbuf, outbuf_size, inbuf, inbuf_size);
+	std::string out(outbuf);
+
+	delete[] inbuf;
+	delete[] outbuf;
+
+	return out;
+}
+
+#else
+
+#include "utf8.cpp"
+
+std::wstring narrow_to_wide(const std::string &input) {
+	size_t outbuf_size = input.size() + 1;
+	wchar_t *outbuf = new wchar_t[outbuf_size];
+	memset(outbuf, 0, outbuf_size * sizeof(wchar_t));
+	/* irr::core:: */ utf8ToWchar(input.c_str(), outbuf, outbuf_size * sizeof(wchar_t));
+	std::wstring out(outbuf);
+	delete[] outbuf;
+	return out;
+}
+
+std::string wide_to_narrow(const std::wstring &input) {
+	size_t outbuf_size = (input.size() + 1) * 6;
+	char *outbuf = new char[outbuf_size];
+	memset(outbuf, 0, outbuf_size);
+	size_t inbuf_size = (input.length() + 1);
+	wchar_t *inbuf = new wchar_t[inbuf_size];
+	memcpy(inbuf, input.c_str(), inbuf_size * sizeof(wchar_t));
+	/* irr::core:: */ wcharToUtf8(inbuf, outbuf, outbuf_size);
+	std::string out(outbuf);
+	delete[] outbuf;
+	delete[] inbuf;
+	return out;
+}
+
+#endif
 
 #include <sstream>
 #include <iomanip>
 #include <map>
 
+/*
 #ifndef _WIN32
 	#include <iconv.h>
 #else
@@ -40,10 +160,15 @@
 	defined(__OpenBSD__) || defined(__DragonFly__))
 	#define BSD_ICONV_USED
 #endif
+*/
 
 static bool parseHexColorString(const std::string &value, video::SColor &color);
 static bool parseNamedColorString(const std::string &value, video::SColor &color);
 
+std::wstring utf8_to_wide(const std::string &input) { return narrow_to_wide(input); };
+std::string wide_to_utf8(const std::wstring &input) { return wide_to_narrow(input); };
+
+/*
 #ifndef _WIN32
 
 bool convert(const char *to, const char *from, char *outbuf,
@@ -163,6 +288,7 @@
 }
 
 #endif // _WIN32
+*/
 
 wchar_t *utf8_to_wide_c(const char *str)
 {
@@ -201,13 +327,18 @@
 
 
 #ifdef __ANDROID__
+int wctomb(char *s, wchar_t wc) { return wcrtomb(s,wc,NULL); }
+int mbtowc(wchar_t *pwc, const char *s, size_t n) { return mbrtowc(pwc, s, n, NULL); }
+#endif
 
-const wchar_t* wide_chars =
+#ifdef __ANDROID__
+
+const wchar_t wide_chars[] =
 	L" !\"#$%&'()*+,-./0123456789:;<=>?@"
 	L"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
 	L"abcdefghijklmnopqrstuvwxyz{|}~";
 
-int wctomb(char *s, wchar_t wc)
+int NOT_USED_wctomb(char *s, wchar_t wc)
 {
 	for (unsigned int j = 0; j < (sizeof(wide_chars)/sizeof(wchar_t));j++) {
 		if (wc == wide_chars[j]) {
@@ -222,7 +353,7 @@
 	return -1;
 }
 
-int mbtowc(wchar_t *pwc, const char *s, size_t n)
+int NOT_USED_mbtowc(wchar_t *pwc, const char *s, size_t n)
 {
 	std::wstring intermediate = narrow_to_wide(s);
 
@@ -235,7 +366,7 @@
 	}
 }
 
-std::wstring narrow_to_wide(const std::string &mbs) {
+std::wstring narrow_to_wide_real(const std::string &mbs) {
 	size_t wcl = mbs.size();
 
 	std::wstring retval = L"";
@@ -257,7 +388,7 @@
 
 #else // not Android
 
-std::wstring narrow_to_wide(const std::string &mbs)
+std::wstring narrow_to_wide_real(const std::string &mbs)
 {
 	size_t wcl = mbs.size();
 	Buffer<wchar_t> wcs(wcl + 1);
@@ -272,7 +403,7 @@
 
 #ifdef __ANDROID__
 
-std::string wide_to_narrow(const std::wstring &wcs) {
+std::string wide_to_narrow_real(const std::wstring &wcs) {
 	size_t mbl = wcs.size()*4;
 
 	std::string retval = "";
@@ -300,7 +431,7 @@
 
 #else // not Android
 
-std::string wide_to_narrow(const std::wstring &wcs)
+std::string wide_to_narrow_real(const std::wstring &wcs)
 {
 	size_t mbl = wcs.size() * 4;
 	SharedBuffer<char> mbs(mbl+1);
@@ -353,6 +484,8 @@
 
 u32 readFlagString(std::string str, const FlagDesc *flagdesc, u32 *flagmask)
 {
+	if (str.length() == 0)
+		return 0;
 	u32 result = 0;
 	u32 mask = 0;
 	char *s = &str[0];
@@ -732,6 +865,55 @@
 	return true;
 }
 
+//freeminer:
+
+std::wstring colorizeText(const std::wstring &s, std::vector<video::SColor> &colors, const video::SColor &initial_color) {
+	std::wstring output;
+	colors.clear();
+	size_t i = 0;
+	video::SColor color = initial_color;
+	while (i < s.length()) {
+		if (s[i] == L'\v' && i + 7 < s.length()) {
+			parseColorString(wide_to_narrow(s.substr(i + 1, 7)), color);
+			i += 8;
+			continue;
+		}
+		output += s[i];
+		colors.push_back(color);
+
+		++i;
+	}
+
+	return output;
+}
+
+// removes escape sequences
+std::wstring sanitizeChatString(const std::wstring &s) {
+	std::wstring output;
+	size_t i = 0;
+	while (i < s.length()) {
+		if (s[i] == L'\v') {
+			i += 7;
+			continue;
+		}
+		output += s[i];
+		++i;
+	}
+	return output;
+}
+
+bool char_icompare(char c1, char c2)
+{
+	return (std::tolower(static_cast<unsigned char>(c1)) <std::tolower(static_cast<unsigned char>(c2)));
+}
+
+bool string_icompare(const std::string& a, const std::string& b)
+{
+	return std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end(), char_icompare);
+}
+//== eofreeminer
+
+
 void str_replace(std::string &str, char from, char to)
 {
 	std::replace(str.begin(), str.end(), from, to);
