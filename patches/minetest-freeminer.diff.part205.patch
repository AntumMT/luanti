diff -ruN minetest-master/src/content_sao.cpp minetest-freeminer/src/content_sao.cpp
--- minetest-master/src/content_sao.cpp	2016-09-03 16:15:52.609779000 -0700
+++ minetest-freeminer/src/content_sao.cpp	2016-09-03 15:43:59.762740000 -0700
@@ -1,20 +1,23 @@
 /*
-Minetest
+content_sao.cpp
 Copyright (C) 2010-2013 celeron55, Perttu Ahola <celeron55@gmail.com>
+*/
+
+/*
+This file is part of Freeminer.
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation; either version 2.1 of the License, or
+Freeminer is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
+Freeminer  is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
+GNU General Public License for more details.
 
-You should have received a copy of the GNU Lesser General Public License along
-with this program; if not, write to the Free Software Foundation, Inc.,
-51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+You should have received a copy of the GNU General Public License
+along with Freeminer.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "content_sao.h"
@@ -30,7 +33,7 @@
 #include "server.h"
 #include "scripting_game.h"
 #include "genericobject.h"
-#include "log.h"
+#include "log_types.h"
 
 std::map<u16, ServerActiveObject::Factory> ServerActiveObject::m_types;
 
@@ -66,9 +69,11 @@
 			return;
 		}
 
+		auto m_base_position = getBasePosition();
 		m_base_position.Y += dtime * BS * 2;
 		if(m_base_position.Y > 8*BS)
 			m_base_position.Y = 2*BS;
+		setBasePosition(m_base_position);
 
 		if(send_recommended == false)
 			return;
@@ -122,11 +127,9 @@
 	m_init_name(name),
 	m_init_state(state),
 	m_registered(false),
-	m_hp(-1),
 	m_velocity(0,0,0),
 	m_acceleration(0,0,0),
 	m_yaw(0),
-	m_properties_sent(true),
 	m_last_sent_yaw(0),
 	m_last_sent_position(0,0,0),
 	m_last_sent_velocity(0,0,0),
@@ -141,6 +144,8 @@
 	m_attachment_parent_id(0),
 	m_attachment_sent(false)
 {
+	m_hp = -1;
+	m_properties_sent = true;
 	// Only register type if no environment supplied
 	if(env == NULL){
 		ServerActiveObject::registerType(getType(), create);
@@ -206,8 +211,10 @@
 		}
 	}
 	// create object
+/*
 	infostream<<"LuaEntitySAO::create(name=\""<<name<<"\" state=\""
 			<<state<<"\")"<<std::endl;
+*/
 	LuaEntitySAO *sao = new LuaEntitySAO(env, pos, name, state);
 	sao->m_hp = hp;
 	sao->m_velocity = velocity;
@@ -230,11 +237,11 @@
 {
 	if(!m_properties_sent)
 	{
-		m_properties_sent = true;
 		std::string str = getPropertyPacket();
 		// create message and add to list
 		ActiveObjectMessage aom(getId(), true, str);
 		m_messages_out.push(aom);
+		m_properties_sent = true;
 	}
 
 	// If attached, check that our parent is still there. If it isn't, detach.
@@ -254,7 +261,7 @@
 	if(isAttached())
 	{
 		v3f pos = m_env->getActiveObject(m_attachment_parent_id)->getBasePosition();
-		m_base_position = pos;
+		setBasePosition(pos);
 		m_velocity = v3f(0,0,0);
 		m_acceleration = v3f(0,0,0);
 	}
@@ -266,7 +273,7 @@
 			box.MaxEdge *= BS;
 			collisionMoveResult moveresult;
 			f32 pos_max_d = BS*0.25; // Distance per iteration
-			v3f p_pos = m_base_position;
+			v3f p_pos = getBasePosition();
 			v3f p_velocity = m_velocity;
 			v3f p_acceleration = m_acceleration;
 			moveresult = collisionMoveSimple(m_env,m_env->getGameDef(),
@@ -275,12 +282,14 @@
 					this, m_prop.collideWithObjects);
 
 			// Apply results
-			m_base_position = p_pos;
+			setBasePosition(p_pos);
 			m_velocity = p_velocity;
 			m_acceleration = p_acceleration;
 		} else {
-			m_base_position += dtime * m_velocity + 0.5 * dtime
+			v3f p_pos = getBasePosition();
+			p_pos += dtime * m_velocity + 0.5 * dtime
 					* dtime * m_acceleration;
+			setBasePosition(p_pos);
 			m_velocity += dtime * m_acceleration;
 		}
 
@@ -302,7 +311,9 @@
 		}
 	}
 
-	if(m_registered){
+	if(m_registered && (getType() < ACTIVEOBJECT_TYPE_LUACREATURE
+			|| getType() > ACTIVEOBJECT_TYPE_LUAFALLING)) {
+
 		m_env->getScriptIface()->luaentity_Step(m_id, dtime);
 	}
 
@@ -318,7 +329,7 @@
 		} else if(m_last_sent_position_timer > 0.2){
 			minchange = 0.05*BS;
 		}
-		float move_d = m_base_position.getDistanceFrom(m_last_sent_position);
+		float move_d = getBasePosition().getDistanceFrom(m_last_sent_position);
 		move_d += m_last_sent_move_precision;
 		float vel_d = m_velocity.getDistanceFrom(m_last_sent_velocity);
 		if(move_d > minchange || vel_d > minchange ||
@@ -368,13 +379,16 @@
 {
 	std::ostringstream os(std::ios::binary);
 
+	auto lock = lock_shared_rec();
+	try {
+
 	if(protocol_version >= 14)
 	{
 		writeU8(os, 1); // version
 		os<<serializeString(""); // name
 		writeU8(os, 0); // is_player
 		writeS16(os, getId()); //id
-		writeV3F1000(os, m_base_position);
+		writeV3F1000(os, getBasePosition());
 		writeF1000(os, m_yaw);
 		writeS16(os, m_hp);
 
@@ -393,7 +407,7 @@
 		writeU8(os, 0); // version
 		os<<serializeString(""); // name
 		writeU8(os, 0); // is_player
-		writeV3F1000(os, m_base_position);
+		writeV3F1000(os, getBasePosition());
 		writeF1000(os, m_yaw);
 		writeS16(os, m_hp);
 		writeU8(os, 2); // number of messages stuffed in here
@@ -401,13 +415,20 @@
 		os<<serializeLongString(gob_cmd_update_armor_groups(m_armor_groups)); // 2
 	}
 
+	} catch (std::exception &e){
+		errorstream << "Catn serialize object id="<<getId()<< " pos="<< getBasePosition() << std::endl;
+		return "";
+	}
+
 	// return result
 	return os.str();
 }
 
 std::string LuaEntitySAO::getStaticData()
 {
+/*
 	verbosestream<<FUNCTION_NAME<<std::endl;
+*/
 	std::ostringstream os(std::ios::binary);
 	// version
 	writeU8(os, 1);
@@ -498,7 +519,7 @@
 {
 	if(isAttached())
 		return;
-	m_base_position = pos;
+	setBasePosition(pos);
 	sendPosition(false, true);
 }
 
@@ -506,7 +527,7 @@
 {
 	if(isAttached())
 		return;
-	m_base_position = pos;
+	setBasePosition(pos);
 	if(!continuous)
 		sendPosition(true, true);
 }
@@ -540,6 +561,7 @@
 
 void LuaEntitySAO::setArmorGroups(const ItemGroupList &armor_groups)
 {
+	auto lock = lock_unique_rec();
 	m_armor_groups = armor_groups;
 	m_armor_groups_sent = false;
 }
@@ -697,18 +719,18 @@
 	if(isAttached())
 		return;
 
-	m_last_sent_move_precision = m_base_position.getDistanceFrom(
+	m_last_sent_move_precision = getBasePosition().getDistanceFrom(
 			m_last_sent_position);
 	m_last_sent_position_timer = 0;
 	m_last_sent_yaw = m_yaw;
-	m_last_sent_position = m_base_position;
+	m_last_sent_position = getBasePosition();
 	m_last_sent_velocity = m_velocity;
 	//m_last_sent_acceleration = m_acceleration;
 
 	float update_interval = m_env->getSendRecommendedInterval();
 
 	std::string str = gob_cmd_update_position(
-		m_base_position,
+		getBasePosition(),
 		m_velocity,
 		m_acceleration,
 		m_yaw,
@@ -728,8 +750,8 @@
 		toset->MinEdge = m_prop.collisionbox.MinEdge * BS;
 		toset->MaxEdge = m_prop.collisionbox.MaxEdge * BS;
 
-		toset->MinEdge += m_base_position;
-		toset->MaxEdge += m_base_position;
+		toset->MinEdge += getBasePosition();
+		toset->MaxEdge += getBasePosition();
 
 		return true;
 	}
@@ -759,15 +781,11 @@
 	m_nocheat_dig_pos(32767, 32767, 32767),
 	m_nocheat_dig_time(0),
 	m_wield_index(0),
-	m_position_not_sent(false),
-	m_armor_groups_sent(false),
-	m_properties_sent(true),
 	m_privs(privs),
 	m_is_singleplayer(is_singleplayer),
 	m_animation_speed(0),
 	m_animation_blend(0),
 	m_animation_loop(true),
-	m_animation_sent(false),
 	m_bone_position_sent(false),
 	m_attachment_parent_id(0),
 	m_attachment_sent(false),
@@ -776,12 +794,24 @@
 	m_physics_override_jump(1),
 	m_physics_override_gravity(1),
 	m_physics_override_sneak(true),
-	m_physics_override_sneak_glitch(true),
-	m_physics_override_sent(false)
+	m_physics_override_sneak_glitch(true)
 {
-	assert(m_player);	// pre-condition
-	assert(m_peer_id != 0);	// pre-condition
-	setBasePosition(m_player->getPosition());
+	m_properties_sent = true;
+	m_position_not_sent = false;
+	m_ms_from_last_respawn = 10000; //more than ignore move time (1)
+	m_physics_override_sent = false;
+	m_animation_sent = false;
+	m_armor_groups_sent = false;
+
+	//assert(m_player);	// pre-condition
+	//assert(m_peer_id != 0);	// pre-condition
+	++m_player->refs;
+	//setBasePosition(m_player->getPosition()); // deadlock?
+	if (m_player)
+		//m_base_position = m_player->getPosition();
+		m_base_position = m_player->m_position;
+	m_position_not_sent = true;
+	if (m_player)
 	m_inventory = &m_player->inventory;
 	m_armor_groups["fleshy"] = 100;
 
@@ -805,13 +835,18 @@
 
 PlayerSAO::~PlayerSAO()
 {
+	if (!m_player)
+		return;
 	if(m_inventory != &m_player->inventory)
 		delete m_inventory;
+	--m_player->refs;
 
 }
 
 std::string PlayerSAO::getDescription()
 {
+	if (!m_player)
+		return "";
 	return std::string("player ") + m_player->getName();
 }
 
@@ -819,6 +854,10 @@
 void PlayerSAO::addedToEnvironment(u32 dtime_s)
 {
 	ServerActiveObject::addedToEnvironment(dtime_s);
+	if (!m_player) {
+		errorstream << "PlayerSAO::addedToEnvironment(): Fail id=" << m_peer_id << std::endl;
+		return;
+	}
 	ServerActiveObject::setBasePosition(m_player->getPosition());
 	m_player->setPlayerSAO(this);
 	m_player->peer_id = m_peer_id;
@@ -829,12 +868,16 @@
 void PlayerSAO::removingFromEnvironment()
 {
 	ServerActiveObject::removingFromEnvironment();
-	if(m_player->getPlayerSAO() == this)
+	if(m_player && m_player->getPlayerSAO() == this)
 	{
 		m_player->setPlayerSAO(NULL);
 		m_player->peer_id = 0;
 		m_env->savePlayer((RemotePlayer*)m_player);
+		/*
 		m_env->removePlayer(m_player);
+		*/
+		--m_player->refs;
+		m_player = nullptr;
 	}
 }
 
@@ -847,6 +890,8 @@
 {
 	std::ostringstream os(std::ios::binary);
 
+	if (!m_player)
+		return "";
 	if(protocol_version >= 15)
 	{
 		writeU8(os, 1); // version
@@ -857,6 +902,8 @@
 		writeF1000(os, m_player->getYaw());
 		writeS16(os, getHP());
 
+		auto lock = lock_shared_rec();
+
 		writeU8(os, 6 + m_bone_position.size()); // number of messages stuffed in here
 		os<<serializeLongString(getPropertyPacket()); // message 1
 		os<<serializeLongString(gob_cmd_update_armor_groups(m_armor_groups)); // 2
@@ -907,23 +954,29 @@
 
 void PlayerSAO::step(float dtime, bool send_recommended)
 {
+	if (!m_player)
+		return;
+
 	if(!m_properties_sent)
 	{
-		m_properties_sent = true;
 		std::string str = getPropertyPacket();
 		// create message and add to list
 		ActiveObjectMessage aom(getId(), true, str);
 		m_messages_out.push(aom);
+		m_properties_sent = true;
 	}
 
 	// If attached, check that our parent is still there. If it isn't, detach.
 	if(m_attachment_parent_id && !isAttached())
 	{
+	  {
+		auto lock = lock_unique_rec();
 		m_attachment_parent_id = 0;
 		m_attachment_bone = "";
 		m_attachment_position = v3f(0,0,0);
 		m_attachment_rotation = v3f(0,0,0);
 		m_player->setPosition(m_last_good_position);
+	  }
 		((Server*)m_env->getGameDef())->SendMovePlayer(m_peer_id);
 	}
 
@@ -940,9 +993,12 @@
 	// Increment cheat prevention timers
 	m_dig_pool.add(dtime);
 	m_move_pool.add(dtime);
+	{
+		auto lock = lock_unique_rec();
 	m_time_from_last_punch += dtime;
 	m_nocheat_dig_time += dtime;
-
+	m_ms_from_last_respawn += dtime*1000;
+	}
 	// Each frame, parent position is copied if the object is attached, otherwise it's calculated normally
 	// If the object gets detached this comes into effect automatically from the last known origin
 	if(isAttached())
@@ -960,15 +1016,18 @@
 	{
 		m_position_not_sent = false;
 		float update_interval = m_env->getSendRecommendedInterval();
-		v3f pos;
+		v3f pos, vel, acc;
 		if(isAttached()) // Just in case we ever do send attachment position too
 			pos = m_env->getActiveObject(m_attachment_parent_id)->getBasePosition();
 		else
+		{
 			pos = m_player->getPosition() + v3f(0,BS*1,0);
+			vel = m_player->getSpeed();
+		}
 		std::string str = gob_cmd_update_position(
 			pos,
-			v3f(0,0,0),
-			v3f(0,0,0),
+			vel,
+			acc,
 			m_player->getYaw(),
 			true,
 			false,
@@ -989,6 +1048,7 @@
 	}
 
 	if(m_physics_override_sent == false){
+		auto lock = lock_unique_rec();
 		m_physics_override_sent = true;
 		std::string str = gob_cmd_update_physics_override(m_physics_override_speed,
 				m_physics_override_jump, m_physics_override_gravity,
@@ -999,6 +1059,7 @@
 	}
 
 	if(m_animation_sent == false){
+		auto lock = lock_unique_rec();
 		m_animation_sent = true;
 		std::string str = gob_cmd_update_animation(
 			m_animation_range, m_animation_speed, m_animation_blend, m_animation_loop);
@@ -1035,21 +1096,33 @@
 
 void PlayerSAO::setPos(v3f pos)
 {
+	if (!m_player)
+		return;
+
 	if(isAttached())
 		return;
 	m_player->setPosition(pos);
+	{
+	auto lock = lock_unique_rec();
 	// Movement caused by this command is always valid
 	m_last_good_position = pos;
+	}
 	((Server*)m_env->getGameDef())->SendMovePlayer(m_peer_id);
 }
 
 void PlayerSAO::moveTo(v3f pos, bool continuous)
 {
+	if (!m_player)
+		return;
+
 	if(isAttached())
 		return;
 	m_player->setPosition(pos);
+	{
+	auto lock = lock_unique_rec();
 	// Movement caused by this command is always valid
 	m_last_good_position = pos;
+	}
 	((Server*)m_env->getGameDef())->SendMovePlayer(m_peer_id);
 }
 
@@ -1061,15 +1134,29 @@
 
 void PlayerSAO::setPitch(float pitch)
 {
+	if (!m_player)
+		return;
+
 	m_player->setPitch(pitch);
 	((Server*)m_env->getGameDef())->SendMovePlayer(m_peer_id);
 }
 
+void PlayerSAO::addSpeed(v3f speed)
+{
+	if (!m_player)
+		return;
+	m_player->addSpeed(speed);
+	((Server*)m_env->getGameDef())->SendPunchPlayer(m_peer_id, speed);
+}
+
 int PlayerSAO::punch(v3f dir,
 	const ToolCapabilities *toolcap,
 	ServerActiveObject *puncher,
 	float time_from_last_punch)
 {
+	if (!m_player)
+		return 0;
+
 	// It's best that attachments cannot be punched
 	if (isAttached())
 		return 0;
@@ -1113,6 +1200,8 @@
 		}
 	}
 
+	v3f punch = dir * 5 * BS;
+	addSpeed(punch);
 
 	actionstream << "Player " << m_player->getName() << " punched by "
 			<< punchername;
@@ -1132,6 +1221,8 @@
 
 s16 PlayerSAO::getHP() const
 {
+	if (!m_player)
+		return 0;
 	return m_player->hp;
 }
 
@@ -1144,6 +1235,9 @@
 
 void PlayerSAO::setHP(s16 hp)
 {
+	if (!m_player)
+		return;
+
 	s16 oldhp = m_player->hp;
 
 	s16 hp_change = m_env->getScriptIface()->on_player_hpchange(this,
@@ -1161,6 +1255,8 @@
 		return;
 	}
 
+	if (!m_player)
+		return;
 	m_player->hp = hp;
 
 	if (oldhp > hp)
@@ -1173,16 +1269,21 @@
 
 u16 PlayerSAO::getBreath() const
 {
+	if (!m_player)
+		return 0;
 	return m_player->getBreath();
 }
 
 void PlayerSAO::setBreath(u16 breath)
 {
+	if (!m_player)
+		return;
 	m_player->setBreath(breath);
 }
 
 void PlayerSAO::setArmorGroups(const ItemGroupList &armor_groups)
 {
+	auto lock = lock_unique_rec();
 	m_armor_groups = armor_groups;
 	m_armor_groups_sent = false;
 }
@@ -1194,6 +1295,7 @@
 
 void PlayerSAO::setAnimation(v2f frame_range, float frame_speed, float frame_blend, bool frame_loop)
 {
+	auto lock = lock_unique_rec();
 	// store these so they can be updated to clients
 	m_animation_range = frame_range;
 	m_animation_speed = frame_speed;
@@ -1225,6 +1327,7 @@
 
 void PlayerSAO::setAttachment(int parent_id, const std::string &bone, v3f position, v3f rotation)
 {
+	auto lock = lock_unique_rec();
 	// Attachments need to be handled on both the server and client.
 	// If we just attach on the server, we can only copy the position of the parent. Attachments
 	// are still sent to clients at an interval so players might see them lagging, plus we can't
@@ -1286,6 +1389,8 @@
 InventoryLocation PlayerSAO::getInventoryLocation() const
 {
 	InventoryLocation loc;
+	if (!m_player)
+		return loc;
 	loc.setPlayer(m_player->getName());
 	return loc;
 }
@@ -1311,7 +1416,7 @@
 {
 	m_peer_id = 0;
 	m_removed = true;
-	if(m_player->getPlayerSAO() == this)
+	if(m_player && m_player->getPlayerSAO() == this)
 	{
 		m_player->setPlayerSAO(NULL);
 		m_player->peer_id = 0;
@@ -1320,13 +1425,15 @@
 
 std::string PlayerSAO::getPropertyPacket()
 {
-	m_prop.is_visible = (true);
+	// WAT?  m_prop.is_visible = (true);
 	return gob_cmd_set_properties(m_prop);
 }
 
 bool PlayerSAO::checkMovementCheat()
 {
 	bool cheated = false;
+	if (!m_player)
+		return cheated;
 	if(isAttached() || m_is_singleplayer ||
 			g_settings->getBool("disable_anticheat"))
 	{
@@ -1353,8 +1460,7 @@
 			player_max_speed = m_player->movement_speed_walk;
 		}
 		// Tolerance. With the lag pool we shouldn't need it.
-		//player_max_speed *= 2.5;
-		//player_max_speed_up *= 2.5;
+		player_max_speed *= 1.5;
 
 		v3f diff = (m_player->getPosition() - m_last_good_position);
 		float d_vert = diff.Y;
@@ -1377,11 +1483,13 @@
 }
 
 bool PlayerSAO::getCollisionBox(aabb3f *toset) {
+	if (!m_player)
+		return false;
 	//update collision box
 	*toset = m_player->getCollisionbox();
 
-	toset->MinEdge += m_base_position;
-	toset->MaxEdge += m_base_position;
+	toset->MinEdge += getBasePosition();
+	toset->MaxEdge += getBasePosition();
 
 	return true;
 }
